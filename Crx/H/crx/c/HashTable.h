#if(!defined(CRX__C__HASH_TABLE___h__))
#define CRX__C__HASH_TABLE___h__

#include <boost/version.hpp>
#include "Crx/H/crx/crx.h"
#if(CRX__PREPROCESSOR__HAS_PUSH_MACRO)
	#pragma push_macro("CRX__LIB__MODE")
	#undef CRX__LIB__MODE
	#if(!defined(CRX__CONFIG__MODE))
		#define CRX__CONFIG__MODE CRX__LIB__MODE__STAND_ALONE
	#endif
	#define CRX__LIB__MODE CRX__CONFIG__MODE
#else
	#undef CRX__LIB__MODE
	#if(!defined(CRX__LIB__C_MODE))
		#define CRX__LIB__C_MODE CRX__LIB__MODE__STAND_ALONE
	#endif
	#define CRX__LIB__MODE CRX__LIB__C_MODE
#endif
//<<START>>	INCLUDE ".h" OF C NON CRXed CODE THAT THIS HEADER NEEDS.
//			INCLUDE ".h", NOT ".c.h", OF C CRXed CODE.
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <malloc.h>
#include "Crx/H/crx/nonCrxed/standard/stdint.h"
#include "Crx/H/crx/c/TypeBluePrint.h"
#include "Crx/H/crx/c/random/Isaac.h"
//<<END>>

CRX__LIB__C_CODE_BEGIN()

/*
NOTE: THE UNDERLYING DATA MEMEBERS OF THE KHASH STRUCTURE ARE ASSUMED PRIVATE. HENCE, SOME
		ALGORITHMS MIGHT APPEAR SLOWER THAN THEY NEED TO BE.
	- NULL IS ASSUMED 0, OTHERWISE A CONSTRUCT FUNCTION WOULD BE REQUIRED.
	- THE PROBING FUNCTION, MARKED BY THE CODE:
					vIndex = (vIndex + (++vStep)) & vMask; \
			WHICH IS IN A LOOP AMOUNT TO THE NTH vIndex TO BE
					vIndex + SUM[1, N] 	= vIndex + (N + 1)(N / 2)
										= vIndex + (N * N + N)/2
			"(N * N + N)/2" AMOUNTS TO A QUADRATIC PROBING FUNCTION THAT IS GUARANTEED
			TO VISIT EVERY BUCKET IF N, MEANING THE HASHTABLE IS SIZE, IS A POWER OF 2.
	- STICKING TO THE ORIGINAL ALGORITHM, THE CURRENT IMPLEMENTATION CAN LEAD TO A SITUATION
			WHERE gPrivate_keys ENDS UP LARGER THAN NECESSARY. THIS HAPPENS WHEN RESIZING, AND ALLOCATION
			FOR gPrivate_keys WORKS, BUT NOT FOR gPrivate_elements.
	- THERE ARE TWO FLAGS USED FOR EACH BUCKET, AND EACH FLAG IS ONE BIT. CONCEPTUALLY,
			STARTING FROM LEFT, THE FIRST BIT INDICATES WHETHER THE BUCKET WAS EVERY
			USED. THE SECOND BIT INDICATES WHETHER THE CONTENT OF THE BUCKET IS DELETED. HENCE,
			THE FLAGS FOR ONE BUCKET FOLLOW THE FOLLOWING LIFE,
							NEVER USED?		DELETED
							1					0
							0					0
							0					1
							0					0
							0					1
							0					0
									.
									.
			NOTICE:
				- THE FIRST BIT WILL NEVER RETURN TO 1. 
				- AN EMPTY BUCKET IS EITHER 10 OR 01.
				- THE FLAGS 11 ARE IMPOSSIBLE, WILL NEVER HAPPEN.
	- set() IS NOT AS OPTIMAL AS IT CAN BE, BUT TO KEEP THE CODE SIMPLE. FOR EXAMPLE,
			THE FUNCTION WILL CONTINUE TO MAKE A LOCAL COPY OF THE KEY EVEN IF THE
			KEY HAS NO COPY CONSTRUCT FUNCTION NOR MOVE CONSTRUCT FUNCTION.
	- THE setCapacity() CAN SOMETIMES BE USED NOT TO CHANGE THE SIZE, BUT RE HASH. THIS
			IS CURRENTLY INEFFICIENT BECAUSE THE FUNCTION CAN CONTINUE TO ALLOCATE
			MEMORY EVEN THOUGH IT DOES NOT NEET TO.
	- THE setCapacity() FUNCTION CAN BE SLOWER THAN NEEDS TO BE DEPENDING ON THE CATEGORY
			OF THE KEY AND ELEMENT TYPES. HOWEVER, TO KEEP THE IMPLEMENTATION SIMILAR TO
			THE REFERENCE, khash, KEEPING PERFORMANCE AS FAST WHEN THE CATEGORY OF THE
			TYPES INVOLVED IS THE SAME WHERE khash WOULD WORK WITHOUT ERROR, I AVOIDED
			CHANGING THE ALGORITHM. HOWEVER, THIS PROBLEM IS MUCH MORE SERIOUS IN THE
			ORDERED HASH TABLE CASE BECAUSE THERE, WHILE THE CODE REATINS THE ORIGINAL
			ALGORITHM STRUCTURE, NO LONGER BENEFITS FROM ANY SPEED UP NO MATTER THE CATEGORY
			OF KEYS AND ELEMENTS.
	- THE tryMoveKeyAndPrepareBucketFor() FUNCTION, PER THE ORIGINAL CODE, TRIES TO INSERT
			DATA SUCH AS WHEN A VIRTUAL ARRAY IS TRAVERSED, THE LAST, NOT FIRST, EMPTY
			BUCKET SPOTTED IS USED. EMPTY MEANS A BUCKET THAT WAS USED BEFORE, AND THEN WAS
			EMPTIED. I DO NOT KNOW WHY THE ALGORITHM DOES THIS, AND BENCHMARKS I FOUND
			ONLINE DO NOT TEST FOR THE SCENARIO FOR WHEN SUCH AN ALGORITHM WOULD APPARANTLY
			BE A PROBLEM. THEREFORE, I KEPT IT AS IS FOR THE TIME BEING. HOWEVER, NOTE THAT
			THE ALGORITHM DOES USE THE FIRST BUCKET THAT WAS NEVER USED. ALSO NOTE
			THAT EVEN IF THE FIRST EMPTY BUCKET SPOTTED IS TO BE USED, THE ALGORITHM WOULD
			STILL HAVE TO TRAVERSE THE ENTIRE VIRTUAL ARRAY TO MAKE SURE THAT THE KEY 
			DOES NOT ALREADY EXIST. THE SPEED UP WOULD COME FROM THE NEXT TIME THE
			KEY IS READ.
	- NOTE. IF TWO KEYS ARE LOGICALLY EQUAL, THEIR HASHES MUST BE EQUAL. THIS IS WHY
			NO GENERAL PURPOSE HASH FUNCTION CAN BE CONSTRUCTED. ONLY THE DEVELOPER OF THE 
			TYPE OF THE KEY KNOWS WHAT LOGICAL EQUAL KEYS ARE.
	- NOTE THAT setCapacity(), AFTER THE INITIAL MOVING OF DATA TO A NEW BUFFER, IS 
			GUARANTEED TO MOVE DATA AGAIN TWICE ONLY IN THE CASE WHEN DATA IS MOVED OUT
			TO THE STACK, AND THAT MOVE IS THE FIRST MOVE. AND THIS FIRST MOVE IS GUARANTEED
			TO BE WITH THE OLD 'INFORMATION'. THIS MEANS THAT ONCE AN ELEMENT IS MOVED FROM
			IT INCORRECT LOCATION TO ITS CORRECT LOCATION, MEANING FROM THE BUFFER TO THE
			STACK AND BACK TO THE BUFFER, IT IS NOT MOVED AGAIN. WHEN IT COMES TO THE 
			OrderHashTable, THIS IS IMPORTANT BECAUSE OF THE gPrivate_index MEMBER PART
			OF THE KeyNode CLASS THAT MUST CONTINUE TO HOLD ITS OLD VALUE AFTER
			BEING TEMPORARILY MOVED TO THE STACK.
	- IN THE CASE OF OrderHashTable, NOTE THE FOLLOWING,
		- AT SOME POINT SWITCHED TO USING INDICES FOR KeyNode::gPrivate_next AND 
				KeyNode::gPrivate_previous INSTEAD OF POINTERS. THIS WOULD SAVE MEMORY
				UNDER CERTAIN CIRCUMSTANCES. HOWEVER, THIS LOWERS THE MAXIMUM CAPACITY
				TO pSIZE_T / 2
		- SOME OLDER PROBLEMS
			- WE WANT TO AVOID POINTER COMPARISON.
			- WE WANT THE ITERATOR TO BE ALSO uint32_t, MEANING THE SAME AS FOR HashTable, AND 
					ALSO NOT A CLASS AS DEFINED IN MY STANDARD.
		- THE GENERIC IMPLEMENTATION HAS AN EXTRA BUFFER JUST FOR THE KEYS, YET
				THE ALGORITHM DOES NOT REFLECT CHANGES RELATED TO THAT. IN PARTICULAR, NOW
				THAT THE KEYS ARE ON THEIR OWN, AND NOT PART OF THE LINKED LIST NODES,
				ONE COULD USE OPTIMIZATIONS IF THE KEYS ARE RAW COPYABLE, AS DEFINED IN MY
				STANDARD, FOR EXAMPLE, LIKE IS DONE IN THE HashTable CASE. HOWEVER, I
				DID NOT DO THAT TO KEEP THE CODE SYMMETRIC WITH THE TEMPLATE CODE. I MIGHT
				STILL DO THAT IN THE FUTURE.
*/
/*
Naieve performance test: INSERTION 10,000,000 ITEMS
					HashTable			OrderedHashTable				OrderedHashTable
										(with pointers for next			(with integer for
										and previous nodes)				next and previous nodes)
Using 					
setCapacity				31						37							37
setCapacity2			24						27							27

*/
/*
FUTURE DESIGN:

THERE ARE TWO MAJOR CATEGORIES OF HASHTABLE AS I RECOGNIZE THEM.
	- THE FIRST IS WHERE THE BACKING ARRAY HOLDS THE DATA.
	- THE SECOND IS WHERE THE BACKING ARRAY HOLDS DATA STRUCTURES, OR POINTERS TO THEM,
			AND THESE HOLD THE DATA.

NOTE THAT THE FIRST CATEGORY CAN NOT GET AWAY FROM COLLISIONS, AND THEREFORE LIKE THE
SECOND CATEGORY A DATA STRUCTURE WOULD BE REQUIRED TO STORE MULTIPLE ELEMENTS WITH
THE SAME STORAGE 'INDEX' IN THE BACKING ARRAY. HENCE THE FIRST CATEGORY USES WHAT I CALL
VIRTUAL ARRAYS, WHICH ARE ALL SUPER IMPOSED ON THE MAIN BACKING ARRAY.

THE CURRENT HASHTABLE IS FROM THE FIRST CATEGORY.

IN THE FUTURE, CONSIDER IMPLEMENTING THE HASHTABLE USING THE SAME TECHNIQUE BUT INSTEAD
OF VIRTUAL ARRAYS ON THE SAME TWO ARRAYS OF KEYS AND ELEMENTS, ONE WOULD
USE ACTUAL ARRAYS. THIS WOULD BE "SEPERATE CHAINING" BUT WITH ARRAYS INSTEAD
OF LINKED LIST. HOWEVER, YOU WOULD CONTINUE USING THE TECQNIQUE BELOW TO AVOID
MOVING THINGS AROUND THOSE EXTRA ARRAYS. THE BUCKETS IN THIS IMPLEMENTATION BELOW
BECOME "ROOMS", AND EACH ROOM CONTAINING AN ARRAY OF BUCKETS. EACH BUCKET
WOULD HAVE THE SAME MARKERS USED ON THE BUCKETS IN THE IMPLEMENTATION BELOW,
AND HENCE AN ARRAY OF BUCKETS IS NEVER RESIZED UNLESS ALL THE BUCKETS ACTUALLY
ARE FULL. HOWEVER, FOR EACH BUCKET THERE WOULD BE AN EXTRA MARKER THAT SWITCHES 
BETWEEN ZERO AND ONE EACH TIME THE TABLE IS RESIZED. THIS MARKER IS REUSED TO
TO REORGANIZE(REHASH) THE ELEMENTS DURING RESIZE IN PLACE AS AN APPROACH TO REUSE
ALL CURRENTY ALLOCATED ARRAYS. EACH ARRAY ITSELF WOULD BE A STRUCTURE THAT
HOLDS THE MARKER DATA, THE CAPACITY, AND A POINTER TO THE BUFFER HOLDING
THE ELEMENTS AND A POINTER TO AN ARRAY HOLDING THE KEYS. THE MARKER DATA, 
BEING PART OF THE STRUCTURE, MEANS THAT THE INDIVIDUAL ARRY HAS A MAXIMUM CAPACITY 
IT CAN GROW INTO. HOWEVER, THIS APPROACH SAVES AN EXTRA ALLOCATION. WITHOUT THIS 
APPROACH AN ARRAY WOULD REQUIRE FOUR ALLOCATIONS INSTEAD OF THREE. WE COULD ALSO
SAVE AN ALLOCATION BY STORING EACH KEY AND VALUE IN ONE STRUCTURE, BUT THIS WOULD
SLOW DOWN THE ITERATION RATE. THERE WOULD BE TWO VALUES TO CONFIGURE THE TABLE, (X, Y) 
WHRE X IS THE NUMBER OF BUCKETS BEFORE THE TABLE IS RESIZED, AND Y IS THE GROWTH 
FACTOR BASED ON THE NUMBER OF BUCKETS GIVING YOU THE NEW NUMBER OF ROOMS. X WILL 
ALSO BE THE STARTING SIZE OF EACH ARRAY IN THE ROOMS TO REDUCE MEMORY ALLOCATIONS. 
SO FOR EXAMPLE IF THE SETTING IS (4, 1), WHICH IS WHAT I AM RECOMMENDING, THEN IF 
THE HASH TABLE HAS 3 ROOMS, IT WOULD GROW WHEN IT HAS (3 * 4) ELEMENTS, AND IT 
WOULD GROW TO HAVE ((3 * 4) * 1) ROOMS. OTHER GOOD CONFIGURATIONS I THINK ARE (1, 2), 
WHICH IS THE "TRADITIONAL" CASE, AND (2, 2). 

I THINK THE ABOVE DESIGN SHOULD GIVE THE BEST FROM THE SECOND CATEGORY. IT RETAINS GOOD 
GROWTH RATE, AND GOOD ITERATION RATE, AS I DEFINE THESE IN MY STANDARD. IT SHOULD ALSO 
USE LESS MEMORY COMPARED TO IMPLEMENTATIONS THAT USE OTHER HASH TABLES INSTEAD OF 
ARRAYS. IT SHOULD BE FASTER THAN AN IMPLEMENTATION WITH LINKED LISTS WHEN IT COMES TO THE 
ITERATION RATE BECAUSE OF BETTER DATA LOCALITY, AND FASTER THAN THE IMPLEMENTATION 
BELOW WHEN IT COMES TO ACCESS RATE ON AN OLD TABLE BECAUSE OF MUCH BETTER BOUNDED 
STATISTICAL ACCESS COST. HOWEVER, IT WOULD NOT BE SURPRISING IF THE IMPLEMENTATION BELOW 
REMAINS THE FASTEST FOR GENERAL USE. ALSO, UNLIKE AN IMPLEMENTATION USING LINKED LISTS, 
USING ARRAYS CAN MAKE FAILURES DURING RESIZE DAMAGING, AND THE ONLY WAY TO RECOVER IS TO 
WRITE AN ALGORITHM SPECIFICALLY FOR RECOVERY. THIS IS ALSO UNLIKE THE IMPLEMENTATION 
BELOW. THIS IS BECAUSE, UNLIKE THE IMPLEMENTATION BELOW, AND THE IMPLEMENTATIONS USING A 
LINKED LIST, USING ARRAYS REQUIRES MORE THAN ZERO ALLOCATIONS AFTER THE MOVING PROCESS 
HAS STARTED DURING RESIZE. 
*/

/*	USAGE
	- pFUNC_ARE_KEYS_EQUAL IS A FUNCTION WITH THE SIGNATURE:
			bool function(const * pKEY_TYPE, const * pKEY_TYPE)
	- pFUNC_COMPUTE_HASH IS A FUNCTION WITH THE SIGNATURE:
			pSIZE_T function(size_t pSeed, const * pKEY_TYPE)
	- OVERRIDES (DECLARE, DEFINE):	(KEYS ARE COPYABLE)
		- KEYS ONLY:										(11 PARAMETERS)
				CRX__C__HashTable__DECLARE(pHASH_TABLE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX,
						pSIZE_T, pSIZE_T_MAX,
						pKEY_TYPE, pFUNC_KEY_DESTRUCTOR,
						pFUNC_KEY_COPY_CONSTRUCTOR,
						pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR,
						pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH)
		- KEYS AND ELEMENTS:								(15 OR 16 PARAMETERS)
				CRX__C__HashTable__DECLARE(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX,
						pSIZE_T, pSIZE_T_MAX,
						pKEY_TYPE, pFUNC_KEY_DESTRUCTOR,
						pFUNC_KEY_COPY_CONSTRUCTOR,
						pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR,
						pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH,
						pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR,
						[pFUNC_ELEMENT_COPY_CONSTRUCTOR,]
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)
	- OVERRIDES (DECLARE2, DEFINE2): (KEYS ARE NOT COPYABLE)
		- KEYS ONLY:										(10 PARAMETERS)
				CRX__C__HashTable__DECLARE2(pHASH_TABLE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX,
						pSIZE_T, pSIZE_T_MAX,
						pKEY_TYPE, pFUNC_KEY_DESTRUCTOR,
						pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR,
						pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH)
		- KEYS AND ELEMENTS:								(14 OR 15 PARAMETERS)
				CRX__C__HashTable__DECLARE2(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX,
						pSIZE_T, pSIZE_T_MAX,
						pKEY_TYPE, pFUNC_KEY_DESTRUCTOR,
						pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR,
						pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH,
						pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR,
						[pFUNC_ELEMENT_COPY_CONSTRUCTOR,]
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)
				
*/

#if(UINT32_MAX < SIZE_MAX)
	#define CRX__C__HASH_TABLE__IS_TO_GENERATE_UINT64_RANDOM CRXM__FALSE
#else
	#define CRX__C__HASH_TABLE__IS_TO_GENERATE_UINT64_RANDOM CRXM__TRUE
#endif


#if(!CRX_ARE_VARIADIC_MACROS_EMULATED)
	#define CRX__C__HashTable__DECLARE(...) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__HashTable__DECLARE, __VA_ARGS__)
#else
	#define CRX__C__HashTable__DECLARE(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__HashTable__DECLARE, p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
#endif

/*KEYS ONLY				(KEYS COPYABLE)*/
#define CRX__C__HashTable__DECLARE__11(pHASH_TABLE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH) \
_CRX__C__HashTable__DECLARE(pHASH_TABLE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__TRUE, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
\
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION()) \

/*KEYS AND ELEMENTS.	(KEYS COPYABLE)*/
#define CRX__C__HashTable__DECLARE__15(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__HashTable__DECLARE(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		\
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
#define CRX__C__HashTable__DECLARE__16(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__HashTable__DECLARE(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		\
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())


#if(!CRX_ARE_VARIADIC_MACROS_EMULATED)
	#define CRX__C__HashTable__DECLARE2(...) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__HashTable__DECLARE2, __VA_ARGS__)
#else
	#define CRX__C__HashTable__DECLARE2(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__HashTable__DECLARE2, p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
#endif

/*KEYS ONLY				(KEYS NOT COPYABLE)*/
#define CRX__C__HashTable__DECLARE2__10(pHASH_TABLE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH) \
_CRX__C__HashTable__DECLARE(pHASH_TABLE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__TRUE, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		\
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION()) \

/*KEYS AND ELEMENTS.	(KEYS NOT COPYABLE)*/
#define CRX__C__HashTable__DECLARE2__14(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__HashTable__DECLARE(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		\
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
#define CRX__C__HashTable__DECLARE2__15(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__HashTable__DECLARE(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		\
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())


#define _CRX__C__HashTable__DECLARE(pHASH_TABLE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pIS_KEYS_ONLY, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pIS_KEY_COPYABLE, pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pIS_ELEMENT_COPYABLE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		PUBLIC, PRIVATE) \
	\
	typedef struct pHASH_TABLE_TYPE_NAME \
	{ \
		pSIZE_T gPrivate_numberOfBuckets; \
		pSIZE_T gPrivate_size; \
		pSIZE_T gPrivate_numberOfBucketsEverUsed; \
		pSIZE_T gPrivate_upperBoundOfNumberOfBucketsEverUsed; \
		size_t gPrivate_seed; \
		uint32_t * gPrivate_bucketData; \
		pKEY_TYPE * gPrivate_keys; \
		CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
		pELEMENT_TYPE * gPrivate_elements;, ) \
	} pHASH_TABLE_TYPE_NAME; \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## construct(pHASH_TABLE_TYPE_NAME * pThis); \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## copyConstruct(pHASH_TABLE_TYPE_NAME * pThis, \
			pHASH_TABLE_TYPE_NAME const * CRX_NOT_NULL pHashTable); \
	PUBLIC pHASH_TABLE_TYPE_NAME * pMEMBER_FUNCTIONS_PREFIX ## new(); \
	PUBLIC pHASH_TABLE_TYPE_NAME * pMEMBER_FUNCTIONS_PREFIX ## moveNew( \
			pHASH_TABLE_TYPE_NAME * pHashTable); \
	PUBLIC pHASH_TABLE_TYPE_NAME * pMEMBER_FUNCTIONS_PREFIX ## copyNew( \
			pHASH_TABLE_TYPE_NAME const * pHashTable); \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## destruct(pHASH_TABLE_TYPE_NAME * pThis); \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## free(pHASH_TABLE_TYPE_NAME * pThis); \
	\
	CRX__C__TYPE_BLUE_PRINT__DECLARE_GET_BLUE_PRINT( \
			pHASH_TABLE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
			CRXM__TRUE, CRXM__TRUE, \
			CRXM__AND(pIS_KEY_COPYABLE, CRXM__OR(pIS_KEYS_ONLY, pIS_ELEMENT_COPYABLE)), CRXM__TRUE, \
			CRXM__FALSE, CRXM__FALSE); \
	\
	PRIVATE pSIZE_T pMEMBER_FUNCTIONS_PREFIX ## private_get(pHASH_TABLE_TYPE_NAME const * pThis, \
			pKEY_TYPE const * pKey); \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## empty(pHASH_TABLE_TYPE_NAME * pThis); \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_setCapacity(pHASH_TABLE_TYPE_NAME * pThis, \
			pSIZE_T pNumberOfBuckets); \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_setCapacity2(pHASH_TABLE_TYPE_NAME * pThis, \
			pSIZE_T pNumberOfBuckets); \
	PRIVATE pSIZE_T pMEMBER_FUNCTIONS_PREFIX ## private_tryMoveKeyAndPrepareBucketFor( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE * pKey, int * pReturn); \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_deleteElementAt(pHASH_TABLE_TYPE_NAME * pThis, \
			pSIZE_T pBucketIndex); \
	\
	PUBLIC pSIZE_T pMEMBER_FUNCTIONS_PREFIX ## getSize(pHASH_TABLE_TYPE_NAME const * pThis); \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndElementAndSet( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE * pKey, pELEMENT_TYPE * pElement);, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndSet( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE * pKey, pELEMENT_TYPE const * pElement);, \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndSet( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE * pKey);) \
	CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## tryMoveElementAndSet( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE const * pKey, pELEMENT_TYPE * pElement);, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## set( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE const * pKey, pELEMENT_TYPE const * pElement);, \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## set( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE const * pKey); ) \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
	PUBLIC pELEMENT_TYPE * pMEMBER_FUNCTIONS_PREFIX ## get(pHASH_TABLE_TYPE_NAME * pThis, \
			pKEY_TYPE const * pKey);, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
	PUBLIC pELEMENT_TYPE const * pMEMBER_FUNCTIONS_PREFIX ## constantGet( \
			pHASH_TABLE_TYPE_NAME const * pThis, pKEY_TYPE const * pKey);, ) \
	CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), pIS_ELEMENT_COPYABLE), \
	CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_DESTRUCTOR), \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## copyGetTo(pHASH_TABLE_TYPE_NAME const * pThis, \
			pELEMENT_TYPE * pReturn, pKEY_TYPE const * pKey);, \
	PUBLIC pELEMENT_TYPE pMEMBER_FUNCTIONS_PREFIX ## copyGet(pHASH_TABLE_TYPE_NAME const * pThis, \
			pKEY_TYPE const * pKey);), ) \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## hasKey(pHASH_TABLE_TYPE_NAME const * pThis, \
			pKEY_TYPE const * pKey); \
	\
	PUBLIC pKEY_TYPE const * pMEMBER_FUNCTIONS_PREFIX ## getKeyFromIndex( \
			pHASH_TABLE_TYPE_NAME const * pThis, size_t pIndex); \
	PUBLIC pELEMENT_TYPE const * pMEMBER_FUNCTIONS_PREFIX ## getElementFromIndex( \
			pHASH_TABLE_TYPE_NAME const * pThis, size_t pIndex); \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## remove(pHASH_TABLE_TYPE_NAME * pThis, \
			pKEY_TYPE const * pKey); \
	\
	CRX__LIB__PUBLIC_INLINE_C_FUNCTION() pSIZE_T pMEMBER_FUNCTIONS_PREFIX ## getStartIndex( \
			pHASH_TABLE_TYPE_NAME const * pThis); \
	CRX__LIB__PUBLIC_INLINE_C_FUNCTION() pSIZE_T pMEMBER_FUNCTIONS_PREFIX ## getEndIndex( \
			pHASH_TABLE_TYPE_NAME const * pThis); \
	CRX__LIB__PUBLIC_INLINE_C_FUNCTION() pSIZE_T pMEMBER_FUNCTIONS_PREFIX ## getNextIndex( \
			pHASH_TABLE_TYPE_NAME const * pThis, size_t pIndex); \
	\
	PRIVATE size_t pMEMBER_FUNCTIONS_PREFIX ## prepareSeedForHash( \
			void const * pPointer, void const * pPointer2);
//#END_DEFINE

#if(!CRX_ARE_VARIADIC_MACROS_EMULATED)
	#define CRX__C__HashTable__DEFINE(...) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__HashTable__DEFINE, __VA_ARGS__)
#else
	#define CRX__C__HashTable__DEFINE(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__HashTable__DEFINE, p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
#endif

/*KEYS ONLY.	(KEYS COPYABLE)*/
#define CRX__C__HashTable__DEFINE__11(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH) \
_CRX__C__HashTable__DEFINE(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__TRUE, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		\
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())

/*KEYS AND ELEMENTS.	(KEYS COPYABLE)*/
#define CRX__C__HashTable__DEFINE__15(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__HashTable__DEFINE(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		\
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
#define CRX__C__HashTable__DEFINE__16(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__HashTable__DEFINE(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
\
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())


#if(!CRX_ARE_VARIADIC_MACROS_EMULATED)
	#define CRX__C__HashTable__DEFINE2(...) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__HashTable__DEFINE2, __VA_ARGS__)
#else
	#define CRX__C__HashTable__DEFINE2(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__HashTable__DEFINE2, p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
#endif

/*KEYS ONLY.			(KEYS NOT COPYABLE)*/
#define CRX__C__HashTable__DEFINE2__10(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH) \
_CRX__C__HashTable__DEFINE(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__TRUE, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		\
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())

/*KEYS AND ELEMENTS.	(KEYS NOT COPYABLE)*/
#define CRX__C__HashTable__DEFINE2__14(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__HashTable__DEFINE(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		\
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
#define CRX__C__HashTable__DEFINE2__15(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__HashTable__DEFINE(pHASH_TABLE_TYPE_NAME, pHASH_TABLE_MEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		\
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
		
		
#define _CRX__C__HashTable__DEFINE(pHASH_TABLE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pIS_KEYS_ONLY, pKEY_TYPE, pFUNC_KEY_DESTRUCTOR, \
		pIS_KEY_COPYABLE, pFUNC_KEY_COPY_CONSTRUCTOR, \
		pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR, \
		pFUNC_ARE_KEYS_EQUAL, pFUNC_COMPUTE_HASH, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pIS_ELEMENT_COPYABLE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		PUBLIC, PRIVATE) \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## construct(pHASH_TABLE_TYPE_NAME * pThis) \
	{ \
		pThis->gPrivate_numberOfBuckets = 0; \
		pThis->gPrivate_size = 0; \
		pThis->gPrivate_numberOfBucketsEverUsed = 0; \
		pThis->gPrivate_upperBoundOfNumberOfBucketsEverUsed = 0; \
		pThis->gPrivate_seed = 0; \
		pThis->gPrivate_bucketData = NULL; \
		pThis->gPrivate_keys = NULL; \
		CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
		pThis->gPrivate_elements = NULL;, ) \
	} \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## copyConstruct(pHASH_TABLE_TYPE_NAME * pThis, \
			pHASH_TABLE_TYPE_NAME const * CRX_NOT_NULL pHashTable) \
	{ \
		CRXM__IFELSE2(CRXM__OR(CRXM__NOT(pIS_KEY_COPYABLE), \
				CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), \
						CRXM__NOT(pIS_ELEMENT_COPYABLE))), abort();, \
	\
		CRX__SET_TO_ZERO(pHASH_TABLE_TYPE_NAME, *pThis); \
	\
		if(pMEMBER_FUNCTIONS_PREFIX ## private_setCapacity(pThis, pHashTable->gPrivate_size)) \
		{ \
			CRX_FOR(pSIZE_T tI = 0, tI != pHashTable->gPrivate_numberOfBuckets, ++tI) \
			{ \
				if(CRX__C__HashTable__IS_BUCKET_EMPTY(pHashTable->gPrivate_bucketData, tI)) \
					{continue;} \
	\
				CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## set(pThis, pHashTable->gPrivate_keys + tI, \
							pHashTable->gPrivate_elements + tI); \
				) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## set(pThis, pHashTable->gPrivate_keys + tI); \
				) \
			} \
			CRX_ENDFOR \
		} \
	)} \
	\
	PUBLIC pHASH_TABLE_TYPE_NAME * pMEMBER_FUNCTIONS_PREFIX ## new() \
	{ \
		pHASH_TABLE_TYPE_NAME * vReturn = (pHASH_TABLE_TYPE_NAME *)(calloc(1, \
				sizeof(pHASH_TABLE_TYPE_NAME))); \
	\
		if(vReturn != NULL) \
			{pMEMBER_FUNCTIONS_PREFIX ## construct(vReturn);} \
	\
		return vReturn; \
	} \
	\
	PUBLIC pHASH_TABLE_TYPE_NAME * pMEMBER_FUNCTIONS_PREFIX ## moveNew( \
			pHASH_TABLE_TYPE_NAME * pHashTable) \
	{ \
		pHASH_TABLE_TYPE_NAME * vReturn = (pHASH_TABLE_TYPE_NAME *)(calloc(1, \
				sizeof(pHASH_TABLE_TYPE_NAME))); \
	\
		if(vReturn != NULL) \
			{memcpy(vReturn, pHashTable, sizeof(pHASH_TABLE_TYPE_NAME));} \
	\
		return vReturn; \
	} \
	\
	PUBLIC pHASH_TABLE_TYPE_NAME * pMEMBER_FUNCTIONS_PREFIX ## copyNew( \
			pHASH_TABLE_TYPE_NAME const * pHashTable) \
	{ \
		CRXM__IFELSE2(CRXM__OR(CRXM__NOT(pIS_KEY_COPYABLE), \
				CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), \
						CRXM__NOT(pIS_ELEMENT_COPYABLE))), abort();, \
	\
		pHASH_TABLE_TYPE_NAME * vReturn = (pHASH_TABLE_TYPE_NAME *)(calloc(1, \
				sizeof(pHASH_TABLE_TYPE_NAME))); \
	\
		if(vReturn != NULL) \
			{pMEMBER_FUNCTIONS_PREFIX ## copyConstruct(vReturn, pHashTable);} \
	\
		return vReturn; \
	)} \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## destruct(pHASH_TABLE_TYPE_NAME * pThis) \
	{ \
		CRXM__IFELSE2(CRXM__OR(pFUNC_KEY_DESTRUCTOR, CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), \
				pFUNC_ELEMENT_DESTRUCTOR)), \
		pMEMBER_FUNCTIONS_PREFIX ## empty(pThis);, ) \
	\
		free((void *) pThis->gPrivate_keys); \
		pThis->gPrivate_keys = NULL; \
		free(pThis->gPrivate_bucketData); \
		pThis->gPrivate_bucketData = NULL; \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
		( \
			free((void *) pThis->gPrivate_elements); \
			pThis->gPrivate_elements = NULL; \
		)() \
	} \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## free(pHASH_TABLE_TYPE_NAME * pThis) \
		{free(pThis);} \
	\
	CRX__C__TYPE_BLUE_PRINT__DEFINE_GET_BLUE_PRINT( \
			pHASH_TABLE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
			CRXM__TRUE, CRXM__TRUE, \
			CRXM__AND(pIS_KEY_COPYABLE, CRXM__OR(pIS_KEYS_ONLY, pIS_ELEMENT_COPYABLE)), CRXM__TRUE, \
			CRXM__FALSE, CRXM__FALSE) \
	\
	PRIVATE pSIZE_T pMEMBER_FUNCTIONS_PREFIX ## private_get(pHASH_TABLE_TYPE_NAME const * pThis, \
			pKEY_TYPE const * pKey) \
	{																	\
		if(pThis->gPrivate_numberOfBuckets == 0) \
			{return 0;} \
	\
		pSIZE_T vMask = pThis->gPrivate_numberOfBuckets - 1; \
		pSIZE_T vIndex = ((pSIZE_T)pFUNC_COMPUTE_HASH(pThis->gPrivate_seed, pKey)) & vMask; \
		pSIZE_T vLastIndex = vIndex; \
		pSIZE_T vStep = 0; \
	\
		while(!CRX__C__HashTable__WAS_BUCKET_NEVER_FILLED(pThis->gPrivate_bucketData, vIndex) && \
				(CRX__C__HashTable__IS_BUCKET_CONTENT_DELETED(pThis->gPrivate_bucketData, vIndex) || \
				!pFUNC_ARE_KEYS_EQUAL(pThis->gPrivate_keys + vIndex, pKey))) \
		{ \
			vIndex = (vIndex + (++vStep)) & vMask; \
	\
			if(vIndex == vLastIndex) \
				{return pThis->gPrivate_numberOfBuckets;} \
		} \
	\
		return (CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, vIndex) ? \
				pThis->gPrivate_numberOfBuckets : vIndex); \
	} \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## empty(pHASH_TABLE_TYPE_NAME * pThis) \
	{ \
		if(pThis->gPrivate_bucketData != NULL) \
		{ \
			CRXM__IFELSE(CRXM__OR(CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), \
					pFUNC_ELEMENT_DESTRUCTOR), pFUNC_KEY_DESTRUCTOR)) \
			( \
				CRX_FOR(pSIZE_T tI = 0, \
						tI != pThis->gPrivate_numberOfBuckets, ++tI) \
				{ \
					if(CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, \
							tI)) \
						{continue;} \
	\
					CRXM__IFELSE(CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), \
							pFUNC_ELEMENT_DESTRUCTOR)) \
					( \
						pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_elements + tI); \
					)() \
					CRXM__IFELSE(pFUNC_KEY_DESTRUCTOR) \
					( \
						pFUNC_KEY_DESTRUCTOR(pThis->gPrivate_keys + tI); \
					)() \
				} \
				CRX_ENDFOR \
			)() \
	\
			memset(pThis->gPrivate_bucketData, 0xaa, \
					CRX__C__HashTable__GET_SIZE_OF_BUCKET_DATA( \
					pThis->gPrivate_numberOfBuckets) * sizeof(uint32_t)); \
			pThis->gPrivate_size = 0; \
			pThis->gPrivate_numberOfBucketsEverUsed = 0; \
		} \
	} \
	\
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_setCapacity(pHASH_TABLE_TYPE_NAME * pThis, \
			pSIZE_T pNumberOfBuckets) \
	{ /* This function uses 0.25*gPrivate_numberOfBuckets bytes of working space instead of [sizeof(key_t+val_t)+.25]*gPrivate_numberOfBuckets. */ \
		CRX_SCOPE_META \
		if(pNumberOfBuckets > ((pSIZE_T_MAX >> 1) + 1)) \
			{return false;} \
	\
		CRX_SCOPE \
		uint32_t * vBucketData = NULL; \
		pSIZE_T vNumberOfBuckets = CRX__C__HashTable__ROUND_UP_TO_POWER_OF_TWO( \
				pNumberOfBuckets); \
		bool vIsRehashingRequired = true; \
	\
		{ \
			if(vNumberOfBuckets < 4) \
				{vNumberOfBuckets = 4;} \
	\
			if(pThis->gPrivate_size >= (pSIZE_T)(vNumberOfBuckets * 0.77 + 0.5)) \
				{vIsRehashingRequired = false;}	/* requested gPrivate_size is too small */ \
			else \
			{ /* hash table gPrivate_size to be changed (shrink or expand); rehash */ \
				vBucketData = (uint32_t *)(malloc( \
						CRX__C__HashTable__GET_SIZE_OF_BUCKET_DATA(vNumberOfBuckets) * \
						sizeof(uint32_t)));	\
	\
				if(vBucketData != NULL) \
				{ \
					memset(vBucketData, 0xaa, \
							CRX__C__HashTable__GET_SIZE_OF_BUCKET_DATA(vNumberOfBuckets) * \
							sizeof(uint32_t)); \
	\
					if(pThis->gPrivate_numberOfBuckets < vNumberOfBuckets) \
					{	/* expand */ \
						pKEY_TYPE * tKeys; \
	\
						CRXM__IFELSE(CRXM__OR(pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR)) \
						( \
							tKeys = (pKEY_TYPE*)(malloc(vNumberOfBuckets * sizeof(pKEY_TYPE))); \
	\
							if(tKeys != NULL) \
							{ \
								CRXM__IFELSE(pFUNC_KEY_MOVE_CONSTRUCTOR) \
								( \
									CRX_FOR(pSIZE_T tI = 0, tI < pThis->gPrivate_numberOfBuckets, tI++) \
									{ \
										if(CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, tI)) \
											{continue;} \
	\
										pFUNC_KEY_MOVE_CONSTRUCTOR( \
												tKeys + tI, pThis->gPrivate_keys + tI); \
	\
										CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
										pFUNC_KEY_MOVE_DESTRUCTOR(pThis->gPrivate_keys + tI);, ) \
									} \
									CRX_ENDFOR \
								) \
								( \
									memcpy(tKeys, pThis->gPrivate_keys, \
											pThis->gPrivate_numberOfBuckets * sizeof(pKEY_TYPE)); \
	\
									CRX_FOR(pSIZE_T tI = 0, tI < pThis->gPrivate_numberOfBuckets, tI++) \
									{ \
										if(CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, tI)) \
											{continue;} \
	\
										pFUNC_KEY_MOVE_DESTRUCTOR(pThis->gPrivate_keys + tI); \
									} \
									CRX_ENDFOR \
								) \
	\
								free(pThis->gPrivate_keys); \
								pThis->gPrivate_keys = tKeys; \
							} \
							else \
							{ \
								free(vBucketData); \
								vBucketData = NULL; \
							} \
						) \
						( \
							tKeys = (pKEY_TYPE*)realloc((void *)pThis->gPrivate_keys, vNumberOfBuckets * sizeof(pKEY_TYPE)); \
	\
							if(!tKeys) \
							{ \
								free(vBucketData); \
								vBucketData = NULL; \
							} \
							else \
								{pThis->gPrivate_keys = tKeys;} \
						) \
	\
						CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
						( \
							if(tKeys != NULL) \
							{ \
								pELEMENT_TYPE * tElements; \
	\
								CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, \
										pFUNC_ELEMENT_MOVE_DESTRUCTOR)) \
								( \
									tElements = (pELEMENT_TYPE*)(malloc( \
											vNumberOfBuckets * sizeof(pELEMENT_TYPE))); \
	\
									if(tElements != NULL) \
									{ \
										CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
										( \
											CRX_FOR(pSIZE_T tI = 0, \
													tI < pThis->gPrivate_numberOfBuckets, tI++) \
											{ \
												if(CRX__C__HashTable__IS_BUCKET_EMPTY( \
														pThis->gPrivate_bucketData, tI) == 0) \
												{ \
													pFUNC_ELEMENT_MOVE_CONSTRUCTOR(tElements + tI, \
															pThis->gPrivate_elements + tI); \
	\
													CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
													pFUNC_ELEMENT_MOVE_DESTRUCTOR( \
															pThis->gPrivate_elements + tI);, ) \
												} \
											} \
											CRX_ENDFOR \
										) \
										( \
											memcpy(tElements, pThis->gPrivate_elements, \
													pThis->gPrivate_numberOfBuckets * \
													sizeof(pELEMENT_TYPE)); \
	\
											CRX_FOR(pSIZE_T tI = 0, \
													tI < pThis->gPrivate_numberOfBuckets, tI++) \
											{ \
												if(CRX__C__HashTable__IS_BUCKET_EMPTY( \
														pThis->gPrivate_bucketData, tI) == 0) \
												{ \
													pFUNC_ELEMENT_MOVE_DESTRUCTOR( \
															pThis->gPrivate_elements + tI); \
												} \
											} \
											CRX_ENDFOR \
										) \
	\
										free(pThis->gPrivate_elements); \
										pThis->gPrivate_elements = tElements; \
									} \
									else \
									{ \
										free(vBucketData); \
										vBucketData = NULL; \
									} \
								) \
								( \
									tElements = (pELEMENT_TYPE*)realloc((void *)pThis->gPrivate_elements, \
											vNumberOfBuckets * sizeof(pELEMENT_TYPE)); \
	\
									if(!tElements) \
									{ \
										free(vBucketData); \
										vBucketData = NULL; \
									} \
									else \
										{pThis->gPrivate_elements = tElements;} \
								) \
							} \
						)() \
					} /* otherwise shrink */ \
				} \
			} \
		} \
	\
		if(vBucketData != NULL) \
		{ \
			if(vIsRehashingRequired) \
			{ /* rehashing is needed */ \
				size_t tSeed = 0; \
				unsigned char * tKey = (unsigned char *) CRX__ALLOCA(sizeof(pKEY_TYPE)); \
				unsigned char * tKey_temp = (unsigned char *) CRX__ALLOCA(sizeof(pKEY_TYPE)); \
				CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
				unsigned char * tElement = (unsigned char *) CRX__ALLOCA( \
						sizeof(pELEMENT_TYPE));, ) \
				CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
				unsigned char * tElement_tmp = (unsigned char *) CRX__ALLOCA( \
						sizeof(pELEMENT_TYPE));, ) \
	\
				if(pThis->gPrivate_numberOfBuckets <= vNumberOfBuckets) \
				{ \
					CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
					( \
						tSeed = pMEMBER_FUNCTIONS_PREFIX ## prepareSeedForHash(pThis->gPrivate_keys, \
								pThis->gPrivate_elements); \
					) \
					( \
						tSeed = pMEMBER_FUNCTIONS_PREFIX ## prepareSeedForHash(pThis, \
								pThis->gPrivate_keys); \
					) \
				} \
				else \
				{ \
					CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
					( \
						tSeed = pMEMBER_FUNCTIONS_PREFIX ## prepareSeedForHash(pThis->gPrivate_keys, \
								pThis->gPrivate_elements + 101); \
					) \
					( \
						tSeed = pMEMBER_FUNCTIONS_PREFIX ## prepareSeedForHash(pThis, \
								pThis->gPrivate_keys + 101); \
					) \
				} \
	\
				CRX_FOR(pSIZE_T tI = 0, tI != pThis->gPrivate_numberOfBuckets, ++tI) \
				{ \
					if(CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, tI) == 0) \
					{ \
						pSIZE_T tNewMask = vNumberOfBuckets - 1; \
	\
						CRXM__IFELSE(CRXM__AND(CRXM__AND(pIS_KEY_COPYABLE, \
								CRXM__NOT(pFUNC_KEY_COPY_CONSTRUCTOR)), \
								CRXM__NOT(pFUNC_KEY_DESTRUCTOR))) \
						( \
							memcpy(tKey, pThis->gPrivate_keys + tI, sizeof(pKEY_TYPE)); \
						) \
						( \
							CRXM__IFELSE(pFUNC_KEY_MOVE_CONSTRUCTOR) \
							( \
								pFUNC_KEY_MOVE_CONSTRUCTOR(((pKEY_TYPE *)tKey), \
										pThis->gPrivate_keys + tI); \
							) \
							( \
								memcpy(tKey, pThis->gPrivate_keys + tI, sizeof(pKEY_TYPE)); \
							) \
	\
							CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
							pFUNC_KEY_MOVE_DESTRUCTOR(pThis->gPrivate_keys + tI), ); \
						) \
	\
						CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
						( \
							CRXM__IFELSE(CRXM__AND(CRXM__AND(pIS_ELEMENT_COPYABLE, \
									CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR)), \
									CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))) \
							( \
								memcpy(tElement, pThis->gPrivate_elements + tI, \
										sizeof(pELEMENT_TYPE)); \
							) \
							( \
								CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
								( \
									pFUNC_ELEMENT_MOVE_CONSTRUCTOR(((pELEMENT_TYPE *)tElement), \
											pThis->gPrivate_elements + tI); \
								) \
								( \
									memcpy(tElement, pThis->gPrivate_elements + tI, \
											sizeof(pELEMENT_TYPE)); \
								) \
	\
								CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR(pThis->gPrivate_elements + tI);, ) \
							) \
						)() \
	\
						CRX__C__HashTable__MARK_BUCKET_CONTENT_DELETED( \
								pThis->gPrivate_bucketData, tI); \
	\
						while(true) \
						{ /* kick-out process; sort of like in Cuckoo hashing */ \
							pSIZE_T tIndex = ((pSIZE_T)pFUNC_COMPUTE_HASH(tSeed, \
									((pKEY_TYPE *)tKey))) & tNewMask; \
							pSIZE_T tStep = 0; \
	\
							while(!CRX__C__HashTable__WAS_BUCKET_NEVER_FILLED(vBucketData, \
									tIndex)) \
								{tIndex = (tIndex + (++tStep)) & tNewMask;} \
	\
							CRX__C__HashTable__MARK_BUCKET_EVER_FILLED(vBucketData, tIndex);	\
	\
							if((tIndex < pThis->gPrivate_numberOfBuckets) && \
									(CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, tIndex) == 0)) \
							{ /* kick out the existing element */ \
								{ \
									CRXM__IFELSE(CRXM__AND(CRXM__AND(pIS_KEY_COPYABLE, \
											CRXM__NOT(pFUNC_KEY_COPY_CONSTRUCTOR)), \
											CRXM__NOT(pFUNC_KEY_DESTRUCTOR))) \
									( \
										memcpy(tKey_temp, pThis->gPrivate_keys + tIndex, \
												sizeof(pKEY_TYPE)); \
										memcpy(pThis->gPrivate_keys + tIndex, tKey, \
												sizeof(pKEY_TYPE)); \
										memcpy(tKey, tKey_temp, sizeof(pKEY_TYPE)); \
									) \
									( \
										CRXM__IFELSE(pFUNC_KEY_MOVE_CONSTRUCTOR) \
										( \
											pFUNC_KEY_MOVE_CONSTRUCTOR(((pKEY_TYPE *)tKey_temp), \
													pThis->gPrivate_keys + tIndex); \
											CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
											pFUNC_KEY_MOVE_DESTRUCTOR(pThis->gPrivate_keys + \
													tIndex);, ) \
	\
											pFUNC_KEY_MOVE_CONSTRUCTOR(pThis->gPrivate_keys + \
													tIndex, ((pKEY_TYPE *)tKey)); \
											CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
											pFUNC_KEY_MOVE_DESTRUCTOR(((pKEY_TYPE *)tKey));, ) \
	\
											pFUNC_KEY_MOVE_CONSTRUCTOR(((pKEY_TYPE *)tKey), \
													((pKEY_TYPE *)tKey_temp)); \
											CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
											pFUNC_KEY_MOVE_DESTRUCTOR(((pKEY_TYPE *)tKey_temp));, ) \
										) \
										( \
											memcpy(tKey_temp, pThis->gPrivate_keys + tIndex, \
													sizeof(pKEY_TYPE)); \
											CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
											pFUNC_KEY_MOVE_DESTRUCTOR( \
													pThis->gPrivate_keys + tIndex);, ) \
	\
											memcpy(pThis->gPrivate_keys + tIndex, tKey, \
													sizeof(pKEY_TYPE)); \
											CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
											pFUNC_KEY_MOVE_DESTRUCTOR(((pKEY_TYPE *)tKey));, ) \
	\
											memcpy(tKey, tKey_temp, sizeof(pKEY_TYPE)); \
											CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
											pFUNC_KEY_MOVE_DESTRUCTOR(((pKEY_TYPE *)tKey_temp));, ) \
										) \
									) \
								} \
	\
								CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
								( \
									CRXM__IFELSE(CRXM__AND(CRXM__AND(pIS_ELEMENT_COPYABLE, \
											CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR)), \
											CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))) \
									( \
										memcpy(tElement_tmp, pThis->gPrivate_elements + tIndex, \
												sizeof(pELEMENT_TYPE)); \
										memcpy(pThis->gPrivate_elements + tIndex, tElement, \
												sizeof(pELEMENT_TYPE)); \
										memcpy(tElement, tElement_tmp, sizeof(pELEMENT_TYPE)); \
									) \
									( \
										CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
										( \
											pFUNC_ELEMENT_MOVE_CONSTRUCTOR( \
													((pELEMENT_TYPE *)tElement_tmp), \
													pThis->gPrivate_elements + tIndex); \
											CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
											pFUNC_ELEMENT_MOVE_DESTRUCTOR( \
													pThis->gPrivate_elements + tIndex), ); \
	\
											pFUNC_ELEMENT_MOVE_CONSTRUCTOR( \
													pThis->gPrivate_elements + tIndex, \
													((pELEMENT_TYPE *)tElement)); \
											CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
											pFUNC_ELEMENT_MOVE_DESTRUCTOR( \
													((pELEMENT_TYPE *)tElement));, ) \
	\
											pFUNC_ELEMENT_MOVE_CONSTRUCTOR( \
													((pELEMENT_TYPE *)tElement), \
													((pELEMENT_TYPE *)tElement_tmp)); \
											CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
											pFUNC_ELEMENT_MOVE_DESTRUCTOR( \
													((pELEMENT_TYPE *)tElement_tmp));, ) \
										) \
										( \
											memcpy(tElement_tmp, \
													pThis->gPrivate_elements + tIndex, \
													sizeof(pELEMENT_TYPE)); \
											CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
											pFUNC_ELEMENT_MOVE_DESTRUCTOR( \
													pThis->gPrivate_elements + tIndex);, ) \
	\
											memcpy(pThis->gPrivate_elements + tIndex, tElement, \
													sizeof(pELEMENT_TYPE)); \
											CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
											pFUNC_ELEMENT_MOVE_DESTRUCTOR( \
													((pELEMENT_TYPE *)tElement));, ) \
	\
											memcpy(tElement, tElement_tmp, sizeof(pELEMENT_TYPE)); \
											CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
											pFUNC_ELEMENT_MOVE_DESTRUCTOR( \
													((pELEMENT_TYPE *)tElement_tmp));, ) \
										) \
									) \
								)() \
	\
								CRX__C__HashTable__MARK_BUCKET_CONTENT_DELETED( \
										pThis->gPrivate_bucketData, tIndex); /* mark it as deleted in the old hash table */ \
							} \
							else \
							{ /* write the element and jump out of the loop */ \
								CRXM__IFELSE(CRXM__AND(CRXM__AND(pIS_KEY_COPYABLE, \
										CRXM__NOT(pFUNC_KEY_COPY_CONSTRUCTOR)), \
										CRXM__NOT(pFUNC_KEY_DESTRUCTOR))) \
								( \
									memcpy(pThis->gPrivate_keys + tIndex, tKey, \
											sizeof(pKEY_TYPE)); \
								) \
								( \
									CRXM__IFELSE(pFUNC_KEY_MOVE_CONSTRUCTOR) \
									( \
										pFUNC_KEY_MOVE_CONSTRUCTOR(pThis->gPrivate_keys + tIndex, \
												((pKEY_TYPE *)tKey)); \
									) \
									( \
										memcpy(pThis->gPrivate_keys + tIndex, tKey, \
												sizeof(pKEY_TYPE)); \
									) \
	\
									CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
									pFUNC_KEY_MOVE_DESTRUCTOR(((pKEY_TYPE *)tKey));, ) \
								) \
	\
								CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
								( \
									CRXM__IFELSE(CRXM__AND(CRXM__AND(pIS_ELEMENT_COPYABLE, \
											CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR)), \
											CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))) \
									( \
										memcpy(pThis->gPrivate_elements + tIndex, tElement, \
												sizeof(pELEMENT_TYPE)); \
									) \
									( \
										CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
										( \
											pFUNC_ELEMENT_MOVE_CONSTRUCTOR( \
													pThis->gPrivate_elements + tIndex, \
													((pELEMENT_TYPE *)tElement)); \
										) \
										( \
											memcpy(pThis->gPrivate_elements + tIndex, tElement, \
													sizeof(pELEMENT_TYPE)); \
										) \
	\
										CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
										pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)tElement)), ); \
									) \
								)() \
	\
								break; \
							} \
						} \
					} \
				} \
				CRX_ENDFOR \
	\
				if(pThis->gPrivate_numberOfBuckets > vNumberOfBuckets) \
				{ /* shrink the hash table */ \
					pKEY_TYPE * tKeys; \
	\
					CRXM__IFELSE(CRXM__OR(pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR)) \
					( \
						tKeys = (pKEY_TYPE*)(malloc(vNumberOfBuckets * sizeof(pKEY_TYPE))); \
	\
						if(tKeys != NULL) \
						{ \
							CRXM__IFELSE(pFUNC_KEY_MOVE_CONSTRUCTOR) \
							( \
								CRX_FOR(pSIZE_T tI = 0, tI < pThis->gPrivate_numberOfBuckets, tI++) \
								{ \
									if(CRX__C__HashTable__IS_BUCKET_EMPTY( \
											pThis->gPrivate_bucketData, tI) == 0) \
									{ \
										pFUNC_KEY_MOVE_CONSTRUCTOR(tKeys + tI, \
												pThis->gPrivate_keys + tI); \
	\
										CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
										pFUNC_KEY_MOVE_DESTRUCTOR(pThis->gPrivate_keys + tI);, ) \
									} \
								} \
								CRX_ENDFOR \
							) \
							( \
								memcpy(tKeys, pThis->gPrivate_keys, \
										pThis->gPrivate_numberOfBuckets * sizeof(pKEY_TYPE)); \
	\
								CRX_FOR(pSIZE_T tI = 0, tI < pThis->gPrivate_numberOfBuckets, tI++) \
								{ \
									if(CRX__C__HashTable__IS_BUCKET_EMPTY( \
											pThis->gPrivate_bucketData, tI) == 0) \
									{ \
										pFUNC_KEY_MOVE_DESTRUCTOR(pThis->gPrivate_keys + tI); \
									} \
								} \
							) \
	\
							free(pThis->gPrivate_keys); \
							pThis->gPrivate_keys = tKeys; \
						} \
					) \
					( \
						tKeys = (pKEY_TYPE*)realloc((void *)pThis->gPrivate_keys, vNumberOfBuckets * sizeof(pKEY_TYPE)); \
	\
						if(tKeys != NULL) \
							{pThis->gPrivate_keys = tKeys;} \
					) \
	\
					CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
					( \
						if(tKeys != NULL) \
						{ \
							pELEMENT_TYPE * tElements; \
	\
							CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, \
									pFUNC_ELEMENT_MOVE_DESTRUCTOR)) \
							( \
								tElements = (pELEMENT_TYPE*)(malloc( \
										vNumberOfBuckets * sizeof(pELEMENT_TYPE))); \
	\
								if(tElements != NULL) \
								{ \
									CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
									( \
										CRX_FOR(pSIZE_T tI = 0, \
												tI < pThis->gPrivate_numberOfBuckets, tI++) \
										{ \
											if(CRX__C__HashTable__IS_BUCKET_EMPTY( \
													pThis->gPrivate_bucketData, tI) == 0) \
											{ \
												pFUNC_ELEMENT_MOVE_CONSTRUCTOR(tElements + tI, \
														pThis->gPrivate_elements + tI); \
	\
												CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
												pFUNC_ELEMENT_MOVE_DESTRUCTOR( \
														pThis->gPrivate_elements + tI);, ) \
											} \
										} \
										CRX_ENDFOR \
									) \
									( \
										memcpy(tElements, pThis->gPrivate_elements, \
												pThis->gPrivate_numberOfBuckets * \
												sizeof(pELEMENT_TYPE)); \
	\
										CRX_FOR(pSIZE_T tI = 0, \
												tI < pThis->gPrivate_numberOfBuckets, tI++) \
										{ \
											if(CRX__C__HashTable__IS_BUCKET_EMPTY( \
													pThis->gPrivate_bucketData, tI) == 0) \
											{ \
												pFUNC_ELEMENT_MOVE_DESTRUCTOR( \
														pThis->gPrivate_elements + tI); \
											} \
										} \
										CRX_ENDFOR \
									) \
	\
									free(pThis->gPrivate_elements); \
									pThis->gPrivate_elements = tElements; \
								} \
							) \
							( \
								tElements = (pELEMENT_TYPE*)realloc((void *)pThis->gPrivate_elements, \
										vNumberOfBuckets * sizeof(pELEMENT_TYPE)); \
	\
								if(tElements != NULL) \
									{pThis->gPrivate_elements = tElements;} \
							) \
						} \
					)() \
				} \
	\
				free(pThis->gPrivate_bucketData); /* free the working space */ \
				pThis->gPrivate_bucketData = vBucketData; \
				pThis->gPrivate_numberOfBuckets = vNumberOfBuckets; \
				pThis->gPrivate_numberOfBucketsEverUsed = pThis->gPrivate_size; \
				pThis->gPrivate_upperBoundOfNumberOfBucketsEverUsed = \
						(pSIZE_T)(pThis->gPrivate_numberOfBuckets * 0.77 + 0.5); \
				pThis->gPrivate_seed = tSeed; \
			} \
	\
			return true; \
		} \
		else \
			{return false;} \
		CRX_SCOPE_END \
	} \
	\
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_setCapacity2(pHASH_TABLE_TYPE_NAME * pThis, \
			pSIZE_T pNumberOfBuckets) \
	{ /* This function uses 0.25*gPrivate_numberOfBuckets bytes of working space instead of [sizeof(key_t+val_t)+.25]*gPrivate_numberOfBuckets. */ \
		CRX_SCOPE_META \
		if(pNumberOfBuckets > ((pSIZE_T_MAX >> 1) + 1)) \
			{return false;} \
	\
		CRX_SCOPE \
		uint32_t * vBucketData = NULL; \
		pSIZE_T vNumberOfBuckets = CRX__C__HashTable__ROUND_UP_TO_POWER_OF_TWO( \
				pNumberOfBuckets); \
		bool vIsRehashingRequired = true; \
		CRXM__IFELSE2(CRXM__OR(CRXM__OR(pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR), \
				CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)), \
		pKEY_TYPE * vKeys = NULL;, ) \
		CRXM__IFELSE2(CRXM__OR(CRXM__OR(pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR), \
				CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)), \
		pELEMENT_TYPE * vElements = NULL;, ) \
	\
		{ \
			if(vNumberOfBuckets < 4) \
				{vNumberOfBuckets = 4;} \
	\
			if(pThis->gPrivate_size >= (pSIZE_T)(vNumberOfBuckets * 0.77 + 0.5)) \
				{vIsRehashingRequired = false;}	/* requested gPrivate_size is too small */ \
			else \
			{ /* hash table gPrivate_size to be changed (shrink or expand); rehash */ \
				vBucketData = (uint32_t *)(malloc( \
						CRX__C__HashTable__GET_SIZE_OF_BUCKET_DATA(vNumberOfBuckets) * \
						sizeof(uint32_t)));	\
	\
				if(vBucketData != NULL) \
				{ \
					memset(vBucketData, 0xaa, \
							CRX__C__HashTable__GET_SIZE_OF_BUCKET_DATA(vNumberOfBuckets) * \
							sizeof(uint32_t)); \
	\
					if(CRXM__IFELSE2(CRXM__NOT(CRXM__OR(CRXM__OR(pFUNC_KEY_MOVE_CONSTRUCTOR, \
								pFUNC_KEY_MOVE_DESTRUCTOR), CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR))), \
								pThis->gPrivate_numberOfBuckets < vNumberOfBuckets, \
								pThis->gPrivate_numberOfBuckets != vNumberOfBuckets)) \
					{	/* expand OR POSSIBLY SHRINK NOW*/ \
						CRXM__IFELSE2(CRXM__NOT(CRXM__OR(CRXM__OR(pFUNC_KEY_MOVE_CONSTRUCTOR, \
								pFUNC_KEY_MOVE_DESTRUCTOR), CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR))), \
						pKEY_TYPE * tKeys;, ) \
	\
						CRXM__IFELSE(CRXM__OR(CRXM__OR(pFUNC_KEY_MOVE_CONSTRUCTOR, \
								pFUNC_KEY_MOVE_DESTRUCTOR), CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR))) \
						( \
							vKeys = (pKEY_TYPE*)(malloc(vNumberOfBuckets * sizeof(pKEY_TYPE))); \
	\
							if(vKeys != NULL) \
							{ \
								CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
								( \
									vElements = (pELEMENT_TYPE*)(malloc( \
											vNumberOfBuckets * sizeof(pELEMENT_TYPE))); \
	\
									if(vElements == NULL) \
									{ \
										free(vKeys); \
										vKeys = NULL; \
										free(vBucketData); \
										vBucketData = NULL; \
									} \
								)() \
							} \
							else \
							{ \
								free(vBucketData); \
								vBucketData = NULL; \
							} \
						) \
						( \
							tKeys = (pKEY_TYPE*)realloc((void *)pThis->gPrivate_keys, vNumberOfBuckets * sizeof(pKEY_TYPE)); \
	\
							if(!tKeys) \
							{ \
								free(vBucketData); \
								vBucketData = NULL; \
							} \
							else \
							{ \
								pThis->gPrivate_keys = tKeys; \
	\
								CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
								( \
									pELEMENT_TYPE * tElements = (pELEMENT_TYPE*)realloc((void *)pThis->gPrivate_elements, \
											vNumberOfBuckets * sizeof(pELEMENT_TYPE)); \
	\
									if(!tElements) \
									{ \
										free(vBucketData); \
										vBucketData = NULL; \
									} \
									else \
										{pThis->gPrivate_elements = tElements;} \
								)() \
							} \
						) \
					} /* otherwise shrink */ \
				} \
			} \
		} \
		if(vBucketData != NULL) \
		{ \
			if(vIsRehashingRequired) \
			{ /* rehashing is needed */ \
				size_t tSeed = 0; \
				pSIZE_T tNewMask = vNumberOfBuckets - 1; \
	\
				CRXM__IFELSE(CRXM__OR(CRXM__OR(pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR), \
						CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR))) \
				( \
					CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
					( \
						tSeed = pMEMBER_FUNCTIONS_PREFIX ## prepareSeedForHash(vKeys, \
								vElements); \
					) \
					( \
						tSeed = pMEMBER_FUNCTIONS_PREFIX ## prepareSeedForHash(pThis, \
								vKeys); \
					) \
	\
					CRX_FOR(pSIZE_T tI = 0, tI != pThis->gPrivate_numberOfBuckets, ++tI) \
					{ \
						if(CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, tI) != 0) \
							{continue;} \
	\
						pSIZE_T tI2 = ((pSIZE_T)pFUNC_COMPUTE_HASH(tSeed, \
								pThis->gPrivate_keys + tI)) & tNewMask; \
						pSIZE_T tStep = 0; \
	\
						while(!CRX__C__HashTable__WAS_BUCKET_NEVER_FILLED(vBucketData, tI2)) \
							{tI2 = (tI2 + (++tStep)) & tNewMask;} \
	\
						CRX__C__HashTable__MARK_BUCKET_EVER_FILLED(vBucketData, tI2); \
	\
						CRXM__IFELSE(pFUNC_KEY_MOVE_CONSTRUCTOR) \
						( \
							pFUNC_KEY_MOVE_CONSTRUCTOR(vKeys + tI2, pThis->gPrivate_keys + tI); \
						) \
						( \
							memcpy(vKeys + tI2, \
									pThis->gPrivate_keys + tI, sizeof(pKEY_TYPE)); \
						) \
	\
						CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
						pFUNC_KEY_MOVE_DESTRUCTOR(pThis->gPrivate_keys + tI);, ) \
	\
						CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
						( \
							CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
							( \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR(vElements + tI2, \
										pThis->gPrivate_elements + tI); \
							) \
							( \
								memcpy(vElements + tI2, pThis->gPrivate_elements + tI, \
										sizeof(pELEMENT_TYPE)); \
							) \
	\
							CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
							pFUNC_ELEMENT_MOVE_DESTRUCTOR(pThis->gPrivate_elements + tI);, ) \
						)() \
	\
					} \
					CRX_ENDFOR \
	\
					pThis->gPrivate_numberOfBuckets = vNumberOfBuckets; \
					pThis->gPrivate_numberOfBucketsEverUsed = pThis->gPrivate_size; \
					pThis->gPrivate_upperBoundOfNumberOfBucketsEverUsed = \
							(pSIZE_T)(pThis->gPrivate_numberOfBuckets * 0.77 + 0.5); \
					pThis->gPrivate_seed = tSeed; \
	\
					free(pThis->gPrivate_bucketData); \
					pThis->gPrivate_bucketData = vBucketData; \
					vBucketData = NULL; \
	\
					free(pThis->gPrivate_keys); \
					pThis->gPrivate_keys = vKeys; \
					vKeys = NULL; \
	\
					CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
					( \
						free(pThis->gPrivate_elements); \
						pThis->gPrivate_elements = vElements; \
						vElements = NULL; \
					)() \
				) \
				( \
					unsigned char * tKey = (unsigned char *) CRX__ALLOCA(sizeof(pKEY_TYPE)); \
					unsigned char * tKey_temp = (unsigned char *) CRX__ALLOCA(sizeof(pKEY_TYPE)); \
					CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
					unsigned char * tElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
					CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
					unsigned char * tElement_tmp = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
	\
					if(pThis->gPrivate_numberOfBuckets <= vNumberOfBuckets) \
					{ \
						CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
						( \
							tSeed = pMEMBER_FUNCTIONS_PREFIX ## prepareSeedForHash(pThis->gPrivate_keys, \
									pThis->gPrivate_elements); \
						) \
						( \
							tSeed = pMEMBER_FUNCTIONS_PREFIX ## prepareSeedForHash(pThis, \
									pThis->gPrivate_keys); \
						) \
					} \
					else \
					{ \
						CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
						( \
							tSeed = pMEMBER_FUNCTIONS_PREFIX ## prepareSeedForHash(pThis->gPrivate_keys, \
									pThis->gPrivate_elements + 101); \
						) \
						( \
							tSeed = pMEMBER_FUNCTIONS_PREFIX ## prepareSeedForHash(pThis, \
									pThis->gPrivate_keys + 101); \
						) \
					} \
	\
					CRX_FOR(pSIZE_T tI = 0, tI != pThis->gPrivate_numberOfBuckets, ++tI) \
					{ \
						if(CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, tI) == 0) \
						{ \
							memcpy(tKey, pThis->gPrivate_keys + tI, sizeof(pKEY_TYPE)); \
	\
							CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
							( \
								memcpy(tElement, pThis->gPrivate_elements + tI, \
										sizeof(pELEMENT_TYPE)); \
							)() \
	\
							CRX__C__HashTable__MARK_BUCKET_CONTENT_DELETED( \
									pThis->gPrivate_bucketData, tI); \
	\
							while(true) \
							{ /* kick-out process; sort of like in Cuckoo hashing */ \
								pSIZE_T tIndex = ((pSIZE_T)pFUNC_COMPUTE_HASH(tSeed, \
										((pKEY_TYPE *)tKey))) & tNewMask; \
								pSIZE_T tStep = 0; \
	\
								while(!CRX__C__HashTable__WAS_BUCKET_NEVER_FILLED(vBucketData, tIndex)) \
									{tIndex = (tIndex + (++tStep)) & tNewMask;} \
	\
								CRX__C__HashTable__MARK_BUCKET_EVER_FILLED(vBucketData, tIndex);	\
	\
								if((tIndex < pThis->gPrivate_numberOfBuckets) && \
										(CRX__C__HashTable__IS_BUCKET_EMPTY( \
										pThis->gPrivate_bucketData, tIndex) == 0)) \
								{ /* kick out the existing element */ \
									{ \
										memcpy(tKey_temp, pThis->gPrivate_keys + tIndex, \
												sizeof(pKEY_TYPE)); \
										memcpy(pThis->gPrivate_keys + tIndex, tKey, \
												sizeof(pKEY_TYPE)); \
										memcpy(tKey, tKey_temp, sizeof(pKEY_TYPE)); \
									} \
	\
									CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
									( \
										memcpy(tElement_tmp, pThis->gPrivate_elements + tIndex, \
												sizeof(pELEMENT_TYPE)); \
										memcpy(pThis->gPrivate_elements + tIndex, tElement, \
												sizeof(pELEMENT_TYPE)); \
										memcpy(tElement, tElement_tmp, sizeof(pELEMENT_TYPE)); \
									)() \
	\
									CRX__C__HashTable__MARK_BUCKET_CONTENT_DELETED(pThis->gPrivate_bucketData, tIndex); /* mark it as deleted in the old hash table */ \
								} \
								else \
								{ /* write the element and jump out of the loop */ \
									memcpy(pThis->gPrivate_keys + tIndex, tKey, \
											sizeof(pKEY_TYPE)); \
	\
									CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
									( \
										memcpy(pThis->gPrivate_elements + tIndex, tElement, \
												sizeof(pELEMENT_TYPE)); \
									)() \
	\
									break; \
								} \
							} \
						} \
					} \
					CRX_ENDFOR \
				) \
	\
				CRXM__IFELSE(CRXM__NOT(CRXM__OR(CRXM__OR(pFUNC_KEY_MOVE_CONSTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR), \
						CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)))) \
				( \
					if(pThis->gPrivate_numberOfBuckets > vNumberOfBuckets) \
					{ /* shrink the hash table */ \
						pKEY_TYPE * tKeys = (pKEY_TYPE*)realloc((void *)pThis->gPrivate_keys, \
								vNumberOfBuckets * sizeof(pKEY_TYPE)); \
	\
						if(tKeys != NULL) \
							{pThis->gPrivate_keys = tKeys; } \
	\
						CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
						( \
							if(tKeys != NULL) \
							{ \
								pELEMENT_TYPE * tElements = (pELEMENT_TYPE*)realloc((void *)pThis->gPrivate_elements, \
										vNumberOfBuckets * sizeof(pELEMENT_TYPE)); \
	\
								if(tElements != NULL) \
									{pThis->gPrivate_elements = tElements;} \
							} \
						)() \
					} \
	\
					free(pThis->gPrivate_bucketData); /* free the working space */ \
					pThis->gPrivate_bucketData = vBucketData; \
					pThis->gPrivate_numberOfBuckets = vNumberOfBuckets; \
					pThis->gPrivate_numberOfBucketsEverUsed = pThis->gPrivate_size; \
					pThis->gPrivate_upperBoundOfNumberOfBucketsEverUsed = \
							(pSIZE_T)(pThis->gPrivate_numberOfBuckets * 0.77 + 0.5); \
					pThis->gPrivate_seed = tSeed; \
				)() \
			} \
	\
			return true; \
		} \
		else \
			{return false;} \
		CRX_SCOPE_END \
	} \
	\
	PRIVATE pSIZE_T pMEMBER_FUNCTIONS_PREFIX ## private_tryMoveKeyAndPrepareBucketFor( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE * pKey, int * pReturn) \
	{ \
		pSIZE_T vReturn = 0; \
	\
		if(pThis->gPrivate_numberOfBucketsEverUsed >= pThis->gPrivate_upperBoundOfNumberOfBucketsEverUsed) \
		{ /* update the hash table */ \
			if(pThis->gPrivate_numberOfBuckets > (pThis->gPrivate_size << 1)) \
			{ \
				if(!pMEMBER_FUNCTIONS_PREFIX ## private_setCapacity(pThis, \
						pThis->gPrivate_numberOfBuckets - 1)) \
				{/* clear "deleted" elements */ \
					*pReturn = -1; \
	\
					vReturn = pThis->gPrivate_numberOfBuckets; \
				} \
			} \
			else if(!pMEMBER_FUNCTIONS_PREFIX ## private_setCapacity(pThis, \
					pThis->gPrivate_numberOfBuckets + 1)) \
			{ /* expand the hash table */ \
				*pReturn = -1; \
	\
				vReturn = pThis->gPrivate_numberOfBuckets; \
			} \
		} /* TODO: to implement automatically shrinking; private_setCapacity() already support shrinking */ \
	\
		if((vReturn != pThis->gPrivate_numberOfBuckets) || \
				(pThis->gPrivate_numberOfBucketsEverUsed < pThis->gPrivate_numberOfBuckets))\
		{ \
			{ \
				pSIZE_T tMask = pThis->gPrivate_numberOfBuckets - 1; \
				pSIZE_T tIndex = ((pSIZE_T)pFUNC_COMPUTE_HASH(pThis->gPrivate_seed, pKey)) & tMask; \
	\
				if(CRX__C__HashTable__WAS_BUCKET_NEVER_FILLED(pThis->gPrivate_bucketData, tIndex)) \
					{vReturn = tIndex;} /* for speed up */ \
				else \
				{ \
					pSIZE_T site = pThis->gPrivate_numberOfBuckets; \
					pSIZE_T tLastIndex = tIndex; \
					pSIZE_T tStep = 0; \
	\
					vReturn = pThis->gPrivate_numberOfBuckets; \
	\
					while(!CRX__C__HashTable__WAS_BUCKET_NEVER_FILLED(pThis->gPrivate_bucketData, tIndex) && \
							(CRX__C__HashTable__IS_BUCKET_CONTENT_DELETED(pThis->gPrivate_bucketData, tIndex) || \
							!pFUNC_ARE_KEYS_EQUAL(pThis->gPrivate_keys + tIndex, pKey))) \
					{ \
						if(CRX__C__HashTable__IS_BUCKET_CONTENT_DELETED(pThis->gPrivate_bucketData, tIndex)) \
							{site = tIndex;} \
	\
						tIndex = (tIndex + (++tStep)) & tMask; \
	\
						if(tIndex == tLastIndex) \
						{ \
							vReturn = site; \
							break; \
						} \
					} \
					if(vReturn == pThis->gPrivate_numberOfBuckets) \
					{ \
						if(CRX__C__HashTable__WAS_BUCKET_NEVER_FILLED(pThis->gPrivate_bucketData, tIndex) && \
								site != pThis->gPrivate_numberOfBuckets) \
							{vReturn = site;} \
						else \
							{vReturn = tIndex;} \
					} \
				} \
			} \
	\
			if(CRX__C__HashTable__WAS_BUCKET_NEVER_FILLED(pThis->gPrivate_bucketData, vReturn)) \
			{ /* not present at all */ \
				CRXM__IFELSE(pFUNC_KEY_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_KEY_MOVE_CONSTRUCTOR(pThis->gPrivate_keys + vReturn, pKey); \
				) \
				( \
					memcpy(pThis->gPrivate_keys + vReturn, pKey, sizeof(pKEY_TYPE)); \
				) \
	\
				CRX__C__HashTable__MARK_BUCKET_NOT_EMPTY(pThis->gPrivate_bucketData, vReturn); \
	\
				++(pThis->gPrivate_size); \
				++(pThis->gPrivate_numberOfBucketsEverUsed); \
	\
				*pReturn = 1; \
			} \
			else if(CRX__C__HashTable__IS_BUCKET_CONTENT_DELETED(pThis->gPrivate_bucketData, vReturn)) \
			{ /* deleted */ \
				CRXM__IFELSE(pFUNC_KEY_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_KEY_MOVE_CONSTRUCTOR(pThis->gPrivate_keys + vReturn, pKey); \
				) \
				( \
					memcpy(pThis->gPrivate_keys + vReturn, pKey, sizeof(pKEY_TYPE)); \
				) \
	\
				CRX__C__HashTable__MARK_BUCKET_NOT_EMPTY(pThis->gPrivate_bucketData, vReturn); \
				++(pThis->gPrivate_size); \
	\
				*pReturn = 2; \
			} \
			else \
				{*pReturn = 0;} /* Don't touch pThis->gPrivate_keys[vReturn] if present and not deleted */ \
		} \
	\
		return vReturn; \
	} \
	\
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_deleteElementAt(pHASH_TABLE_TYPE_NAME * pThis, \
			pSIZE_T pBucketIndex) \
	{																	\
		if((pBucketIndex != pThis->gPrivate_numberOfBuckets) && \
				!CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, pBucketIndex)) \
		{ \
			CRX__C__HashTable__MARK_BUCKET_CONTENT_DELETED(pThis->gPrivate_bucketData, pBucketIndex); \
	\
			CRXM__IFELSE2(pFUNC_KEY_DESTRUCTOR, \
			pFUNC_KEY_DESTRUCTOR(pThis->gPrivate_keys + pBucketIndex);, ); \
			CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), pFUNC_ELEMENT_DESTRUCTOR), \
			pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_elements + pBucketIndex);, ); \
	\
			--(pThis->gPrivate_size); \
		} \
	} \
	\
	PUBLIC pSIZE_T pMEMBER_FUNCTIONS_PREFIX ## getSize(pHASH_TABLE_TYPE_NAME const * pThis) \
		{return pThis->gPrivate_size;} \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndElementAndSet( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE * pKey, pELEMENT_TYPE * pElement) \
	{ \
		int vReturnedCode = 0; \
		pSIZE_T vBucketNumber = \
				pMEMBER_FUNCTIONS_PREFIX ## private_tryMoveKeyAndPrepareBucketFor(pThis, \
				pKey, &vReturnedCode); \
	\
		if(vBucketNumber != pThis->gPrivate_numberOfBuckets) \
		{ \
			if(vReturnedCode > 0) \
				{} \
			else \
			{ \
				CRXM__IFELSE2(pFUNC_KEY_DESTRUCTOR, \
				pFUNC_KEY_DESTRUCTOR(pThis->gPrivate_keys + vBucketNumber);, ) \
	\
				CRXM__IFELSE(pFUNC_KEY_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_KEY_MOVE_CONSTRUCTOR(pThis->gPrivate_keys + vBucketNumber, pKey); \
				) \
				( \
					memcpy(pThis->gPrivate_keys + vBucketNumber, pKey, sizeof(pKEY_TYPE)); \
				) \
	\
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
				pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_elements + vBucketNumber);, ) \
			} \
	\
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_elements + vBucketNumber, pElement); \
			) \
			( \
				memcpy(pThis->gPrivate_elements + vBucketNumber, pElement, sizeof(pELEMENT_TYPE)); \
			) \
	\
			return true; \
		} \
		else \
			{return false;} \
	}, ) \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndSet( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE * pKey, pELEMENT_TYPE const * pElement), \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndSet( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE * pKey)) \
	{ \
		CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), \
				CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
		unsigned char * vElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
		CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), \
				CRXM__AND(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
				CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR))), \
		bool vReturn;, )\
		CRXM__IFELSE2(pIS_KEYS_ONLY, \
		int vReturnedCode = 0;, ) \
		CRXM__IFELSE2(pIS_KEYS_ONLY, \
		pSIZE_T vBucketNumber = \
				pMEMBER_FUNCTIONS_PREFIX ## private_tryMoveKeyAndPrepareBucketFor(pThis, \
				pKey, &vReturnedCode);, ) \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
			( \
				pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
	\
				CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						vReturn = , return) pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndElementAndSet(pThis, pKey, \
						((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
	\
					CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						vReturn = , return) pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndElementAndSet(pThis, pKey, \
						((pELEMENT_TYPE *)vElement)); \
				) \
				( \
					return pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndElementAndSet(pThis, pKey, \
							((pELEMENT_TYPE *)pElement)); \
				) \
			) \
	\
			CRXM__IFELSE(CRXM__AND(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
					CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR))) \
			( \
				if(vReturn) \
				{ \
					CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
					pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
				} \
				else \
				{ \
					CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
					pFUNC_ELEMENT_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
				} \
	\
				return vReturn; \
			)() \
		) \
		( \
			if(vBucketNumber != pThis->gPrivate_numberOfBuckets) \
			{ \
				if(vReturnedCode > 0) \
					{} \
				else \
				{ \
					CRXM__IFELSE2(pFUNC_KEY_DESTRUCTOR, \
					pFUNC_KEY_DESTRUCTOR(pThis->gPrivate_keys + vBucketNumber);, ) \
	\
					CRXM__IFELSE(pFUNC_KEY_MOVE_CONSTRUCTOR) \
					( \
						pFUNC_KEY_MOVE_CONSTRUCTOR(pThis->gPrivate_keys + vBucketNumber, pKey); \
					) \
					( \
						memcpy(pThis->gPrivate_keys + vBucketNumber, pKey, sizeof(pKEY_TYPE)); \
					) \
				} \
	\
				return true; \
			} \
			else \
				{return false;} \
		) \
	} \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## tryMoveElementAndSet( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE const * pKey, pELEMENT_TYPE * pElement) \
	{ \
		CRXM__IFELSE2(CRXM__OR(pFUNC_KEY_COPY_CONSTRUCTOR, pFUNC_KEY_MOVE_CONSTRUCTOR), \
		unsigned char * vKey = (unsigned char *) CRX__ALLOCA(sizeof(pKEY_TYPE));, ) \
		CRXM__IFELSE2(CRXM__AND(CRXM__OR(pFUNC_KEY_DESTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR), \
				CRXM__OR(pFUNC_KEY_COPY_CONSTRUCTOR, pFUNC_KEY_MOVE_CONSTRUCTOR)), \
		bool vReturn;, )\
	\
		CRXM__IFELSE(pFUNC_KEY_COPY_CONSTRUCTOR) \
		( \
			pFUNC_KEY_COPY_CONSTRUCTOR(((pKEY_TYPE *)vKey), pKey); \
	\
			CRXM__IFELSE2(CRXM__OR(pFUNC_KEY_DESTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR), \
					vReturn = , return) pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndElementAndSet(\
					pThis, ((pKEY_TYPE *)vKey), pElement); \
		) \
		( \
			CRXM__IFELSE(pFUNC_KEY_MOVE_CONSTRUCTOR) \
			( \
				memcpy(vKey, pKey, sizeof(pKEY_TYPE)); \
	\
				CRXM__IFELSE2(CRXM__OR(pFUNC_KEY_DESTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR), \
						vReturn = , return) pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndElementAndSet( \
						pThis, ((pKEY_TYPE *)vKey), pElement); \
			) \
			( \
				return pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndElementAndSet( \
						pThis, ((pKEY_TYPE *)pKey), pElement); \
			) \
		) \
	\
		CRXM__IFELSE(CRXM__AND(CRXM__OR(pFUNC_KEY_DESTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR), \
				CRXM__OR(pFUNC_KEY_COPY_CONSTRUCTOR, pFUNC_KEY_MOVE_CONSTRUCTOR))) \
		( \
			if(vReturn) \
			{ \
				CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
				pFUNC_KEY_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vKey));, ) \
			} \
			else \
			{ \
				CRXM__IFELSE2(pFUNC_KEY_DESTRUCTOR, \
				pFUNC_KEY_DESTRUCTOR(((pELEMENT_TYPE *)vKey));, ) \
			} \
	\
			return vReturn; \
		)() \
	}, ) \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## set( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE const * pKey, pELEMENT_TYPE const * pElement), \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## set( \
			pHASH_TABLE_TYPE_NAME * pThis, pKEY_TYPE const * pKey)) \
	{ \
		unsigned char * vKey = (unsigned char *) CRX__ALLOCA(sizeof(pKEY_TYPE)); \
		CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
		unsigned char * vElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
		CRXM__IFELSE2(CRXM__OR(CRXM__OR(pFUNC_KEY_DESTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR), \
				CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), \
						CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR))), \
		bool vReturn;, )\
	\
		CRXM__IFELSE(pFUNC_KEY_COPY_CONSTRUCTOR) \
		( \
			pFUNC_KEY_COPY_CONSTRUCTOR(((pKEY_TYPE *)vKey), pKey); \
		) \
		( \
			memcpy(vKey, pKey, sizeof(pKEY_TYPE)); \
		) \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
			( \
				pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
			) \
			( \
				memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
			) \
		)() \
	\
		CRXM__IFELSE(CRXM__OR(CRXM__OR(pFUNC_KEY_DESTRUCTOR, pFUNC_KEY_MOVE_DESTRUCTOR), \
				CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), \
						CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)))) \
		( \
			CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
			( \
				vReturn = pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndElementAndSet(pThis, \
						((pKEY_TYPE *)vKey), ((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				vReturn = pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndSet(pThis, \
						((pKEY_TYPE *)vKey)); \
			) \
	\
			if(vReturn) \
			{ \
				CRXM__IFELSE2(pFUNC_KEY_MOVE_DESTRUCTOR, \
				pFUNC_KEY_MOVE_DESTRUCTOR(((pKEY_TYPE *)vKey));, ); \
				CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), \
						pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ); \
			} \
			else \
			{ \
				CRXM__IFELSE2(pFUNC_KEY_DESTRUCTOR, \
				pFUNC_KEY_DESTRUCTOR(((pKEY_TYPE *)vKey));, ); \
				CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), \
						pFUNC_ELEMENT_DESTRUCTOR), \
				pFUNC_ELEMENT_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ); \
			} \
	\
			return vReturn; \
		) \
		( \
			CRXM__IFELSE(CRXM__NOT(pIS_KEYS_ONLY)) \
			( \
				return pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndElementAndSet(pThis, \
						((pKEY_TYPE *)vKey), ((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				return pMEMBER_FUNCTIONS_PREFIX ## tryMoveKeyAndSet(pThis, \
						((pKEY_TYPE *)vKey)); \
			) \
		) \
	} \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
	PUBLIC pELEMENT_TYPE * pMEMBER_FUNCTIONS_PREFIX ## get(pHASH_TABLE_TYPE_NAME * pThis, \
			pKEY_TYPE const * pKey) \
	{ \
		pSIZE_T vBucketIndex = pMEMBER_FUNCTIONS_PREFIX ## private_get(pThis, pKey); \
	\
		assert(vBucketIndex != pThis->gPrivate_numberOfBuckets); \
	\
		return (pThis->gPrivate_elements + vBucketIndex); \
	}, ) \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_KEYS_ONLY), \
	PUBLIC pELEMENT_TYPE const * pMEMBER_FUNCTIONS_PREFIX ## constantGet( \
			pHASH_TABLE_TYPE_NAME const * pThis, pKEY_TYPE const * pKey) \
		{return pMEMBER_FUNCTIONS_PREFIX ## get(((pHASH_TABLE_TYPE_NAME *)pThis), pKey);}, ) \
	\
	CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_KEYS_ONLY), pIS_ELEMENT_COPYABLE), \
	CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_DESTRUCTOR), \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## copyGetTo(pHASH_TABLE_TYPE_NAME const * pThis, \
			pELEMENT_TYPE * pReturn, pKEY_TYPE const * pKey), \
	PUBLIC pELEMENT_TYPE pMEMBER_FUNCTIONS_PREFIX ## copyGet(pHASH_TABLE_TYPE_NAME const * pThis, \
			pKEY_TYPE const * pKey)) \
	{ \
		pSIZE_T vBucketIndex = pMEMBER_FUNCTIONS_PREFIX ## private_get(pThis, pKey); \
	\
		assert(vBucketIndex != pThis->gPrivate_numberOfBuckets); \
	\
		CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_DESTRUCTOR)) \
		( \
			CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
			pFUNC_ELEMENT_DESTRUCTOR(pReturn);, ) \
	\
			CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
			( \
				pFUNC_ELEMENT_COPY_CONSTRUCTOR(pReturn, pThis->gPrivate_elements + vBucketIndex); \
			) \
			( \
				memcpy(pReturn, pThis->gPrivate_elements + vBucketIndex, \
						sizeof(pHASH_TABLE_TYPE_NAME)); \
			) \
		) \
		( \
			return *(pThis->gPrivate_elements + vBucketIndex); \
		) \
	}, ) \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## hasKey(pHASH_TABLE_TYPE_NAME const * pThis, \
			pKEY_TYPE const * pKey) \
	{ \
		return (pMEMBER_FUNCTIONS_PREFIX ## private_get(pThis, pKey) != \
				pThis->gPrivate_numberOfBuckets); \
	} \
	\
	PUBLIC pKEY_TYPE const * pMEMBER_FUNCTIONS_PREFIX ## getKeyFromIndex( \
			pHASH_TABLE_TYPE_NAME const * pThis, size_t pIndex) \
	{ \
		assert(pIndex <= pSIZE_T_MAX); \
	\
		if(CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, ((pSIZE_T)pIndex))) \
			{return NULL;} \
	\
		return (pThis->gPrivate_keys + pIndex); \
	} \
	PUBLIC pELEMENT_TYPE const * pMEMBER_FUNCTIONS_PREFIX ## getElementFromIndex( \
			pHASH_TABLE_TYPE_NAME const * pThis, size_t pIndex) \
	{ \
		assert(pIndex <= pSIZE_T_MAX); \
	\
		if(CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, ((pSIZE_T)pIndex))) \
			{return NULL;} \
	\
		return (pThis->gPrivate_elements + pIndex); \
	} \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## remove(pHASH_TABLE_TYPE_NAME * pThis, \
			pKEY_TYPE const * pKey) \
	{ \
		pMEMBER_FUNCTIONS_PREFIX ## private_deleteElementAt(pThis, \
				pMEMBER_FUNCTIONS_PREFIX ## private_get(pThis, pKey)); \
	} \
	\
	CRX__LIB__PUBLIC_INLINE_C_FUNCTION() pSIZE_T pMEMBER_FUNCTIONS_PREFIX ## getStartIndex( \
			pHASH_TABLE_TYPE_NAME const * pThis) \
	{ \
		pSIZE_T vIndex = 0; \
	\
		while((vIndex < pThis->gPrivate_numberOfBuckets) && \
				CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, vIndex)) \
			{vIndex = vIndex + 1;} \
	\
		return vIndex; \
	} \
	CRX__LIB__PUBLIC_INLINE_C_FUNCTION() pSIZE_T pMEMBER_FUNCTIONS_PREFIX ## getEndIndex( \
			pHASH_TABLE_TYPE_NAME const * pThis) \
		{return pThis->gPrivate_numberOfBuckets;} \
	CRX__LIB__PUBLIC_INLINE_C_FUNCTION() pSIZE_T pMEMBER_FUNCTIONS_PREFIX ## getNextIndex( \
			pHASH_TABLE_TYPE_NAME const * pThis, size_t pIndex) \
	{ \
		CRX_SCOPE_META \
		if(pIndex >= pThis->gPrivate_numberOfBuckets) \
			{return pThis->gPrivate_numberOfBuckets;} \
	\
		CRX_SCOPE \
		pSIZE_T vIndex = pIndex + 1; \
	\
		while((vIndex < pThis->gPrivate_numberOfBuckets) && \
				CRX__C__HashTable__IS_BUCKET_EMPTY(pThis->gPrivate_bucketData, vIndex)) \
			{vIndex = vIndex + 1;} \
	\
		return vIndex; \
		CRX_SCOPE_END \
	} \
	PRIVATE size_t pMEMBER_FUNCTIONS_PREFIX ## prepareSeedForHash( \
			void const * pPointer, void const * pPointer2) \
	{ \
		Crx_C_Random_Isaac vIsaac; \
		uint32_t vPointerValue = ((uint32_t)(((uintmax_t)pPointer) | \
				(((uintmax_t)pPointer) >> 3) & 0x03)); \
		uint32_t vPointer2Value = ((uint32_t)(((uintmax_t)pPointer2) |  \
				(((uintmax_t)pPointer2) >> 3) & 0x03)); \
	\
		crx_c_random_isaac_construct2(&vIsaac, vPointerValue, vPointer2Value, 0, 0, 0, 0, 0, 0); \
	\
		CRXM__IFELSE(CRX__C__HASH_TABLE__IS_TO_GENERATE_UINT64_RANDOM) \
		( \
			return ((((size_t)crx_c_random_isaac_getRandomUnsignedInt32(&vIsaac)) << 32) && \
					crx_c_random_isaac_getRandomUnsignedInt32(&vIsaac)); \
		) \
		( \
				return crx_c_random_isaac_getRandomUnsignedInt32(&vIsaac); \
		) \
	}
//#END_DEFINE

#define CRX__C__HashTable__GET_SIZE_OF_BUCKET_DATA(pNumberOfBuckets) \
		((pNumberOfBuckets) < 16 ? 1 : (pNumberOfBuckets)>>4)

#if(!defined(CRX__BOOST_NO_INT64_T))
	#define CRX__C__HashTable__ROUND_UP_TO_POWER_OF_TWO(pUINT64) \
			__CRX__C__HashTable__ROUND_UP_TO_POWER_OF_TWO(pUINT64)
	#define __CRX__C__HashTable__ROUND_UP_TO_POWER_OF_TWO(pUINT64) \
			(--(pUINT64), (pUINT64)|=(pUINT64)>>1, (pUINT64)|=(pUINT64)>>2, \
			(pUINT64)|=(pUINT64)>>4, (pUINT64)|=(pUINT64)>>8, \
			(pUINT64)|=(pUINT64)>>16, (pUINT64)|=((uint64_t)pUINT64)>>32, ++(pUINT64))
#else
	#define CRX__C__HashTable__ROUND_UP_TO_POWER_OF_TWO(pUINT32) \
			__CRX__C__HashTable__ROUND_UP_TO_POWER_OF_TWO(pUINT32)
	#define __CRX__C__HashTable__ROUND_UP_TO_POWER_OF_TWO(pUINT32) \
			(--(pUINT32), (pUINT32)|=(pUINT32)>>1, (pUINT32)|=(pUINT32)>>2, \
			(pUINT32)|=(pUINT32)>>4, (pUINT32)|=(pUINT32)>>8, \
			(pUINT32)|=(pUINT32)>>16, ++(pUINT32))
#endif

/*THE FOLLOWING IS USING TWO BITS FOR EACH BUCKET TO REPRESENT EMPTY AND DELETED.*/
#define CRX__C__HashTable__WAS_BUCKET_NEVER_FILLED(pBUCKET_DATA, pINDEX) ((pBUCKET_DATA[pINDEX>>4]>>((pINDEX&0xfU)<<1))&2)
#define CRX__C__HashTable__IS_BUCKET_CONTENT_DELETED(pBUCKET_DATA, pINDEX) ((pBUCKET_DATA[pINDEX>>4]>>((pINDEX&0xfU)<<1))&1)
#define CRX__C__HashTable__IS_BUCKET_EMPTY(pBUCKET_DATA, pINDEX) ((pBUCKET_DATA[pINDEX>>4]>>((pINDEX&0xfU)<<1))&3)
#define CRX__C__HashTable__MARK_BUCKET_EVER_FILLED(pBUCKET_DATA, pINDEX) (pBUCKET_DATA[pINDEX>>4]&=~(2ul<<((pINDEX&0xfU)<<1)))
#define CRX__C__HashTable__MARK_BUCKET_NOT_EMPTY(pBUCKET_DATA, pINDEX) (pBUCKET_DATA[pINDEX>>4]&=~(3ul<<((pINDEX&0xfU)<<1)))
#define CRX__C__HashTable__MARK_BUCKET_CONTENT_DELETED(pBUCKET_DATA, pINDEX) (pBUCKET_DATA[pINDEX>>4]|=1ul<<((pINDEX&0xfU)<<1))


CRX__LIB__PUBLIC_C_FUNCTION() uint32_t crx_c_hashTable_compute32BitsHash(
		size_t pSeed, void const * CRX_NOT_NULL pBytes, size_t pSize);
CRX__LIB__PUBLIC_C_FUNCTION() uint32_t crx_c_hashTable_computeSafer32BitsHash(
		size_t pSeed, void const * CRX_NOT_NULL pBytes, size_t pSize);

CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_hashTable_areUint8sEqual(void const * pUint8,
		void const * pUint8__2);
CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_hashTable_getHashKeyForUint8(void const * pUint8);

CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_hashTable_areUint16sEqual(void const * pUint16,
		void const * pUint16__2);
CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_hashTable_getHashKeyForUint16(void const * pUint16);
		
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_hashTable_areUint32sEqual(void const * pUint32,
		void const * pUint32__2);
CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_hashTable_getHashKeyForUint32(void const * pUint32);

#if(!defined(CRX__BOOST_NO_INT64_T))
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_hashTable_areUint64sEqual(void const * pUint64,
		void const * pUint64__2);
CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_hashTable_getHashKeyForUint64(void const * pUint64);
#endif


//TEMPORARY SOLUTION UNTIL I FIX THIS EVERYWHERE IN THE CODE. REMEMBER THAT IN THE PAST
//		GetHashForKey WAS FULLY DEFINED HERE, BUT I THEN INTRODUCED GetHash AN INNER CLASS TO 
//		TypeBluePrint BECAUSE OF ITS IMPORTANCE.
typedef Crx_C_TypeBluePrint_GetHash Crx_C_HashTable_GetHashForKey;

typedef struct Crx_C_HashTable
{
	Crx_C_TypeBluePrint const * CRX_NOT_MINE gPrivate_typeBluePrint__key;
	Crx_C_TypeBluePrint const * CRX_NOT_MINE gPrivate_typeBluePrint__element;
	size_t gPrivate_numberOfBuckets;
	size_t gPrivate_size;
	size_t gPrivate_numberOfBucketsEverUsed;
	size_t gPrivate_upperBoundOfNumberOfBucketsEverUsed;
	size_t gPrivate_seed;
	uint32_t * gPrivate_bucketData;
	unsigned char * gPrivate_keys;
	unsigned char * gPrivate_elements;
	Crx_C_TypeBluePrint_AreObjectsEqual gPrivate_areKeysEqual;
	Crx_C_HashTable_GetHashForKey gPrivate_getHashForKey;
} Crx_C_HashTable;

CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_hashTable_construct(Crx_C_HashTable * pThis,
		Crx_C_TypeBluePrint const *  CRX_NOT_NULL pTypeBluePrint__key, 
		Crx_C_TypeBluePrint const *  CRX_NOT_NULL pTypeBluePrint__element,
		Crx_C_TypeBluePrint_AreObjectsEqual CRX_NOT_NULL pAreKeysEqual,
		Crx_C_HashTable_GetHashForKey CRX_NOT_NULL pGetHashForKey);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_hashTable_construct2(Crx_C_HashTable * pThis,
		Crx_C_TypeBluePrint const *  CRX_NOT_NULL pTypeBluePrint__key, 
		Crx_C_TypeBluePrint_AreObjectsEqual CRX_NOT_NULL pAreKeysEqual,
		Crx_C_HashTable_GetHashForKey CRX_NOT_NULL pGetHashForKey);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_hashTable_copyConstruct(Crx_C_HashTable * pThis,
		Crx_C_HashTable const * CRX_NOT_NULL pHashTable);

CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_HashTable * crx_c_hashTable_new(
		Crx_C_TypeBluePrint const *  CRX_NOT_NULL pTypeBluePrint__key, 
		Crx_C_TypeBluePrint const *  pTypeBluePrint__element,
		Crx_C_TypeBluePrint_AreObjectsEqual CRX_NOT_NULL pAreKeysEqual,
		Crx_C_HashTable_GetHashForKey CRX_NOT_NULL pGetHashForKey);
CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_HashTable * crx_c_hashTable_new2(
		Crx_C_TypeBluePrint const *  CRX_NOT_NULL pTypeBluePrint__key, 
		Crx_C_TypeBluePrint_AreObjectsEqual CRX_NOT_NULL pAreKeysEqual,
		Crx_C_HashTable_GetHashForKey CRX_NOT_NULL pGetHashForKey);
CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_HashTable * crx_c_hashTable_moveNew(
		Crx_C_HashTable * pHashTable);
CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_HashTable * crx_c_hashTable_copyNew(
		Crx_C_HashTable const * pHashTable);

CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_hashTable_destruct(Crx_C_HashTable * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_hashTable_free(Crx_C_HashTable * pThis);

CRX__C__TYPE_BLUE_PRINT__GENERIC__DECLARE_GET_BLUE_PRINT(
		Crx_C_HashTable, crx_c_hashTable_,
		CRXM__TRUE, CRXM__TRUE,
		CRXM__TRUE, CRXM__TRUE,
		CRXM__FALSE, CRXM__FALSE);

CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_hashTable_private_doInit(Crx_C_HashTable * pThis,
		Crx_C_TypeBluePrint const *  CRX_NOT_NULL pTypeBluePrint__key, 
		Crx_C_TypeBluePrint_AreObjectsEqual CRX_NOT_NULL pAreKeysEqual,
		Crx_C_HashTable_GetHashForKey CRX_NOT_NULL pGetHashForKey,
		Crx_C_TypeBluePrint const *  pTypeBluePrint__element);

CRX__LIB__PRIVATE_C_FUNCTION() size_t crx_c_hashTable_private_get(Crx_C_HashTable const * pThis,
		void const * pKey);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_hashTable_empty(Crx_C_HashTable * pThis);
CRX__LIB__PRIVATE_C_FUNCTION() bool crx_c_hashTable_private_setCapacity(Crx_C_HashTable * pThis,
		size_t pNumberOfBuckets);
CRX__LIB__PRIVATE_C_FUNCTION() bool crx_c_hashTable_private_setCapacity2(Crx_C_HashTable * pThis,
		size_t pNumberOfBuckets);
CRX__LIB__PRIVATE_C_FUNCTION() size_t crx_c_hashTable_private_tryMoveKeyAndPrepareBucketFor(
		Crx_C_HashTable * pThis, void * pKey, int * pReturn);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_hashTable_private_deleteElementAt(Crx_C_HashTable * pThis,
		size_t pBucketIndex);

CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_hashTable_getSize(Crx_C_HashTable const * pThis);

CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_hashTable_tryMoveKeyAndElementAndSet(
		Crx_C_HashTable * pThis, void * CRX_NOT_NULL pKey, void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_hashTable_tryMoveKeyAndSet(
		Crx_C_HashTable * pThis, void * CRX_NOT_NULL pKey, void const * pElement);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_hashTable_tryMoveElementAndSet(
		Crx_C_HashTable * pThis, void const * CRX_NOT_NULL pKey, void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_hashTable_set(
		Crx_C_HashTable * pThis, void const * CRX_NOT_NULL pKey, void const * pElement);

CRX__LIB__PUBLIC_C_FUNCTION() void * crx_c_hashTable_get(Crx_C_HashTable * pThis,
		void const * CRX_NOT_NULL pKey);
CRX__LIB__PUBLIC_C_FUNCTION() void const * crx_c_hashTable_constantGet(
		Crx_C_HashTable const * pThis, void const * CRX_NOT_NULL pKey);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_hashTable_copyGetTo(Crx_C_HashTable const * pThis,
		void * CRX_NOT_NULL pReturn, void const * CRX_NOT_NULL pKey);

CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_hashTable_hasKey(
		Crx_C_HashTable const * pThis, void const * pKey);

CRX__LIB__PUBLIC_C_FUNCTION() void const * crx_c_hashTable_getKeyFromIndex(
		Crx_C_HashTable const * pThis, size_t pIndex);
CRX__LIB__PUBLIC_C_FUNCTION() void const * crx_c_hashTable_getElementFromIndex(
		Crx_C_HashTable const * pThis, size_t pIndex);

CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_hashTable_remove(Crx_C_HashTable * pThis,
		void const * CRX_NOT_NULL pKey);

CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_hashTable_getStartIndex(Crx_C_HashTable const * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_hashTable_getEndIndex(Crx_C_HashTable const * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_hashTable_getNextIndex(Crx_C_HashTable const * pThis,
		size_t pIndex);

CRX__LIB__PRIVATE_C_FUNCTION() size_t crx_c_hashTable_private_prepareSeedForHash(
		void const * pPointer, void const * pPointer2);

CRX__LIB__C_CODE_END()

#if(CRXM__IS(CRX__LIB__MODE, CRX__LIB__MODE__HEADER_ONLY))
	//INCLUDE THE CORRESPONDING .c.h FILE FROM THE CRXed CODE. DO NOT INCLUDE ANY OTHER FILE
	#include "Crx/C.H/crx/c/HashTable.c.h"
#endif
#if(CRX__PREPROCESSOR__HAS_PUSH_MACRO)
	#pragma pop_macro("CRX__LIB__MODE")
#endif

#endif