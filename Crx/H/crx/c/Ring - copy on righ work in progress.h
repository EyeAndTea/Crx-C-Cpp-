#if(!defined(CRX__C__RING___h__))
#define CRX__C__RING___h__

#include <boost/version.hpp>
#include "Crx/H/crx/crx.h"
#if(CRX__PREPROCESSOR__HAS_PUSH_MACRO)
	#pragma push_macro("CRX__LIB__MODE")
	#undef CRX__LIB__MODE
	#if(!defined(CRX__CONFIG__MODE))
		#define CRX__CONFIG__MODE CRX__LIB__MODE__STAND_ALONE
	#endif
	#define CRX__LIB__MODE CRX__CONFIG__MODE
#else
	#undef CRX__LIB__MODE
	#if(!defined(CRX__LIB__C_MODE))
		#define CRX__LIB__C_MODE CRX__LIB__MODE__STAND_ALONE
	#endif
	#define CRX__LIB__MODE CRX__LIB__C_MODE
#endif
//<<START>>	INCLUDE ".h" OF C NON CRXed CODE THAT THIS HEADER NEEDS.
//			INCLUDE ".h", NOT ".c.h", OF C CRXed CODE.
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <malloc.h>
#include "Crx/H/crx/c/TypeBluePrint.h"
//<<END>>
	
CRX__LIB__C_CODE_BEGIN()

/*
--------------------
--------1-----------
--------------------	
THE FOLLOWING DEMONSTRATE THE THOUGHT PROCESS THAT LEAD TO THIS ARCHITECTURE, NOT A FEATURE
TABLE. THE FIRST THREE COLUMNS WHERE WHAT TO LEAD TO THE FIRST ARCHITETURE. EACH OF THOSE THREE
REPRESENTED A PARAMETER TO THE TEMPLATE. THE DECISION WHERE MADE SUCH AS ANY COMBINATION OF
SELECTED PARAMATERS FOR A TEMPLATE WOULD LEAD TO VALID INSTANTIATION.

LATER HOWEVER SOMETHING SUBTLE CHANGED IN MY MIND. I NO LONGER WANTED THE SAME "CLASS" TO BEHAVE
AS ONLY ONE SINGLE TYPE. IF A CLASS COULD BEHAVE AS MULTIPLE TYPES, WHILE NO REDUNDANCY IN THE
DATA STRUCTURE, THEN I CAN COMBINE THEM AND HAVE DIFFERENT METHODS FOR DIFFERENT BEHAVIORS.
THIS IS WHAT THE LAST THREE REMAINING COLUMNS REPRESENT.

WITH THE NEW ARCHITECTURE, DESIGNING THE TYPE LESS VARIATIONS OF RING AND FIXED RING BECAME EASIER,
OR SIMPLY POSSIBLE. I FORGET. NOW, THE FIXED RING CAN NOT HAVE A TYPE LESS VARIATION, NOR IS IT A
SHORT COMING.

I MADE A MISTAKE IN THE RESEASONING SOME HOW WITH THE FIRST ARCHITECTURE, AND I AM HOPING THIS
WRITE UP HELPS ME UNDERSTAND THE MISTAKE, AND NOT MAKE IT AGAIN. I THINK THE CRUX OF THE MISTAKE
IS WHAT I MENTIONED IN PARAGRAPH 2. THE ESSENCE OF IT IS THAT IF A CLASS CAN HAVE DIFFERENT
BEHAVIORS WHILE REMAINING THE SAME TYPE, IT IS STILL ONE CLASS. A CAT IS STILL A CAT WHETHER IT DOES TRICKS
OR NOT, FOR EXAMPLE. IN THE PREVIOUS ARCHITECTURE, I SAW THE TWO CATS AS SEPERATE. HOWEVER, I CAN STILL
SEE ALSO WHY SOMETIMES YOU WANT TO MAKE BEHAVIOR PART OF THE TYPE. AM I WRONG? I DO NOT KNOW. 
BUT PERHAPS THE ANSWER TO KNOWING IN EACH CASE IS TO TAKE THE TYPE, AS HAPPENED HERE, AND SEE IF YOU 
CAN TURN IT TYPELESS, SUCH AS IN THE END ALL THE INFORMATION KEPT ABOUT THE TYPE IS IT BYTE SIZE AND 
AT RUNTIME.

I ALSO MADE A MISTAKE IN FORGETTING THAT STACK ONLY ALSO MEANS THAT THE TYPE HAS A FIXED SIZE WHICH
IS WHAT ALLOWS IT TO OPERATE ON THE STACK OF THE CALLER IF HE WANTED. BUT IT STILL HAS FIXED SIZE, 
MEANING IT IS NOT A SITUATION WHERE YOU CAN SET THE FIXED SIZE FOR EACH DIFFERENT INSTANCE.
WHERE 'FIXED' IN "FIXED RING" BEFORE MEANT FIXED IN SIZE, WHICH IS A SIZE THAT COULD BE SET FOR
EACH INSTANCE. 'FIXED' NOW MEANS, FIXED IN SIZE FOR ALL INSTANCES; ALL INSTANCES HAVE THE SAME
EXACT SIZE.


Eats Itself		Stack Only		No Auto Resize		Can have 		Can have		Can have
													auto resize 	no resize 		round
													operations		operations		operations
	F				F				F					Y				Y				Y				Ring
	F				F				T					Y				Y				Y				Ring
	F				T				T					N				Y				Y			Fixed Ring
	T				F				T					Y				Y				Y				Ring
	T				T				T					N				Y				Y			Fixed Ring
	
	
	
	
--------------------
--------2-----------
--------------------

THE FOLLOWING IS A BIT HISTORY ABOUT SOME OF THE FUNCTIONS.

I RELIZED THAT RINGS CAN BE EFFICIENT FOR INSERTION AT BOTH ENDS, THE PUSH AND THE PUSH TO FRONT. THE RINGS
WERE ALMOST THE PERFECT ARRAY, BUT THEY MISSED INSERTIONS IN THEIR MIDDLE. ALTHOUGH NOT FAST AS A LIST,
A DYNAMIC RING CAN STILL BE FOUR TIME FASTER THAN A NORMAL ARRAY FOR MIDDLE INSERTIONS. THIS MADE
INSERTIONS FUNCTIONS PART OF THE DESIGN. I THEN REALIZED THAT THE INSERTION FUNCTIONS WERE NOT GENERAL. THEY
WEDGE ELEMENT IN BETWEEN, BUT IF I WANT TO INSERT WITHOUT WEDGING, MEANING WITH OVER WRITE?

I INTRODUCED FUNCTIONS THAT ALLOWED ONE TO COPY A RANGE OF ELEMENTS INTO THE ARRAY. THE FUNCTION REQUIRED
AN INSERTION INDEX, AND A LENGTH. THE REQUIREMENT WAS FOR THE INSERTION INDEX TO BE WITHIN THE USED AREA
OF THE ARRAY, TO FIND UNDEFINED SPACE BEFORE THE INSERTION POINT. THE LENGTH CAN BE OF ANY SIZE. HENCE,
THESE FUNCTIONS COULD END UP ENLARGING THE ARRAY OR KEEPING IT AT ITS SIZE. ANOTHER WAY OF LOOKING AT IT,
THEY COULD REPLACE A SMALLER SEGMENT WITH A LARGER SEGMENT, OR REPLACE A SEGMENT WITH AN EQUAL SIZE
SEGMENT. GENERALIZING, I REALIZED THIS DESIGN WAS INCOMPLETE. TO BE COMPLETE, I WOULD ALSO NEED
TO REPLACE A LARGER SEGMENT WITH A SMALLER SEGMENT.

THIS INRODUCED A NEW FUNCTION FOR REPLACING ONE SEGMENT WITH ANOTHER FROM ANOTHER ARRAY. I QUICKLY REALIZED THAT
THIS WAS LIKE A REPLACE SUBSTRING FUNCTION FOR STRINGS. WITH THIS I RELEAIZED THAT ALTHOUGH THE FUNCTION I
PROVIDED IS SIGNIFICANTLY FASTER FOR ONE SUBSTRING REPLACEMENT, IT IS SIGNIFICANTLY SLOWER FOR MORE THAN FOUR
REPLACEMENTS. IF ONE IS REPLACE MANY OCCURANCES OF A SUBTRING, IT WOULD BE FASTER TO SIMPLY RECREATE THE STRING.
THUS, THE FUNCTION I INTRODUCED WAS INCORRECT. WHAT DID I NEED TO INTRODUCED SUCH AS FOR THE ONE SEGMENT REPLACEMENT
THE REPLACEMENT IS FASTER, WHILE NOT ACTUALLY BEING A FUNCTION THAT PROMISES REPLACING SEGMENTS.

FOR THE CASE WHERE A LARGE SEGMENT IS REPLACED WITH A SMALLER ONE, I INTRODUCED THE DELETE FUNCTION WHICH
ALLOWED DELETING PART OF THE RING. THIS ALLOWED THE USER TO EVENTUALLY DELETE A PART OF IT, AND SIMPLY OVER WRITE
A SEGMENT WITH AN EQUAL LENGTH SEGMENT.

FOR THE CASE WHERE A SMALLER SEGMENT IS REPLACE WITH A LARGER SEGMENT, I COULD NOT INTRODUCE A FUNCTION THAT 
INSERT EMPTY SPACE BECAUSE THAT WOULD CREATE UNDEFINED MEMORY AREA. I COULD ALSO NOT DICTATE THAT A ZEROED BLOCK
IS A VALID INSTANCE OF THE TYPE PROVIDED, BECASE THAT WOULD LIMIT THE APPLICATION OF MY ARRAYS. I COULD ALSO NOT
REQUIRE A FUNCTION TO CREATE AN 'EMPTY' INSTANCE OF THE TYPE, BECAUSE THAT IS AN INDIRECT CONSTRUCTOR, AND THAT
WOULD LEAD ME TO GENERALIZE ON CONSTRUCTORS, AND I AM TRYING TO AVOID ASKING FOR MEMORY OPERATION FUNCTIONS.

I ENDED INTRODUCING A FUNCTION THAT ALLOWS N INSERTION OF ONE ELEMENT AT A PARTICULAR INDEX. WITH THIS,
I GENERALIZED, BUT I LOST THE BATTLE WITH THE COPY OPERATIONS WHICH I WOULD NOT HAVE TO SUPPORT.


--------------------
--------3-----------
--------------------

THE FOLLOWING ARE NOTES PERTAINING TO THE MOVABILITY ISSUE KEPT FOR REFERENCE PURPOSES. THE BEGGIING PARAGRAPH
		WAS PART OF THE SPECIFICATION OF THE ARRAYS, BUT IT NO LONGER IS

- pELEMENT_TYPE MUST BE "RAW MOVABLE" (SEE MY STANDARD). THIS MEANS THAT IT IS A TYPE THAT CAN BE TRVIALLY 
			MOVED IN FULL FROM ONE LOCATION TO ANOTHER. IN OTHER WORDS AN INSTANCE OF THIS TYPE CAN BE MOVED
			BY BYTE COPYING USING memmove OR memcpy OR SIMILAR, THEN DISCARDING THE OLD COPY WITHOUT CALLING
			DESTRUCTORS OR SIMILAR. 

			IN THE FUTURE I MIGHT ADD SUPPORT FOR TYPES THAT DO NOT SUPPORT THIS CRITERIA.

			IN THE PAST, I WANTED TO AVOID SUPPORTING AN EXPLICIT MOVE FUNCTION. THINGS TO CONSIDER BACK END
					THEN IF ADDING SUPPORT FOR "PRACTICAL MOVE" (SEE MY STANDARD), WERE:
							- WE CAN NOT DIFFERENTIATE BETWEEN "PRACTICAL MOVE" AND "MOVE" WITHOUT BREAKING
									MY RULE OF API DESIGN WHERE THE NUMBER OF FUNCTION PARAMETERS MAY NOT BE A 
									FUNCTION OF THE VALUE OF ONE OF THE OHTER PARAMETERS. FOR EXAMPLE, WE CAN
									DEDUCE WHETHER WE SHOULD CALL THE DESTRUCTOR IF A DESTRUCTOR FUNCTION IS
									PASSED, BUT IF A DESTRUCTOR FUNCTION IS PASSED ALONG WITH A COPY FUNCTION, 
									THE CASE MIGHT BE A TYPE REQUIRING "MOVE" OR A TYPE REQUIRING "PRACTICAL
									MOVE", AND THUS WE WOULD NEED AN EXTRA PARAMETER FOR A FLAG, AND THAT
									PARAMETER WOULD BE IGNORED IF NO MOVE FUNCTION WAS PASSED, BREAKIG THE API
									DESIGN RULE. HENCE, WE WILL ONLY ADD SUPPORT, IF WE DO, FOR "PRACTICAL MOVE",
									NOT "MOVE".
							- IN THE FUTURE: IF BOTH DESTRUCTOR AND COPY FUNCTIONS ARE PASSED: WE ASSUME
									"PRACTICAL MOVE", OTHER WISE, WE ASSUME "RAW MOVE"
									HOWEVER WHAT IF A DESTRUCTOR FUNCTION IS PASSED WITHOUT A COPY FUNCTION,
									AND CALLER WANTS US TO CALL THE DESTRUCTOR WHEN MOVING?

					LATER I THOUGHT ABOUT WHETHER AN EXPLICIT MOVE FUNCTION SUPPORT IS REQUIRED, WHICH IS SOMETHING
							I AM HOPING TO AVOID. THIS DEPENDS ON WHETHER THE SITUATION WHERE AN OBJECT'S INTERNAL
							PART NEEDS BYTE COPY FOR MOVE, WHILE THE ORIGINAL INTERNAL PART STILL NEEDS AN EXPLICIT
							DESTRUCTOR CALL IS POSSIBLE (SEE MY STANDARD). I AM CALLING THIS FOR NOW, PECULIAR MOVE.
							I AM ALSO HOPING TO AVOID HAVING TO CALL THE DESTRUCTOR DURING MOVE, WHEN DESUTRCTOR
							FUNCTION IS PASSED AND NO COPY FUNCTION, OR IN THE FUTURE, MOVE FUNCTION, IS PASSED.
							
							WE WILL NEED TO INVESTIGATE THE POSSIBILITY OF ALL COMBINATION OF MOVE AND COPY 
							OPERATIONS ON OBJECTS, PER MY STANDARD. THESE ARE:
									- RAW COPY, RAW MOVE: THIS IS OBVIOUSLY POSSIBLE.
									- RAW COPY, MOVE: THIS IS NOT POSSIBLE BECAUSE THE MOVE COULD BE
											DONE BY THE CODE BY FIRST DOING A RAW COPY, AND THEN
											A DESTRUCT CALL AVOIDING ANY ALGORITHMS RUNNING FROM THE
											OBJECT DURING THE MOVE. EVEN THOUGH A DESTRUCT MIGHT LATER BE
											CALLED, THE INFORMATION THAT IS THE FACT THAT A MOVE WAS DONE
											DOES NOT LEAK. FURTHERMORE, IF A MOVE FUNCTION EXPECTS
											TO BE CALLED FOR MOVE, IT IS ILL DEFINED BECAUSE IN THE END
											IT IS UP TO THE OTHER CODE TO DECIDE WHAT TO CALL.
											NOTE THAT IF WE HAVE A SYSTEM THAT WILL USE ONLY MOVE FOR MOVING,
											AND ONLY COPY FOR COPYING, THEN THIS BECOMES POSSIBLE.
											(UPDATE: REMEMBER AT THIS POINT, I DID NOT HAVE "MOVE DESTRUCTOR"
											IN MY STANDARD).
									- RAW COPY, PRACTICAL MOVE: THIS IS NOT POSSIBLE FOR THE SAME REASONS AS
											THE PREVIOUS CASE.
									- COPY, RAW MOVE: POSSIBLE
									- COPY, MOVE: POSSIBLE
									- COPY, PRACTICAL MOVE: POSSIBLE
							AND IF PECULIAR MOVE PROVES POSSIBLE:
									- RAW COPY, PECULIAR MOVE
									- COPY, PECULIAR MOVE
									
					IT IS NOW CLEAR THAT AN EXTRA MOVE FUNCTION IS REQUIRED, AND AN EXTRA DESTRUCT FUNCTION.
							NOTE THAT THE COPY OPERATION USED FOR THE PURPOSE OF COPYING IS NOT NECESSARILY 
							THE SAME AS THE COPY OPERATION USED FOR THE PURPOSE OF MOVING, HENCE THE ORIGINAL
							IDEA OF ONLY SUPPORTING "RAW MOVE" AND "PRACTICAL MOVE" AND ASSUMING
							"PRACTICAL MOVE" ONLY IF BOTH COPY AND DESTRUCT FUNCTIONS ARE PASSED, IS INVALID.
							HENCE WE NEED AN EXPLICIT MOVE FUNCTION.
							ALSO NOTE THAT THE GENERAL DESTRUCT FUNCTION, AND THE DESTRUCT FUNCTION REQUIRED
							TO BE CALLED ON THE ORIGINAL COPY DURING MOVE ARE NOT THE SAME. FOR EXAMPLE, THE
							TYPE MIGHT REQUIRE DESTRUCTION IN GENERAL, BUT ALSO SUPPORTS "RAW MOVE", AND THIS
							IS NOT IMPOSSIBLE. IN THIS CASE, THE GENERAL DESTRUCTOR IS SOME ALGORITHM, WHILE
							THE DESTRUCTOR FOR THE PURPOSE OF MOVE IS SIMPLY THE DO NOTHING ALGORITHM. HOWEVER
							THIS DESTRUCTOR IS ROUGHLY NOT NEEDED WHEN "MOVE" AND WHEN "PRACTICAL MOVE",
							BECAUSE THE INFORMATION THAT THE OBJECT WAS MOVED LEAKS TO THE OBJECT WITH THESE
							TWO, AND HENCE THE OBJECT CAN BEHAVE ACCORDINGLY IN THE NORMAL DESTRUCTOR. HENCE,
							WE MIGHT THINK THAT IF WE IGNORE "PECULIAR MOVE" AND "MOVE, WE CAN DO AWAY WITH
							THE SECOND DESTRUCTOR, AND OUR SITUATION FOR WHAT FUNCTIONS ARE PASSED BECOMES:
									- DESTRUCT FUNCTION, MOVE FUNCTION: PECULIAR MOVE
									- DESTRUCT FUNCTION: RAW MOVE
									- MOVE FUNCTION: ?
									- NEITHER: RAW MOVE
							NOTICE HOW WHEN ONLY THE MOVE FUNCTION IS PASSED WE HAVE A PROBLOMATIC SITUATION,
							BECAUSE IN THIS CASE IT WOULD BE "MOVE", BUT YET OUR API CAN NOT BE USED TO INDICATE
							"MOVE" AND AN OBJECT THAT REQUIRES DESTRUCTION FOR OTHER THINGS.
							IN CONCLUSION, BOTH A MOVE FUNCTION AND A SECOND DESTRUCT FUNCTION IS REQUIRED
							IF WE ARE TO SUPPORT "PECULIAR MOVE".
							WHAT IF WE ONLY SUPPORT "MOVE"? OUR SITUATION NOW BECOMES:
									- DESTRUCT FUNCTION, MOVE FUNCTION: MOVE
									- DESTRUCT FUNCTION: RAW MOVE
									- MOVE FUNCTION: MOVE
									- NEITHER: RAW MOVE
							WHICH IS VALID. "MOVE" SUPPORT ONLY IS NOT VERY PRACTICAL ESPECIALLY IF
							WORKING WITH C++ CODE WHERE MOVE THERE IS GENERALLY "PRACTICAL MOVE", 
							BUT "PRACTICAL MOVE" CAN STIL BE IMPLEMENTED USING THE SAME MOVE FUNCTION
							THAT IS TO BE PASSED, WHERE THE CALLER MUST CALL THE DESTRUCTOR HIMSELF 
							IN SIDE THE MOVE FUNCTION, AND NOT RELEASE THE MEMORY.
							THE FINAL DESIGN NOW BECOMES:
									- DESTRUCT FUNCTION, MOVE FUNCTION: MOVE OR PRACTICAL MOVE
									- DESTRUCT FUNCTION: RAW MOVE
									- MOVE FUNCTION: MOVE OR PRACTICAL MOVE
									- NEITHER: RAW MOVE
							AND WE OURSELVES IN THE CODE NEVER CALL THE DESTRUCTOR DURING MOVE. THIS COVERS
							ALL CASES EXCEPT THOSE OF "PECULIAR MOVE". THIS IS 12 OUT OF 16 CASES.
							
					UPDATE: THIS SCHEME CURRENTLY GIVES PROBLEMS BECAUSE THE MOVE FUNCTION SHOULD BE
							ALLOWED TO DESTRUCT THE ORIGINAL OBJECT, AND THIS IS ONLY POSSIBLE IF WE CAN GUARANTEE
							THAT THE OBJECT WILL NOT BE DESTROYED AGAIN. IN THE "take" FUNCTIONS BELOW, WE CAN
							NOT ASSUME THAT. THIS IS NOT A PROBLEM WITH C OBJECTS (POD OBJECTS). BUT WITH C++ 
							OBJECTS IF THE MOVE FUNCTION DESTRUCTS THE ORIGINAL OBJECT, THE ORIGINAL OBJECT
							IS LIKELY TO BE DESTRUCTED TWICE, ONCE BY THE MOVE FUNCTION, AND ONCE BY THE C++ 
							COMPILER.
							
							THE IDEA OF USING AN EXTRA BOOLEAN PARAMETER WITH THE MOVE FUNCTION THAT INDICATES
							WHETHER THE CALLE MAY DESTRORY THE ORIGINAL OBJECT, ALSO FAILS. THIS IS BECAUSE
							IN THE "take" FUNCTIONS, SOME TIME WE CAN DESTROY THE ORIGINAL OBJECT. THIS
							IS WHEN "take" FUNCTION IS CALLED BY OUR EQUIVILANT NON TAKING FUNCTION. AND
							ALL OTHER TIME, WE CAN NOT DESTROY THE ORIGINAL OBJECT, AND THIS CASE IS FINE. BUT
							THE FIRST CASE REQUIRES THAT WE OURSELVES BE AWARE OF THE MOVE DESTRUCTOR TO CALL IT,
							MEANING OUR TAKE FUNCTIONS MUST NOT HAVE A PRIVATE IMPLEMENTATION THAT ACCEPTS AN EXTRA
							BOOLEAN PARAMTER TO BE PASSED TO THE MOVE FUNCTION, BREAKING OUR SIMPLIFICATION.
							
							IN THE END IT SEEMS I HAVE TO SUPPORT AN EXTRA PARAMTER FOR THE MOVE DESTRUCTOR FUNCTION,
							BUT THIS WOULD MEAN THAT I HAVE TO SUPPORT "PECULIAR MOVE", WHICH IS GENERALLY
							NOT USEFULL AND WHOSE SUPPORT IS NON TRIVIAL, AND HENCE, I DO NOT WANT TO DO THAT.


--------------------
--------4-----------
--------------------	
THE INCLUSION OF THE INTERNAL BUFFER AS PART OF THE ARRAY IS QUESTIONABLE. IF AN ARRAY
WITHOUT A BUFFER, AND AN ARRAY WITH ONLY A BUFFER (FIXED RING) COULD BE USED TO CONSTRUCT A NEW
ARRAY THAT HAS AN INTERNAL BUFFER, THEN THE FOLLOWING DESIGN IS WRONG BECUASE IT IS NOT REDUCED.

REMEBER THAT ANOTHER TYPE OF STORAGE IS STORAGE ON A DYNAMIC INTERNAL BUFFER RATHER THAN JUST
A FIXED ONE, WHICH SAVES ONE HEAP ALLOCATION. BECAUSE OF REDUCTION, WE MUST GENERALIZE, AND HENCE
WE ADD THE FIXED SIZE INTERNAL BUFFER. SO REMEMBER THAT THE ARRAY WAS DESIGNED TO ALLOW IF DESIRED A SINGLE HEAP
ALLOCATION INSTEAD OF TWO WHEN USING THE "NEW" FUNCTIONS, WHICH IS WHY THE INTERNAL BUFFER ENDED UP BEING PART
OF THE DESIGN.

WITH THIS, AS AN EXAMPLE, WE CAN IMPLEMENT A NEW ARRAY WITH COPY ON WRITE AND A FIXED SIZE INTERNAL BUFFER FOR
OPTIMIZATION, USING AN ARRAY WHOSE TEMPLATE IS INSTNATIATED WITH THE DYNAMIC INTERNAL BUFFER FEATURE, AND A FIXED
ARRAY INSTANTIATED TEMPLATE FOR THE NEW ARAY'S INTERNAL BUFFER. IF THE NEW ARRAY IS FOR CHARACTERS, WE WOULD HAVE
A STRING WITH SMALL STRING OPTIMIZATION, AND COPY OF WRITE.


<IMPORTANT>: HOWEVER THE DESIGN IS INDEED WRONG FOR THE Array/Ring, AND THE INTERNAL BUFFER SHOULD NOT BE PART
OF THEM. HOWEVER, IT IS CORRECT FOR FixedArray/FixedRing. IT IS WRONG BECAUSE ONE CAN BUILD AN ARRAY WITH AN
INTERNAL BUFFER THAT COULD HAVE A SIZE SET AT RUNTIME BY USING Array/Ring FOR THE DYNAMIC DATA, AND
FixedArray/FixedRing FOR THE INTERNAL BUFFER. ALTHOUGH THIS IS THE CORRECT DESIGN PER WHAT I CALL REDUCTION, A 
DYNAMIC ARRAY WITH INTERNAL BUFFER WITH SIZE SET AT RUNTIME WOULD BE LESS PERFORMANT THAN THE CURRENT Array/Ring.
OF COURSE, IF ONE ABANDONS REDUCTION AS THE MEASURE, AND GOES FOR PERFORMANCE AS THE "MEASURE", THEN THE SAME THING
CAN BE SAID ABOUT COPY ON WRITE. AN IMPLEMENTATION HAVING COPY ON WRITE WOULD BE FASTER THAN ONE BUILT ON TOP
OF Array/Ring AND FixedArray/FixedRing. HENCE STRICTLY SPEAKING IF I AM TO KEEP THE CURRENT DESIGN, I HAVE TO
IMPLEMENT COPY ON WRITE IF IT IS TO BE CORRECT.

SHOULD YOU DECIDE TO FIX THIS PROBLEM:
	TO FOLLOW THE FIRST OPTION AND REMOVE THE INTERNAL, AND IF YOU WISH TO HAVE THE INTERNAL BUFFER 
	FUNCTIONALITY, MEANS TO CREATE NEW STRUCTURES HOLDING Array/Ring AND FixedArray/FixedRing, 
	OR Array/Ring AND Array/Ring DEPENDING ON WHETHER YOU WANT THE INTERNAL BUFFER TO BE OF FIXED SIZE, 
	OR DYNAMIC SIZE.

	TO FOLLOW THE SECOND OPTION, THE gPrivate_elements WOULD INSTEAD POINT TO A STRUCTURE OF VARIABLE SIZE
	HOLDING ITS CAPACITY AND THE ELEMENTS BUFFER PART OF ITSELF. THIS STRUCTURE WOULD BE SUCH AS IT IS 
	STILL USED REGARDLESS WHETHER THE TEMPLATE OF Array/Ring WAS INSTANTIATED WITH COPY ON WRITE OPTION OR
	NOT TO EASE DEVELOPMENT. ensureCapacity() ATLEAST WILL LIKELY HAVE TO BE UPDATED TO DETACH THE 
	Array/Ring FROM A BUFFER THAT IS SHARED. IN OTHER WORDS CALLS TO THIS FUNCTION CAN BE ASSUMED TO 
	INDICATE THE INTENTION OF WRITING TO THE ARRAY. ensureCapacity() WOULD NO LONGER RETURN IMMEDIATELY 
	IF CAPACITY IS AVAILABLE, UNLESS THE BUFFER IS NOT SHARED.
	THE FINAL ISSUE WOULD BE TO INCLUDE MY THREAD POSSIBLITY SEMANTICS INTO THE Array/Ring, WHICH I
	CURRENTLY HAVE NO SOLUTION FOR. NOTE THAT THE DESIGN DISCUSSED IN THIS PARAGRAPH DOES NOT AFFECT THE
	MEMEORY REQUIREMENTS OF Array/Ring, WHILE AN EXTRA FLAG TO INDICATE THREAD POSSIBILITY WOULD.
	
IN ANY CASE, I HAVE DECIDED TO AVOID IMPLEMENTING COPY ON WRITE IN C FOR THE TIME BEING. I HAVE INVESTIGATED 
MULTIPLE LIBRARIES FOR C STRINGS, INCLUDING Glib (https://developer.gimp.org/api/2.0/glib/glib-Strings.html),
BString (http://bstring.sourceforge.net/), VStr (http://www.and.org/vstr/), 
SEI/CERT library (https://resources.sei.cmu.edu/library/asset-view.cfm?assetID=9531),
sds (https://resources.sei.cmu.edu/library/asset-view.cfm?assetID=9531), 
str (https://github.com/maxim2266/str) AND
Safe C String Library (https://web.archive.org/web/20120106082553/http://zork.org/safestr/safestr.html).
VStr (SEE http://mike.steinert.ca/bstring/doc/md_comparisons.html), AND Safe C String Library, WHICH I COULD NOT 
FIND, APPEARS DEAD, USE COPY ON WRITE.
MEANS NO COPY ON WRITE. THE SEI/CERT library APPEARS FORMAL, AND IT DID NOT USE COPY ON WRITE. I ALSO INVESTIGATED
THE C PROJECTS SQLITE3 (DATABASE), PCRE AND PCRE2 (REGEX ENGINE), AND REDIS (DATABASE), AND THEY EITHER USE NORMAL
CHARACTER ARRAYS, OR THEIR STRING IMPLEMENTATIONS DO NOT USE COPY ON WRITE.

OF COURSE, BY NOT IMPLEMENTING COPY ON WRITE, AND KEEPING THE INTERNAL BUFFER, THE CURRENT DESIGN,
STRICTLY SPEAKING, IS LIEKLY STILL WRONG. IN THE FUTURE, DO NOT REMOVE THE INTERNAL BUFFER, BUT SEEK TO ADD 
COPY ON WRITE (WHICH INCLUDES THREAD POSSIBILITY SEMANTICS) IFF IT PROVES TO BE INDEED USEFUL IN C AND ITS 
APPLICATIONS, MEANING GIVES SIGNIFICANT PERFORMANCE GAINS WHEN USED, AND INSIGNIFICANT PERFORMANCE LOSS WHEN
NOT. REMEMBER, COMPUTATION WOULD BECOME PART OF THE MEASURE IF KEEPING THE INTERNAL BUFFER. ALSO REMEMBER WHEN 
COPY ON RIGHT IS NOT USED, ASSUMING COPY ON RIGHT SUPPORT HAS BEEN ADDED, THE CODE PRODUCED WOULD STILL BE 
DIFFERENT THAN WHAT THE CURRENT Array/Ring PRODCUES, HENCE THE POSSIBLE EXTRA COMPUTATION COST HERE AND THERE, SUCH 
AS THE TWO DIFFERENT VARIABLES THAT COULD BE HOLDING THE CAPACITY AND THE CODE TO UPDATE ONE WHENEVER THE OTHER
IS CHANGED. SEE THE DESIGN NOTES ABOVE FOR THE COPY ON WRITE OPTION.


<UPDATE>
I DECIDED TO ADD COPY ON WRITE, BUT CURRENTLY I MAINTAIN CODE WITH IT AND WITHOUT IT. IT IS STILL
EXPERIMENTAL.

A FLAG IS NOT USED TO IMPLEMENT MY THREAD POSSIBLE SEMANTICS. THIS IS BECAUSE THE FLAG WOULD INCREASE
		MEMORY REQUIREMENTS INVALIDATING THE PREMISES THAT ALLOW, AND REQUIRE, IMPLEMENTING COPY ON RIGHT
		IN THE FIRST PLACE. A SECOND REASON IS THAT IN C, IT IS NOT POSSIBLE TO ENFORCE THE CONVERSION
		RULES BETWEEN A THREAD POSSIBLE TYPE AND ITS NOT THREAD POSSIBLE COUNTER PART AUTOMATICALLY.
		HOWEVER THIS ISSUE IS MANAGABLE. I TRIED THE FOLLOWING ALREADY TO IMPLEMENT THREAD POSSIBLE
		SEMANTICS WITHOUT A FLAG ON THE ARRAY INSTANCE ITSELF:
	(1) IMPLEMENT "THREAD POSSIBLE" METHOD COUNTERPARTS FOR ALL METHODS THAT CAN POTENTIALLY CAUSE
			A SHARING OF THE EXTERNAL BUFFER. THIS APPROACH ENDS UP BEING INCORRECT. AN IMPLICATION
				OF IT IS THAT A THREAD POSSIBLE ARRAY CAN NOT BE USED AS A THREAD IMPOSSIBLE ARRAY,
				WHICH IS COUNTER INTUITIVE. IMAGINE PASSING A THREAD POSSIBLE ARRAY TO A FUNCTION 
				EXPECTING A THREAD IMPOSSIBLE ARRAY. WITHIN THE FUNCTION, CODE WOULD NOT CALL THE 
				THREAD POSSIBLE FUNCTIONS AND MIGHT END UP SHARING THE EXTERNAL BUFFER OF THE THREAD 
				POSSIBLE ARRAY. EVEN IF THIS APPROACH WAS NOT PROBLOMATIC, THE FACT THAT 
				A THREAD POSSIBLE CAN NO LONGER BE USED INSTEAD OF THREAD IMPOSSIBLE, MEANS THAT
				THE IMPLEMENTATION IS REDUNDANT BECAUSE ONE CAN SIMPLY INSTANTIATE TWO ARRAY CLASSES
				ONE WITH COPY ON WRITE, AND ONE WITHOUT, AND THISE WOULD BE MORE CORRECT BECAUSE
				THE COMPILER WOULD NOW MAKE SURE YOU DO NOT USE THESE INCORRECTLY.
	(2) ADD A FLAG TO THE EXTERNAL BUFFER STATING WHETHER IT CAN BE SHARED OR NOT. THEN, FOR ALL
			METHODS ACT "THREAD POSSIBLE" COUNTER PARTS. THIS IS ACTUALLY ONLY NEEDED FOR METHODS
			THAT CAN POTENTIALLY CREATE A NEW EXTERNAL BUFFER. THE AIM IS THAT AS SOON AS THE BUFFER
			IS CREATED, A FLAG WOULD BE SET. THIS APPROACH ALSO PROVED INCORRECT. THIS IS BECAUSE
			AN ARRAY IS NOT NECESSARILY USING AN EXTERNAL BUFFER. IMAGINE PASSING A THREAD POSSIBLE
			ARRAY, BEING ONE WHERE ALL THE METHODS USED, INCLUDING A "THREAD POSSIBLE" new METHOD
			ARE THE "THREAD POSSIBLE" COUNTER PARTS, AND THAT ARRAY IS PASSED TO A FUNCTION NOT EXPECTING
			A THREAD POSSIBLE ARRAY. THE CODE WOULD CONTINUE WORKING IFF THE ARRAY WAS AND CONTINUES TO BE
			USING AN EXTERNAL BUFFER. OTHERWISE, AGAIN, THE ARRAY HAS NO INFORMATION ABOUT THE FACT
			THAT IT IS THREAD POSSIBLE.
	(3) SAME AS (2), BUT MAKE THREAD POSSIBLE ARRAYS FORBIDDEN FROM USING THE INTERNAL BUFFER WHEN ONE
			EXISTS. THE PROBLEM WITH THIS APPROACH IS THAT AN ARRAY BY DESIGN CAN HAVE THE EXTERNAL BUFFER
			SET TO NULL EVEN IF THE ARRAY IS CURRENTLY USING IT, IN WHICH CASE IT WOULD HAVE A CAPACITY
			OF ZERO. ALTHOUGH THIS ONLY HAPPENS WHEN THE ARRAY DOES NOT HAVE AN INTERNAL BUFFER,
			IT WOULD STILL BE A PROBLEM BECAUSE SETTING A CAPACITY TO ZERO WHILE HAVING AN INTERNAL
			BUFFER IS CONTRARY TO THE DESIGN. REMEMBER THAT CAPACITY OF ZERO IS ONLY ALLOWED IF
			NO INTERNAL BUFFER EXISTS, IN WHICH CASE, THE POINTER TO THE EXTERNAL BUFFER WOULD BE NULL.
			TO REMIND YOURSELF MORE ABOUT THIS, SEE THE METHOD empty() WHICH IS DESIGNED TO NOT FAIL.
	(4) SAME AS (1) BUT WITH A FLAG ON THE EXTERNAL BUFFER. THIS APPROACH ENDS UP BEING INCORRECT FOR
			SIMILAR REASONS TO THOSE OF (1), AND SIMILAR REASONS TO THOSE OF (2)
			
THE CONCLUSION FROM THE ABOVE IS THAT THREAD POSSIBILIY CAN ONLY BE IMPLEMENTED WITH A FLAG ON THE ARRAY.
I LATER ENDED UP ADDING SUCH A FLAG. THIS OFCOURSE MEANS THE PROJECT HAS FAILED. HOWEVER, IN RETROSPECT
THE REDUNDANCY THAT LED TO THE REQUIREMENT THAT COPY ON RIGHT BE IMPLEMENTED WHICH WAS CAUSED BY THE INTERNAL 
BUFFER, MIGHT BE SEEN TO HAVE BEEN CAUSED BY FixedArray/FixedRing INSTEAD (WITH A CHANGE OF PREMISE), AND IF
THIS HOLD TRUE THEN IF COPY ON RIGHT IS IMPLEMENTED IT WOULD NO LONGER BE A REQUIREMENT THAT IT ADDS NO NEW
DATA FIELDS. WHETHER COPY ON RIGHT WOULD NEED IMPLEMENTING IN THIS CASE IN THE FIRST PLACE IS ANOTHER
QUESTION, AND THE ANSWER IS PROBABLY NO, AND IMPLEMENTING IT WOULD SIMPLY BE EXPANDING THE TYPE OF ARRAYS
THIS PROJECT SUPPORTS. FURTHERMORE THE FIX FOR THIS REDUNDANCY WOULD SIMPLY BE TO REMOVE THE
FixedArray/FixedRing IMPLEMENTATIONS.

--------------------
--------5-----------
--------------------
pSIZE_T WAS ADDED FOR BETTER MEMORY EFFICIENCY. THE PUBLIC API, HOWEVER, CONTINUES TO USE size_t. CHECKS
OF BOUNDRIES HOWEVER ARE STILL NEEDED, HENCE pSIZE_T_MAX. THE CHECKS, WHICH ARE ASSERTS PER THE DEFINITIONS
IN MY STANDARD, ARE SUCH AS THEY ARE ONLY DONE AT THE SURFACE OF THE CODE, PER MY DEFINITIONS.

I SUERVEYED SOME COMPILERS, IN PARTICULAR THE STRING IMPLEMENTATIONS THAT COME WITH THEM TO SEE
WHAT IS THE VALUE RETURNED BY std::string::max_size(), AND IT APPEARS THAT ON 32BIT SYSTEMS
IT IS ALWAYS (2^32). VC6 HAS (2^32) FOR EXAMPLE. ON 64BIT SYSTEMS, THE VALUE RANGES FROM (2^61) TO (2^64).
IT SHOULD BE NOTED THAT ANY VALUE ABOVE (2^54) IS NOT ACTUALLY POSSIBLE BECAUSE THIS IS THE LARGEST 
MAXIMUM ADDRESSING CURRENTLY SUPPORTED BY ANY CPU, FROM WHAT I REMEMBER. I REMEMBER ONE CASE, WITH 
THE std::stringstream CLASS REPORTED BY ONE USER ABOUT A MICROSOFT COMPILER, WHERE max_size()
GIVES THE RANGE MENTIONED EARLIER ON 64BIT SYSTEMS, WHILE THE SYSTEM CRASHES OR SIMILAR, AT A VALUE
(<= 2^33). THIS IS ON VISUAL STUDIO 2017. GIVEN MY SURVEY, I DECIDED THAT PROVIDING pSIZE_T WHERE
ONE MIGHT USE IT WITH THE VALUE int32_t, IS INDEED NOT A BAD COMPROMISE FOR MEMORY EFFICIENCY. WITH THIS
IF A RING IS TO BE LIMITED TO 32BITS, ONE COULD HAVE AN INTERNAL BUFFER OF SIZE 12BYTES GIVEN MINIMAL
MEMORY COST OPTIONS SUCH AS NO SIZE OF INTERNAL BUFFER FIELD. AS FOR THE ARRAY, ONE COULD HAVE AN
INTERNAL BUFFER OF SIZE 16BYTES, GIVEN MINIMAL MEMORY COST OPTIONS.


--------------------
--------6-----------
--------------------
NOTE: THE FOLLOWING IS FROM MY MEMORY.

INITIALLY I WANTED THE ARRAYS TO BE INITIALIZABLE ON THE STACK AND ON THE HEAP. I ALSO WANTED TO ALLOW
THE INTERNAL BUFFERS TO BE FIXED OR SET AT RUNTIME. THIS IS BECAUSE IT ALLOWS FINE TUNING OF HOW MANY 
HEAP ALLOCATIONS THE CLIENT CODE CAN GO AFTER. BEFORE THE OPTION OF ALLOWING AN INTERNAL BUFFER OR NOT,
THERE WAS A SINGLE PARAMATER, pSIZE_OF_INTERNAL_BUFFER, WHICH ALLOWED TO BOTH CONTROL THE INTERNAL
BUFFER EXISTANCE, AND ITS SIZE. IF pSIZE_OF_INTERNAL_BUFFER WAS ZERO, THERE WOULD BE NO INTERNAL BUFFER
AT ALL. THE ALTERNATIVE, A PARAMETER FOR ENABLING OR DISABLING THE INTERNAL BUFFER, AND A PARAMETER FOR
SETTING ITS SIZE, WOULD BE ILL DEFINED BECAUSE THE TEMPLATE MACRO SIGNATURE WOULD NOT BE REDUCED. IN THIS
CASE BECAUSE THE SIGNATURE WOULD BE A FUNCTION OF ONE OF THE VALUE OF ONE OF THE PARAMETERS OF THE MACRO.
IN OTHER WORDSS, IF THE PARAMTER THAT ENABLED THE INTERNAL BUFFER IS SET TO CRXM__FALSE, THE PARAMETER SETTING
THE SIZE OF THE BUFFER WOULD BE IGNORED.

WHEN I DECIDED TO SUPPORT ARRAYS THAT ALLOW THE SIZE OF THEIR INTERNAL BUFFER TO BE SET AT RUNTIME, I FACED
A DESIGN PROBLEM AGAIN OF KEEPING THE TEMPLATE MAIN MACRO REDUCED. THIS WAS ALSO A PROBLEM WITH THE NON
TEMPLATE (WEAK TYPE) IMPLEMENTATIONS. TO AVOID HAVING TO ADD ANOTHER PARAMTER THAT INDICATES WHETHER
THE INTERNAL BUFFER SIZE CAN BE SET AT RUNTIME, WHICH WOULD BREAK REDUCTION, I CHANGED THE PARAMETER
pSIZE_OF_INTERNAL_BUFFER TO pDEFAULT_SIZE_OF_INTERNAL_BUFFER, AND INTRODUCED THE PARAMETER
pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD. 

HOWEVER, THE NEW PARAMETER, ALTHOUGH SOLVED THE MACRO SIGNATURE ISSUE, INTRODUCED A NEW PROBLEM RELATED
TO THE init() FUNCTION THAT ALLOWS CREATION OF THE ARRAYS ON THE STACK. WHEN A CALLER CREATES AN ARRAY ON 
THE HEAP, WHICH USES new(), new() ENFORCES THE pDEFAULT_SIZE_OF_INTERNAL_BUFFER SEMANTICS. THIS MEANS
THAT WHEN THE CALLER PASSES 0 FOR THE SIZE OF THE INTERNAL BUFFER, THE CODE WOULD DEFAULT TO THE VALUE OF
pDEFAULT_SIZE_OF_INTERNAL_BUFFER. HOWEVER, IF THE CALLER CALLED init() DIRECTLY IN THE CASE WHERE HE IS
CREATING THE ARRAY ON THE STACK, THE MEMORY REQUIRED IS ALREADY ALLOCATED, AND BY THE CALLER, AND HENCE
THE CODE CAN NOT ENFORCE pDEFAULT_SIZE_OF_INTERNAL_BUFFER. FOR A LONG TIME, THIS MEANT THAT THE ARRAYS 
WITH THE STRONGLY TYPED ELEMENTS COULD NO LONGER BE CREATED ON THE STACK, AND init() WAS NO LONGER MEANT
FOR PUBLIC USE. MUCH LATER, HOWEVER, I FINALLY SOLVED THE ISSUE BY INTRODUCING AN assert() IN THE init()
FUNCTION THAT ENSURED THAT WHEN THE SIZE PASSED FOR THE INTERNAL BUFFER IS ZERO, pDEFAULT_SIZE_OF_INTERNAL_BUFFER
IS ZERO EFFECTIVELY ENSURING THAT THE CALLER HIMSELF RETAINS THE SEMANTICS OF pDEFAULT_SIZE_OF_INTERNAL_BUFFER *1*.
ALSO NOTE THAT OTHER WORK WAS DONE DURING THIS TIME RELATED TO THE RELATION SHIP BETWEEN THE THREE
CLASS DATA FIELDS, gPrivate_length, gPrivate_capacity, AND THE POINTER TO THE EXTERNAL BUFFER. THIS LIKELY
PLAYED A ROLE IN ALLOWING ME TO SEE A SOLUTION TO THE PROBLEM, A SOLUTION THAT MIGHT NOT HAVE BEEN
POSSIBLE IN THE PAST.

NOTES TO UDNERSTAND THE ABOVE: 
	- IN THE ARRAYS HOLDING STRONG TYPES, THE PARAMETER pSizeOfInternalBuffer OF THE new() FUNCTIONS, IF SET
			TO ZERO WOULD MEAN THAT THE CALLER WANTS THE VALUE TO BE THAT OF pDEFAULT_SIZE_OF_INTERNAL_BUFFER.
			IN THE ARRAYS HOLDING WEAK TYPES, IF pSizeOfInternalBuffer IS SET TO ZERO, IT MEANT THAT THE CALLER
			DID NOT WANT AN INTERNAL BUFFER AT ALL. THIS IS WHY THE pSizeOfInternalBuffer PARAMETER IS LOCATED
			DIFFERENTLY IN THE FUNCTION SIGNATURES WHEN COMPARING BETWEEN THE ARRAYS OF STRONG TYPES WITH THOSE
			OF WEAK TYPES.
	- BACK THEN THERE WAS A FUNCTION CALLED init() WHICH WITH TIME CHANGED TO THE construct() FUNCTION WHICH 
			EVENTUALLY CHANGED TO THE construct() FUNCTION AS DEFINED IN MY STANDARD.
	- I DO NOT KNOW WHEN, BUT AT SOME POINT THE INTERNAL BUFFER, IF EXISTANT, WOULD NO LONGER ALLOW A CAPACITY OF
			ZERO. THIS MIGHT HAVE BEEN BEFORE I INTRODUCED assert() IN THE init() SOLUTION AS
			MENTIONED ABOVE, SUGGESTING THAT EITHER MY assert() WAS WRONG, OR MY MEMORY IS WRONG OR INCOMPLETE
			ON HOW I SOLVED THE PERTAINING PROBLEM *1*

--------------------
--------7-----------
--------------------

AN ISSUE EXISTS WHEN AN ARRAY FUNCTION IS CALLED ON IT SELF, SUCH AS WHEN AN ARRAY IS ASKED TO APPEND
A PART OF IT SELF TO IT SELF. BEFORE THE ISSUE CAN BE RESOLVED ONE HAS TO BE ABLE TO RELIABLY DETECT
THAT THE PASSED IN ARRAY IS THE SAME ARRAY OF this. THIS WOULD INVOLVE POINTER COMPARISON. UNFORTUANELTY
THE FOLLOWING STATEMENT OF MINE,
		IF TWO POINTERS POINT TO THE SAME OBJECT THEY EVALUTE AS EQUAL WHEN COMPARED WITH THE EQUALITY
		OPERATOR, AND IF TWO POINTERS EVALUATE AS EQUAL WHEN COMPARED WITH THE EQUALITY OPERATOR THEY
		POINT TO THE SAME OBJECT.
DID NOT SEEM TO HOLD IN C NOR C++. THE CONCLUSION WAS THAT IT IS LIKELY TO HOLD, BUT NOT ON ALL HARDWARE
OR OPERATING SYSTEMS. I INTRODUCED A MACRO INTO MY CRX NAMESPACE THAT WOULD COMPARE TWO POINTERS
FOR EQUALITY GUARANTEEING THE ABOVE COMPARISON. IN SITUATIONS WHERE THE MACRO CAN NOT GUARANTEE THE ABOVE,
THE MACRO WOULD RETURN A DEFAULT TOKEN THAT IS PASSED TO IT FOR THE PURPOSE. GENERALLY, THE TOKEN WOULD BE
EITHER true OR false.

AT THE TIME I ALREADY HAD THE "COPY ASSIGNMENT" FUNCTION, copyAssignFrom2(). TAKING THIS FUNCTIONS AS
AN EXAMPLE, THIS FUNCTION WOULD BE UPDATED TO CHECK IF THE PASSED ARRAY IS THE SAME AS this, AND IF IT
IS A NEW ARRAY WOULD BE CREATED THAT IS A COPY OF THE PASSED IN ARRAY, AND THEN THAT ARRAY WOULD BE USED
TO MODIFY THE CURRENT ARRAY. TO CREATE THE NEW ARRAY, THE new() FUNCTION WOULD BE CALLED, FOLLOWED BY
A RECURSIVE CALL TO copyAssignFrom2() WHICH WOULD ALSO COMPARE THE ARRAY PASSED IN, AND THIS TIME IT WOULD
CERTAINLY NOT FIND IT TO EQUAL TO this, AND THEREFORE IT WOULD PROCEED TO DO ITS WORK NORMALLY.

HOWEVER, UNDER COMPILE TIME CONDITIONS, SUCH AS HARDWARE, THAT CAN NOT GUARANTEE THE STATEMENT ABOVE
ABOUT POINTER COMPARISON, THE CRX MACRO FOR COMPARING TWO ARRAYS WOULD RETURN THE DEFAULT TOKEN PASSED TO IT.
THE DEFAULT TOKEN WOULD ALWAYS BE true IN OUR EXAMPLE, BECAUSE THAT WOULD BE THE SAFE OPTION. IN THIS CASE
WHEN copyAssignFrom2() IS CALLED, IT COMPARES, THEN IT FINDS THE ARRAY TO BE THE SAME AS this, EVEN THOUGH
IT MIGHT NOT ACTUALLY BE, CREATE A NEW INSTANCE USING new() AND PROCEED TO COPY THE PASSED IN ARRAY TO IT
USING copyAssignFrom2() AGAIN WHICH GOES ON TO DO THE SAME BECAUSE THE POINTER COMPRISON ALWAYS RETURNS TRUE.

WITH THIS, THE MINOR DIFFERENCE BETWEEN AN ACTUAL "COPY CONSTRUCOTR" AND A "COPY ASSIGNMENT" FUNCTION BECOME
VISIBLE, AND THE "COPY CONSTRUCTOR" NO LONGER BECOME A REDUNDANCY. THIS WAS THE BIRTH OF THE PRIVATE new2(),
WHICH WAS REDUNDANT BEFORE. NOW copyAssignFrom2() WOULD CALL THE PRIVATE new2(), AND BEAUSE IT IS A COPY 
CONSTRUCTOR, IT KNOWS FOR CERTAIN THAT this CAN NOT POSSIBLY EQUAL ANY ARRAY PASSED TO IT, AND HENCE NO 
POITNER COMPARISON WOULD BE REQUIRED, AND THEREBY FIXING THE INFINITE RECURSION PROBLEM WHEN THE CRX MACRO 
THAT WAS MENTIONED EARLIER HAS TO RETURN THE DEFAULT.


--------------------
--------8-----------
--------------------
I LIKED TO USE MY String CLASS, WHICH IS AN INSTANTIATION OF THE ARRAY TEMPLATE FOR C FUNCTIONS THAT
ACCEPT A CHARACTER ARRAY TO WRITE TO. ARRAYS ALREADY ALLOW DIRECT ACCESS TO THE INTERNAL BUFFER
HOLDING THE ELEMENTS USING getElementsPointer(). HOWEVER THAT ACCESS ONLY ALLOWS EDITING OF THE
EXISTING ELEMENTS. IT DOES NOT ALLOW ADDING OR REMOVING ELEMENTS. OF COURSE SUCH A THING, IF ALLOWED
IS GENERALLY ILL DEFINED. THE CALLER AFTER EDITING WOULD BE EXPECTED TO CORRECTLY SET THE NEW SIZE,
FOR EXAMPLE. THIS HOWEVER CAN BE WELL DEFINED IF THE TYPE OF ELEMENT BELONGS TO THE TRIVIAL CATEGORY
OF TYPES AS DEFINED IN MY STANDARD. THIS BUFFER GIVEN TO THE CALLER IS A C ARRAY BY DEFINITION.

IF THE TYPE BELONGS TO THE TRIVIAL CATEGORY, THE ARRAY CLASS COULD PREFILL THE ENTIRE BUFFER AND
EVEN IF THE CALLER FORGETS TO SET, OR SETS THE WRONG, LENGTH LATER IT IS NOT AN ISSUE BECAUSE THE
TYPE HAS NO DESTRUCT FUNCTION. HOWEVER TO RECOGNIZE THAT THE TYPE BELONGS OT THE TRIVIAL
CATEGORY, THE ARRAY TEMPLATE WOULD HAVE TO ASK FOR THE CONSTRUCT FUNCTION WHICH IS ILL DEFINED.
HENCE, THE CALLER IS EXPECTED TO PASS A VALUE WHEN ASKING FOR THE C ARRAY. WITH THIS WE ARE NOT
BOUND TO THE TRIVIAL CATEGORY OF TYPES, AND CAN WORK WITH ANY TYPE THAT IS RAW MOVABLE AND 
RAW COPYABLE AND TRIVIALLY DESTRUCTABLE. ALTHOUGH CORRECT, THIS  APPROACH IS LIKELY SLOW BECAUSE THE
ARRAY WOULD HAVE TO FILL THE ENTIRE BUFFER WITH DATA USING MEMCPY. CONSIDER THE CASE WHERE THE TYPE 
IS INDEED TRIVIALLY CONSTRUCTABLE. THE IMPLEMENTATION WOULD CONTINUE RELYING ON MEMCPY,
AND CAN NOT TAKE ADVANTAGE OF THE SPEED OF CALLOC. REMEMBER PER MY STANDARD, IF TRIVIALLY 
CONSTRUCTABLE, CONSTRUCTION WOULD REQUIRE SETTING THE BYTES TO MACHINE ZERO. HENCE THE INTRODUCTION
OF UNSAFE VARIANTS OF THE FUNCTIONS TO GIVE THE C ARRAY FROM THE ARRAY.

WITH THE ABOVE, FOUR FUNCTIONS WERE INTROCUED INTO THE ARRAY TEMPLATE,
getCArray()
unsafeGetCArray()
updateLength()
unsafeUpdateLength()

WITH THE UNSAFE VERSIONS, THE ARRAY DOES NOT PREINTIALIZES THE ENTIRE INTERNAL BUFFER, AND SIMPLY
TRUSTS THE CALLER TO DO WHAT IS RIGHT. WITH THIS, FOR TYPES SUCH AS THE STRING WHICH IS TRIVIALLY
CONSTRUCTABLE, THE IMPLEMENTATION CAN ATLEAST AVOID THE EXTRA COST OF INITIALIZATION. HOWEVER, THIS
DOES NOT MAKE THIS WELL DEFINED, BUT DOES MAKE IT CLEAR THAT IT IS NOT.

NOTE THAT THIS MECHANISM WAS NOT ADDED TO THE GENERIC ARRAY IMPLEMENTATION BECAUSE IT WOULD AFFECT
THE REQUIREMENT ALIGNMENT OF THE gPrivate_buffer DATA MEMBER RELATIVE TO THE STRUCTURE. HOWEVER, 
TO KEEP GOOD ALIGNMENT PROPOERTIES IN THE TEMPLATE IMPLEMENTATION, PADDING WAS ADDED TO ENSURE AN 
ALIGNMENT OF ELEMENTS THAT IS ATLEAST THE ALIGNMENT OF pSIZE_T.
*/
/*
NOTES:
	- private_unsafeCallElementsDestruct() HAS AN AMBIGUOUS CASE BECAUSE INDICES CAN NOT BE NEGATIVE. HENCE
			IF THE START INDEX IS THE SAME AS THE END, WE CAN NOT TELL WHETHER 1 ELEMENT IS TO BE DELETED
			OR 0 ELEMENTS. THIS IS BECAUSE THE CALLER CAN NOT PASS AN END INDEX SMALLER THAN THE START INDEX
			WHICH COULD BE 0 ITSELF. USING AN EXCLUSIVE END INDEX, NOT INCLUSIVE, WOULD STILL NOT FIX THIS.
			INSTEAD LENGTH WOULD BE REQUIRED. 
			HOWEVER, THIS IS NOT FIXED TO AVOID UNECESSARY CALLS TO private_unsafeCallElementsDestruct(). AT THE SAME
			TIME, AN ASSERT COULD NOT BE private_unsafeCallElementsDestruct() TO CORRECTLY DETECT THE SITUATION,
			HENCE THIS WARNING.
	- gPrivate_capacity ALWAYS, AND MUST ALWAYS, HOLDS THE CAPACITY OF THE ARRAY, EVEN WHEN THE INTERNAL BUFFER IS USED.
			HOWEVER, FOR PERFORMANCE THE CODE MIGHT TRY TO RELY "pDEFAULT_SIZE_OF_INTERNAL_BUFFER" INSTEAD WHEN
			READING THE CAPACITY.
	- IN SITUATIONS WHERE WE HAVE RAW COPY AND PECULIAR MOVE, RAW COPY IS FAVORED LEADING TO AN OPTIMIZATION.
			THIS IS FOUND IN THE SECOND FUNCTION OF A FUNCTION PAIR LIKE "set" FROM "moveAndSet" AND "set".
*/
/* TO DO:
	- USE ALRGOTITHM
					//if size_t is 64bit
					size_t getUpperNearestPowerOfTwoFor(size_t pNumber)
					{
						pNumber--;
						pNumber |= pNumber >> 1;
						pNumber |= pNumber >> 2;
						pNumber |= pNumber >> 4;
						pNumber |= pNumber >> 8;
						pNumber |= pNumber >> 16;
						pNumber |= pNumber >> 32;
						pNumber++;
						
						return pNumber;
					}
					//if size_t is 32bit
					size_t getUpperNearestPowerOfTwoFor(size_t pNumber)
					{
						pNumber--;
						pNumber |= pNumber >> 1;
						pNumber |= pNumber >> 2;
						pNumber |= pNumber >> 4;
						pNumber |= pNumber >> 8;
						pNumber |= pNumber >> 16;
						pNumber++;

						return pNumber;
					}
			THE SHIFTS ARE FORCING ALL THE BITS AFTER THE HIGHEST BIT WITH THE VALUE 1, TO BE 1. THE
			SUBTRACTION HELPS WHEN THE SITUATION IS ONE BIT WITH VALUE 1 FOLLOWED BY ZEROS.
	- COMPILER TIME CHECK FOR pDEFAULT_SIZE_OF_INTERNAL_BUFFER IS ZERO OR A POWER OF 2 FOR 
			pDEFAULT_SIZE_OF_INTERNAL_BUFFER USING
					//IF C++
					BOOST_STATIC_ASSERT((pDEFAULT_SIZE_OF_INTERNAL_BUFFER == 0) || 
							((pDEFAULT_SIZE_OF_INTERNAL_BUFFER & (pDEFAULT_SIZE_OF_INTERNAL_BUFFER - 1)) == 0))
					//IF C OR C++
					 typedef char _ASSERT ## pARRAY_TYPE_NAME ##_INVALID_DEFAULT_SIZE_OF_INTERNAL_BUFFER[
							2 * !!((pDEFAULT_SIZE_OF_INTERNAL_BUFFER == 0) || 
							((pDEFAULT_SIZE_OF_INTERNAL_BUFFER & (pDEFAULT_SIZE_OF_INTERNAL_BUFFER - 1)) == 0)) - 1];

			NOTE THAT IF ONLY CHECKING FOR POWER OF TWO, THEN THE CONDITION IS
					(pDEFAULT_SIZE_OF_INTERNAL_BUFFER != 0) &&
							((pDEFAULT_SIZE_OF_INTERNAL_BUFFER & (pDEFAULT_SIZE_OF_INTERNAL_BUFFER - 1)) == 0)
		- (UPDATE): DONE. RELIED ON THE FORM THAT DOES NOT NEED TO CHECK FOR C OR C++.
							
	- ALIGN MEMORY ON THE STACK WHEN USING BYTE ARRAYS. SAMPLE CODE:
					const int align = 32;
					void *p =_alloca(n + align - 1);
					__m256d *pm = (__m256d *)((((int_ptr_t)p + align - 1) / align) * align);
		- (UPDATE): WE WILL RELY ON THE ALIGNMENT OF CRX__ALLOCA FOR NOW, WHICH SEEMS TO BE 8 BYTES,
				OR 16 BYTES ON NEWER COMPILERS. THE ONLY PROBLEM IS IF WE NEED A HIGHER ALIGNMENT, WHICH
				IS UNLIKELY, AND THE LIKELY WASTED EXTRA SPACE WHEN WE ARE GETTING OVER ALIGNMENT. IN
				THE FUTURE WE MIGHT SWITCH TO A UNION STRUCTURE INSTEAD OF THE FORM
						union
						{
							unsigned char gChars[sizeof(Type)];
							Type gType;
						}
				THIS SHOULD BOTH AVOID THE DEFAULT CONSTRUCTOR OF TYPE, AND ENSURE gChars, OUR BUFFER,
				IS ALIGNED AND WITHOUT WASTING SPACE.
		- (UPDATE): Crx_C_Ring::gPrivate_buffer IS ALIGNED MANUALLY, RELATIVE TO Crx_C_Ring, SUCH AS WE GET THE LARGEST
				ALIGNMENT POSSIBLE UNDER THE CIRCUMSTANCE. IF AN INSTANCE OF Crx_C_Ring IS CREATED ON THE HEAP,
				THIS CAN ALLOW US UP TO 16 BYTES ALIGNMENT, BUT IF ON THE STACK, THE BEST WE CAN HOPE FOR
				CURRENTLY IS 8 BYTE ALIGNMENTS, UNLESS THE USER USES SOMETHING LIKE __alloca().
	- FIX USAGE OF "unsigned char *". THIS USAGE WILL BREAK STRICT ALIASING RULES. PERHAPS USE "void *"
		- (UPDATE): THIS IS UNLIKELY TO CAUSE PROBLEMS IN OUR CASE, EVEN THOUGH WE ARE CASTING
				"unsigned char *" TO A TYPE, WITHOUT FIRST CASTING A TYPE TO "unsigned char *".
				THIS IS BECAUSE THE BUFFER POINTED TO BY OUR "unsigned char *" IS EMPTY. REMEMBER
				THAT "unsigned char *" IS USED FOR THE CASES WHERE WE ARE ALLOCATING MEMORY ON
				THE STACK TO AVOID THE C++ COMPILER CALLING THE DEFAULT CONSTRUCTOR OF A TYPE.
				ALSO USING "void *" INSTEAD WOULD NOT HELP BECAUSE IT CAN NOT BE INVOLVED IN STRICT
				ALIASING BECAUSE IT CAN NOT BE USED WITHOUT CASTING FIRST.
	- FIND A BETTER DEFINITION OF get(). THIS FUNCTION RETURNS A POINTER TO CONSTANT IF COPY ON WRITE IS ENABLED,
			AND JUST A POINTER WHEN NOT. IDEALLY, IT SHOULD RETURN THE SAME THING EITHER WAY, AND IDEALLY IT SHOULD
			BE NOT CONSTANT.
*/
/* DESIGN NOTES:
	- THE DESIGN IS SUCH AS CODE WORKS UNDER C AND C++ THE SAME WAY WITHOUT NEEDED TO CHECK WITHOUT WE
			ARE USING USING C OR C++ AT COMPILE TIME.
	- THE THREE CONSTRUCT FUNCTIONS THAT A CALLER MAY PASS ARE EXPECTED TO OBEY MY STANDARD FOR CONSTRUCTORS.
			THIS MEANS THAT THEY MAY NOT THROW EXCEPTIONS.
	- construct(): THIS FUNCTION ALLOWS THE USER TO CREATE AN INSTANCE OF THE ARRAY ON HIS STACK. THE USER IS
			EXPECTED TO CREATE THE MEMORY BLOCK. THIS FUNCTION WILL SET ALL DATA MEMBERS.
			WHEN THE USER CREATES AN ARRAY ON THE STACK, HE IS EXPECTED TO OBEY THE 
			pDEFAULT_SIZE_OF_INTERNAL_BUFFER PARAMETER. THE CODE CONTAINS AN assert() TO ENSURE THAT.
	- moveConstruct(): CONCEPTUALLY THIS ALLOWS THE SAME INSTANCE TO BE RECREATED ELSEWHERE FOR THE SAKE
			OF MOVING IT. IF OUR OWN ARRAY WAS TO BE AN ELEMENT TO A TEMPLATE INSTATIONATION OF OUR OWN ARRAY,
			THEN THIS FUNCTION WOULD BE THE MOVE CONSTRUCTOR.
			IF THIS IS USED TO CONSTRUCT AN INSTANCE ON THE STACK, THE USER IS EXPECTED TO ENSURE THAT THE SPACE
			AVAILABLE IS EQUAL TO THE SIZE OF THE ORIGINAL ARRAY. THIS IS IMPORTANT TO REMEMBER WHEN THE ARRAY
			HAS A DYNAMICALLY SIZED BUFFER, IN WHICH CASE THE USE OF sizeof WOULD NOT BE SUFFICIENT.
	- new(): THIS FUNCTION ALLOWS THE USER TO CREATE AN INSTANCE OF THE ARRAY ON THE HEAP. IF THE SIZE OF
			THE INTERNAL BUFFER IS DYNAMIC, THE VALUE PASSED, pSizeOfInternalBuffer, MUST BE EITHER
			ZERO INDICATING THE THE VALUE OF pDEFAULT_SIZE_OF_INTERNAL_BUFFER BE USED, OR BE A POWER OF TWO.

			THIS FUNCTION IS REPONSIBLE FOR SETTING POINTERS TO NULL AT LEAST, FOR POINTERS DEFAULT NOT SET BY 
			construct(). THIS IS ONLY RELEVANT FOR THE WEAKLY TYPED ARRAYS WHERE OTHER POINTERS EXIST BESIDE
			THE MAIN POINTER, gPrivate_elements (OR gPrivate_externalBuffer FOR THE STRONG TYPED ARRAYS).
	- IT IS ASSUMED THAT THE SIZE OF THE EXTERNAL BUFFER IS ALWAYS LARGER THAN THE INTERNAL BUFFER.
	- get(): THIS FUNCTION RETURNS A POINTER. HENCE THE ELEMENT RETURNED MUST NEVER BE DELETED. IF USING
			COPY ON RIGHT, THE ELEMENT MUST ALSO NOT BE MODIFIED AND THE FUNCTION RETURN POINTER TO CONSTANT.
	- unsafeDetachExternalBuffer(): THIS FUNCTION IS UNSAFE BECAUSE IT DOES NOT SET ANY OF THE OTHER FIELDS
			OF THE ARRAY.
	- destruct(): NO FUNCTION EXISTS TO DESTRUCT AND FREE THE SPACE. IF WE ASSUME A SINGLE ALLOCATOR EXISTS,
			THE PREVIOUS SENTENCE IS BECAUSE THE OBJECT MIGHT BE ON THE STACK.
			IF WE ASSUME MORE THAN A SINGLE ALLOCATOR COULD EXIST, THE SAID SENTENCE IS BECAUSE
			NOW IT WOULD BECOME AN AMBIGUOUS SITUATION FOR MOVE FUNCTIONS.
	- free(): CALLS THE LOW LEVEL FREE FUNCTION. THIS FUNCTION EXISTS TO AVOID THE ASSUMPTION THAT THERE IS 
			A SINGLE ALLOCATOR IN THE ENTIRE PROGRAM.
	- THE FUNCTIONS PRIVATE FUNCTIONS insertSpaceAt(), fastInsertSpaceAt() AND roundInsertSpaceAt(), PLAY
			AN IMPORTANT ROLE IN ENSURING THAT THE DATA MEMEBER, gPrivate_externalBuffer IS NOT ACCESSED WHEN IT IS
			NULL. THIS HAPPENS INDIRECTLY THROUGH THE DATA MEMEBER, gPrivate_capacity.
			ON THE SAME SUBJECT, NOTE THAT gPrivate_capacity MAY NEVER BE ZERO IF THE INTERNAL BUFFER IS ENABLED, HENCE
			WHY THE SIZE OF THE INTERNAL BUFFER IS NEVER ALLOWED TO BE ZERO.

			NOTE THAT IN THE PAST gPrivate_capacity WAS NEVER ALLOWED TO BE ZERO. THIS LATER CHANGED AFTER I REVIEWED
			THE CODE TO EXPLICITLY ALLOW FOR ZERO WHEN THE INTERNAL BUFFER IS NOT USED. HOWEVER, IN THIS SCENARIO
			WHEN gPrivate_capacity IS ZERO, gPrivate_externalBuffer MUST BE NULL.
			
			IT SHOULD BE NOTED THAT IF gPrivate_capacity IS ZERO, gPrivate_length MUST BE ZERO. gPrivate_length ALSO PLAYS A ROLE
			IN ENSURING THAT gPrivate_externalBuffer IS NOT ACCESSED WHEN IT IS NULL.
			
			private_unsafeCallElementsDestruct() BY DESIGN DOES NOT ENSURE THAT gPrivate_externalBuffer IS NOT NULL. CODE
			CALLING THAT FUNCTION MUST MAKE SURE OF THAT BEFORE CALLING.
	- RELATED TO THE NOTE ABOVE, gPrivate_externalBuffer VALUE IS USED TO DETECT WHETHER THE INTERNAL BUFFER IS 
			USED OR NOT AT RUNTIME WHEN THE ARRAY HAS AN INTERNAL BUFFER. IF NULL, THEN THE INTERNAL BUFFER IS USED.
			HOWEVER WHEN THE ARRAY DOES NOT HAVE AN INTERNAL BUFFER, IF gPrivate_externalBuffer IS NULL IT 
			INDICATES A ZERO CAPACITY, AND INDEED gPrivate_capacity MUST BE ZERO. BE VERY CAREFUL WITH THIS IN THE
			ARRAYS HOLDING WEAK TYPES.
	- BE VERY CAREFUL WITH THE WEAK TYPED ARRAYS. CODE OF THE STRONGLY TYPED ARRAYS, WHERE CHECKS ARE
			MADE ON pHAS_INTERNAL_BUFFER, AND CODE IS PRODUCED FOR BOTH TRUE AND FALSE, LOOKS
			THE SAME AS THE CODE IN THE WEAKLY TYPE ARRAY CODE. HOWEVER, WHEN CODE IS ONLY PRODUCED FOR ONE OF 
			THE CASES, THE CODE WOULD NO LONGER LOOK THE SAME. THIS IS BECAUSE IN THE WEAKLY TYPED CASE THERE IS NO
			EQUIVILANT OF pDEFAULT_SIZE_OF_INTERNAL_BUFFER NOR pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD,
			EVEN THOUGH WHAT THAT CODE PROVIDES APPEAR VERY SIMILAR. 
			AN EXAMPLE OF THIS, IS THE GUARD BLOCK AT THE BEGGINING OF getElementsPointer() WHICH ONLY ACTIVATES
			IF pHAS_INTERNAL_BUFFER IS FALSE. THIS MIGHT MAKE IT APPEAR THAT THE BLOCK IS NOT NEEDED AT ALL ON 
			THE WEAK TYPE, BUT THIS IS NOT TRUE.
	- SOME FUNCTIONS HAVE THREE OPERATIONS:
		- NORMAL OPERATIONS: EXAMPLE, THE tryMoveAndPush FUNCTION. THESE FUNCTIONS WOULD GROW THE ARRAY WHEN NEEDED,
				AND THEREFORE CAN FAIL. THESE FUNCTIONS DO NOT EXIST ON THE FIXED SIZE ARRAYS.
		- FAST OPERATIONS: EXAMPLE, THE moveAndFastPush FUNCTION. THESE FUNCTIONS HAVE THE ADVERB 'FAST'.
				THESE FUNCTIONS CAN NOT FAIL, BUT RELY ON THE USER DISCPLINE FOR THAT. DURING DEBUG, ASSERT()
				CALLS ALLOW CATCHING ERRORS. THESE FUNCTIONS WOULD NOT GROW THE ARRAY EVEN IF NEEDED AND THEY CAN.
				THESE ALSO DO NOT CHECK IF THEY ARE OPERATING ON THE SAME ARRAY, AND THEREFORE WILL NOT MAKE
				A TEMPORARY COPY OF IT BEFORE DOING THEIR WORK.
				BECAUSE THESE FUNCTIONS CAN NOT FAIL, THEY HAVE ASSERT STATEMENTS TO ENSURE THAT THEY
				ARE NOT USED IF COPY ON WRITE IS ENABLED, AND THE BUFFER IS SHARED, AND HAVE ASSERT STATEMENTS
				TO ENSURE THAT THEY ARE NOT PASSED AN ARRAY THAT IS EQUAL TO this.
		- ROUND OPERATIONS: EXAMPLE, THE moveAndRoundPush FUNCTION. THESE FUNCTIONS HAVE THE ADVERB 'ROUND'.
				THESE FUNCTIONS CAN NOT FAIL, AND ONLY EXIST ON RINGS. THEY WILL ESSENTIALLY ALLOW THE RING
				TO EAT ITSELF INSTEAD OF GROWING WHEN CAPACITY IS EXCEEDED. THESE FUNCTIONS ALSO RELY ON 
				USER DISCIPLINE FOR NOT FAILING. FOR EXAMPLE, THE CAPACITY MUST BE LARGER THAN ZERO. DURING
				DEBUG, ASSERT() CALLS ALLOW CATCHING ERRORS. THESE ALSO DO NOT CHECK IF THEY ARE OPERATING
				ON THE SAME ARRAY, AND THEREFORE WILL NOT MAKE A TEMPORARY COPY OF IT BEFORE DOING THEIR WORK.
				BECAUSE THESE FUNCTIONS CAN NOT FAIL, THEY HAVE ASSERT STATEMENTS TO ENSURE THAT THEY
				ARE NOT USED IF COPY ON WRITE IS ENABLED, AND THE BUFFER IS SHARED, AND HAVE ASSERT STATEMENTS
				TO ENSURE THAT THEY ARE NOT PASSED AN ARRAY THAT IS EQUAL TO this.
	- initStackInstance() IS ONLY FOUND ON THE WEAKLY TYPED ARRAYS, AND IT WAS DESIGNED TO ALLOW CLIENT
			CODE TO WRAP AN EXISTING BUFFER WITH THE FUNCTIONALITY PROVIDED BY MY ARRAYS. THE USER WOULD
			PASS A POINTER TO AN EXISTING BUFFER BY THE PARAMETER pBufferOnStack IF THEY WANTED.
			(REMOVED)
	- A NUMBER OF FUNCTION HAVE A '2' VERSION. THESE FUNCTIONS ARE THERE TO SUPPORT LITERALS.
	- FUNCTIONS CALLED unsafe SOMETHING ARE UNSAFE BECAUSE THEY DO NOT UPDATE THE ARRAY FULLY
			AFTER THEIR OPERATION. FOR EXAMPLE, THEY MIGHT NOT UPDATE gPrivate_capacity EVEN THOUGH
			THEY CHANGED THE CAPACITY. ANOTHER REASON THEY MIGHT BE UNSAFE IS BECAUSE CODE NEEDS
			TO CHECK CERTAIN CONDITIONS AT RUNTIME BEFORE CALLING THESE, WHICH THESE FUNCTIONS DO NOT
			CHECK THEMSELVES. UNSAFE FUNCTIONS ARE ALL PRIVATE.
	- COPY ON RIGHT:
		- COPY ON RIGHT IS NOT IMPLEMENTED FOR THE ARRAYS WITH WEAK TYPE ELEMENTS.
		- IN THE TWO FUNCTIONS, copyAssignFrom2(), AND insertElementsAt() THE CODE DOES NOT MEET
				FORMAT OF THE REST OF THE CODE. CHECKS THAT ARE SUPPOSED TO BE COMPILE
				TIME ARE INSTEAD PARTIALLY DONE AT RUNTIME. FURTHERMORE THE CODE DOES NOT
				MEET THE FORMAT USED HERE THAT IS RELATED TO THE INTERLEAVED CONTEXT.
		- ARRAY, AS OPPOSED TO A RING, IS UNABLE TO HOLD A VIEW OF THE BUFFER WHEN THE VIEW
				DOES START AT INDEX 0, BECAUSE OTHERWISE I WOULD HAVE TO ADD A NEW DATA MEMBER FOR HOLDING 
				THE START INDEX.
	- tryToPilferSwapContentWith(), pilferSwapContentWith():
		- THESE FUNCTIONS ARE TO HELP IN 'MOVE' OPERATIONS AS SEEN IN C++, NOT TO BE CONFUSED BY WHAT I
				CALL MOVE IN MY STANDARD.
		- THESE FUNCTIONS ARE NOT ENABLED IF THE SIZE OF THE INTERNAL BUFFER FIELD IS ENABLED. THIS
				IS BECAUSE OF THE DESIRE TO KEEP gSIZE_OF_INTERNAL_BUFFER CONSTANT.
				FOR THE SAME REASON, THESE FUNCTIONS ARE NOT ENABLED IN THE WEAK TYPE ELEMENTS
				CASE.
		- EITHER ONE OF THE FUNCTIONS IS ENABLED, BUT NOT BOTH. tryToPilferSwapContentWith()
				IS FOR CASES WHERE OPERATION IS NOT ALWAYS POSSIBLE. CLIENT CODE IS EXPECTED
				TO CHECK IF THE FUNCTION RETURNS true, AND IF NOT TO COPY THE INPUT ARRAY
				INSTEAD.
*/
/*
WARNING: 
	- ALL SIZES MUST BE 
				0 
		or 
				2^N (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, ...)
	- IF pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD IS TRUE, pDEFAULT_SIZE_OF_INTERNAL_BUFFER CAN NOT
			BE 0
			
*/
/*
KNOWN ISSUES IN COMPILING IN OLDER ENVIRONMENTS, INCLUDING VISUAL STUDIO 6 WHICH USES C89
	- FOR LOOPS CAN NOT DEFINE A PARAMETER WITHIN THEIR HEAD.
	- VARIABLES MUST BE DECLARED AT THE BEGGINING OF EACH SCOPE. THIS MEANS THAT META BLOCKS AND GUARD BLOCKS,
			AS DEFINED IN MY STANDARD, ARE NOT ALLOWED.
*/

typedef struct Crx_C_Ring_Private_IndexTransform
{
	size_t gNewIndex;
	size_t gNewCountToEnd;
} Crx_C_Ring_Private_IndexTransform;

#if(!CRX_ARE_VARIADIC_MACROS_EMULATED)
	#define CRX__C__Ring__DECLARE(...) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__Ring__DECLARE, __VA_ARGS__)
#else
	#define CRX__C__Ring__DECLARE(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__Ring__DECLARE, p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
#endif

#define CRX__C__Ring__DECLARE__12(pARRAY_TYPE_NAME, pARRAY_MEMBER_FUNCTIONS_PREFIX, pELEMENT_TYPE, \
		pSIZE_T, pSIZE_T_MAX, pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
		pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__Ring__DECLARE(pARRAY_TYPE_NAME, pARRAY_MEMBER_FUNCTIONS_PREFIX, pELEMENT_TYPE, \
		pSIZE_T, pSIZE_T_MAX, pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
		pFUNC_ELEMENT_DESTRUCTOR, CRXM__FALSE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, CRXM__FALSE, \
\
		CRXM__OR(pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
		CRX__C__Ring__ECHO_SIZE_OF_INTERNAL_BUFFER(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, pThis, \
				pDEFAULT_SIZE_OF_INTERNAL_BUFFER), \
		CRXM__OR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, pSTART_INDEX_DEFAULT_ALIGN_FACTOR), \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
#define CRX__C__Ring__DECLARE__14(pARRAY_TYPE_NAME, pARRAY_MEMBER_FUNCTIONS_PREFIX, pELEMENT_TYPE, \
		pSIZE_T, pSIZE_T_MAX, pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
		pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, pIS_TO_ENABLE_COPY_ON_RIGHT) \
_CRX__C__Ring__DECLARE(pARRAY_TYPE_NAME, pARRAY_MEMBER_FUNCTIONS_PREFIX, pELEMENT_TYPE, \
		pSIZE_T, pSIZE_T_MAX, pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
		pFUNC_ELEMENT_DESTRUCTOR, CRXM__TRUE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, pIS_TO_ENABLE_COPY_ON_RIGHT, \
\
		CRXM__OR(pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
		CRX__C__Ring__ECHO_SIZE_OF_INTERNAL_BUFFER(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, pThis, \
				pDEFAULT_SIZE_OF_INTERNAL_BUFFER), \
		CRXM__OR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, pSTART_INDEX_DEFAULT_ALIGN_FACTOR), \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION()) \


#define _CRX__C__Ring__DECLARE(pARRAY_TYPE_NAME, pARRAY_MEMBER_FUNCTIONS_PREFIX, pELEMENT_TYPE, \
		pSIZE_T, pSIZE_T_MAX, pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
		pFUNC_ELEMENT_DESTRUCTOR, pIS_COPYABLE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, pIS_TO_ENABLE_COPY_ON_RIGHT, \
		pHAS_INTERNAL_BUFFER, pTHIS_SIZE_OF_INTERNAL_BUFFER, pHAS_ALIGN_FACTOR, PUBLIC, PRIVATE) \
	typedef struct pARRAY_TYPE_NAME ## _ExternalBuffer \
	{ \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
				size_t gCount;, ) \
		pELEMENT_TYPE gPrivate_buffer[1]; \
	} pARRAY_TYPE_NAME ## _ExternalBuffer; \
	typedef struct pARRAY_TYPE_NAME \
	{ \
		pARRAY_TYPE_NAME ## _ExternalBuffer * gPrivate_externalBuffer; \
		pSIZE_T gPrivate_startIndex; \
		pSIZE_T gPrivate_length; \
		pSIZE_T gPrivate_capacity; \
		CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
				pSIZE_T gSIZE_OF_INTERNAL_BUFFER;, )\
		CRXM__IFELSE2(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
				signed char gPrivate_startIndexAlignFactor;, )\
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
				bool gPrivate_isThreadPossible;, ) \
		CRXM__IFELSE2(pHAS_INTERNAL_BUFFER, \
				pELEMENT_TYPE gPrivate_buffer[CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, 1, pDEFAULT_SIZE_OF_INTERNAL_BUFFER)];, )\
	} pARRAY_TYPE_NAME; \
	\
	typedef char pARRAY_TYPE_NAME ##__ERROR__INVALID_DEFAULT_SIZE_OF_INTERNAL_BUFFER[2 * !!( \
			(pDEFAULT_SIZE_OF_INTERNAL_BUFFER == 0) || \
			((pDEFAULT_SIZE_OF_INTERNAL_BUFFER & (pDEFAULT_SIZE_OF_INTERNAL_BUFFER - 1)) == 0)) - 1]; \
	\
	\
	PUBLIC size_t pARRAY_MEMBER_FUNCTIONS_PREFIX ## getCorrectCapacityBoundFor(size_t pCapacity); \
	CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
	PUBLIC size_t pARRAY_MEMBER_FUNCTIONS_PREFIX ## getByteSizeOf( \
			pARRAY_TYPE_NAME const * CRX_NOT_NULL pArray), ); \
	CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
	PUBLIC size_t pARRAY_MEMBER_FUNCTIONS_PREFIX ## getByteSizeFor(size_t pSizeOfInternalBuffer);, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD),  \
			CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(pARRAY_TYPE_NAME * pThis, \
			size_t pCapacity), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(pARRAY_TYPE_NAME * pThis, \
			size_t pCapacity, size_t pSizeOfInternalBuffer)), \
			CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(pARRAY_TYPE_NAME * pThis, \
			size_t pCapacity, size_t pSizeOfInternalBuffer, signed char pStartIndexAlignFactor), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(pARRAY_TYPE_NAME * pThis, \
			size_t pCapacity, signed char pStartIndexAlignFactor))); \
	CRXM__IFELSE2(CRXM__AND(pHAS_INTERNAL_BUFFER, \
			CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveConstruct(pARRAY_TYPE_NAME * pThis, \
			pARRAY_TYPE_NAME * CRX_NOT_NULL pArray), ); \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyConstruct(pARRAY_TYPE_NAME * pThis, \
			pARRAY_TYPE_NAME const * CRX_NOT_NULL pArray); \
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD),  \
			CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_construct(pARRAY_TYPE_NAME * pThis, \
			size_t pCapacity), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_construct(pARRAY_TYPE_NAME * pThis, \
			size_t pSizeOfInternalBuffer, size_t pCapacity)), \
			CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_construct(pARRAY_TYPE_NAME * pThis, \
			size_t pSizeOfInternalBuffer, size_t pCapacity, signed char pStartIndexAlignFactor), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_construct(pARRAY_TYPE_NAME * pThis, \
			size_t pCapacity, signed char pStartIndexAlignFactor))), ); \
	CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD),  \
			CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(size_t pCapacity CRX_DEFAULT(0)), \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(size_t pCapacity CRX_DEFAULT(0), \
			size_t pSizeOfInternalBuffer)), \
			CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(size_t pCapacity CRX_DEFAULT(0), \
			size_t pSizeOfInternalBuffer CRX_DEFAULT(0), \
			signed char pStartIndexAlignFactor CRX_DEFAULT(0)), \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(size_t pCapacity CRX_DEFAULT(0), \
			signed char pStartIndexAlignFactor CRX_DEFAULT(0)))); \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveNew( \
			pARRAY_TYPE_NAME * CRX_NOT_NULL pArray); \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyNew( \
			pARRAY_TYPE_NAME const * CRX_NOT_NULL pArray); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_new2( \
			pARRAY_TYPE_NAME const * CRX_NOT_NULL pArray, size_t pStartIndex, size_t pWidth), ); \
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD),  \
			CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_new( \
			size_t pCapacity CRX_DEFAULT(0)), \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_new( \
			size_t pCapacity CRX_DEFAULT(0), size_t pSizeOfInternalBuffer)), \
			CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_new( \
			size_t pCapacity CRX_DEFAULT(0), size_t pSizeOfInternalBuffer CRX_DEFAULT(0), \
			signed char pStartIndexAlignFactor CRX_DEFAULT(0)), \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_new( \
			size_t pCapacity CRX_DEFAULT(0), signed char pStartIndexAlignFactor CRX_DEFAULT(0)))), ); \
	CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
	PRIVATE void pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct( \
			pARRAY_TYPE_NAME * pThis, size_t pStartIndex, size_t pEndIndex), ); \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## destruct(pARRAY_TYPE_NAME * pThis); \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## free(pARRAY_TYPE_NAME * pThis); \
	\
	CRX__C__TYPE_BLUE_PRINT__DECLARE_GET_BLUE_PRINT( \
			pARRAY_TYPE_NAME, pARRAY_MEMBER_FUNCTIONS_PREFIX, \
			CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), CRXM__TRUE, \
			pIS_COPYABLE, CRXM__TRUE, \
			CRXM__AND(pHAS_INTERNAL_BUFFER, CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, \
					pFUNC_ELEMENT_MOVE_DESTRUCTOR)), CRXM__FALSE); \
	\
	PUBLIC pSIZE_T pARRAY_MEMBER_FUNCTIONS_PREFIX ## getLength(pARRAY_TYPE_NAME const * pThis); \
	PUBLIC pSIZE_T pARRAY_MEMBER_FUNCTIONS_PREFIX ## getCapacity(pARRAY_TYPE_NAME const * pThis); \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## isThreadPossible(pARRAY_TYPE_NAME * pThis); \
	PRIVATE void pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_moveElements( \
			pELEMENT_TYPE * CRX_NOT_NULL pSourceBuffer, size_t pStartIndex, size_t pLength, \
			size_t pCapacity, pELEMENT_TYPE * CRX_NOT_NULL pTargetBuffer); \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## ensureCapacity(pARRAY_TYPE_NAME * pThis, \
			size_t pCapacity); \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## emptyAndEnsureCapacity(pARRAY_TYPE_NAME * pThis, \
			size_t pCapacity); \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## empty(pARRAY_TYPE_NAME * pThis); \
	PRIVATE bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_insertSpaceAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, size_t pWidth); \
	PRIVATE void pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_fastInsertSpaceAt( \
			pARRAY_TYPE_NAME * pThis, size_t pIndex, size_t pWidth); \
	PRIVATE Crx_C_Ring_Private_IndexTransform pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_roundInsertSpaceAt( \
			pARRAY_TYPE_NAME * pThis, size_t pIndex, size_t pWidth); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyAssignFrom2(pARRAY_TYPE_NAME * pThis, \
			pARRAY_TYPE_NAME const * CRX_NOT_NULL pArray, size_t pStartIndex, size_t pWidth), ); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyAssignFrom(pARRAY_TYPE_NAME * pThis, \
			pARRAY_TYPE_NAME const * CRX_NOT_NULL pArray), ); \
	CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
			CRXM__OR(pHAS_INTERNAL_BUFFER, pIS_TO_ENABLE_COPY_ON_RIGHT)), \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryToPilferSwapContentWith( \
			pARRAY_TYPE_NAME * pThis, pARRAY_TYPE_NAME * CRX_NOT_NULL pArray), ); \
	CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pHAS_INTERNAL_BUFFER), CRXM__NOT(pIS_TO_ENABLE_COPY_ON_RIGHT)), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## pilferSwapContentWith(pARRAY_TYPE_NAME * pThis, \
			pARRAY_TYPE_NAME * CRX_NOT_NULL pArray), ); \
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndSetAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE * CRX_NOT_NULL pElement), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndSetAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE * CRX_NOT_NULL pElement)); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## setAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * CRX_NOT_NULL pElement), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## setAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * CRX_NOT_NULL pElement)), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## setAt2(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE pElement), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## setAt2(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE pElement)), ); \
	CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_COPY_ON_RIGHT), \
	PUBLIC pELEMENT_TYPE * pARRAY_MEMBER_FUNCTIONS_PREFIX ## get(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex), \
	PRIVATE pELEMENT_TYPE * pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_get(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex)); \
	PUBLIC pELEMENT_TYPE const * pARRAY_MEMBER_FUNCTIONS_PREFIX ## constantGet( \
			pARRAY_TYPE_NAME const * pThis, size_t pIndex); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_DESTRUCTOR), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyGetTo(pARRAY_TYPE_NAME const * pThis, \
			pELEMENT_TYPE * CRX_NOT_NULL pReturn, size_t pIndex), \
	PUBLIC pELEMENT_TYPE pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyGet(pARRAY_TYPE_NAME const * pThis, \
			size_t pIndex)), ); \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPush(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## push(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE const * CRX_NOT_NULL pElement), ); \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPush(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastPush(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE const * CRX_NOT_NULL pElement), ); \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundPush(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundPush(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE const * CRX_NOT_NULL pElement), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## push2(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE pElement), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastPush2(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE pElement), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundPush2(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE pElement), ); \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## pop(pARRAY_TYPE_NAME * pThis); \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPushToFront(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## pushToFront(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE const * CRX_NOT_NULL pElement), ); \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPushToFront(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastPushToFront(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE const * CRX_NOT_NULL pElement), ); \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundPushToFront(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundPushToFront(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE const * CRX_NOT_NULL pElement), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## pushToFront2(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE pElement), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastPushToFront2(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE pElement), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundPushToFront2(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE pElement), ); \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## popFromFront(pARRAY_TYPE_NAME * pThis); \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndInsertElementAt( \
			pARRAY_TYPE_NAME * pThis, size_t pIndex, pELEMENT_TYPE * CRX_NOT_NULL pElement); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertElementAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE const * CRX_NOT_NULL pElement), ); \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastInsertElementAt( \
			pARRAY_TYPE_NAME * pThis, size_t pIndex, pELEMENT_TYPE * CRX_NOT_NULL pElement); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertElementAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE const * CRX_NOT_NULL pElement), ); \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundInsertElementAt( \
			pARRAY_TYPE_NAME * pThis, size_t pIndex, pELEMENT_TYPE * CRX_NOT_NULL pElement); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertElementAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE const * CRX_NOT_NULL pElement), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertElementAt2(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE pElement), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertElementAt2(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE pElement), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertElementAt2(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE pElement), ); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertElementsAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pARRAY_TYPE_NAME const * CRX_NOT_NULL pArray, size_t pStartIndex, \
			size_t pWidth), ); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertElementsAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pARRAY_TYPE_NAME const * CRX_NOT_NULL pArray, size_t pStartIndex, \
			size_t pWidth), ); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertElementsAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pARRAY_TYPE_NAME const * CRX_NOT_NULL pArray, size_t pStartIndex, \
			size_t pWidth), ); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertCArrayAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE const * CRX_NOT_NULL pArray, size_t pWidth), ); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertCArrayAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE const * CRX_NOT_NULL pArray, size_t pWidth), ); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertCArrayAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE const * CRX_NOT_NULL pArray, size_t pWidth), ); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertElementCopiesAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE const * CRX_NOT_NULL pElement, size_t pNumberOfCopies), ); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertElementCopiesAt( \
			pARRAY_TYPE_NAME * pThis, size_t pIndex, pELEMENT_TYPE const * CRX_NOT_NULL pElement, \
			size_t pNumberOfCopies), ); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertElementCopiesAt( \
			pARRAY_TYPE_NAME * pThis, size_t pIndex, pELEMENT_TYPE const * CRX_NOT_NULL pElement, \
			size_t pNumberOfCopies), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertElementCopiesAt2(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE pElement, size_t pNumberOfCopies), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertElementCopiesAt2( \
			pARRAY_TYPE_NAME * pThis, size_t pIndex, pELEMENT_TYPE pElement, size_t pNumberOfCopies), ); \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertElementCopiesAt2( \
			pARRAY_TYPE_NAME * pThis, size_t pIndex, pELEMENT_TYPE pElement, size_t pNumberOfCopies), ); \
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## removeElements(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, size_t pWidth), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## removeElements(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, size_t pWidth)); \
	PRIVATE pELEMENT_TYPE * pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_doGetElementsPointer( \
			pARRAY_TYPE_NAME * pThis); \
	CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_COPY_ON_RIGHT), \
	PUBLIC pELEMENT_TYPE * pARRAY_MEMBER_FUNCTIONS_PREFIX ## getElementsPointer( \
			pARRAY_TYPE_NAME * pThis), ); \
	PUBLIC pELEMENT_TYPE const * pARRAY_MEMBER_FUNCTIONS_PREFIX ## constantGetElementsPointer( \
			pARRAY_TYPE_NAME const * pThis);
//#END_DEFINE	
	



#if(!CRX_ARE_VARIADIC_MACROS_EMULATED)
	#define CRX__C__Ring__DEFINE(...) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__Ring__DEFINE, __VA_ARGS__)
#else
	#define CRX__C__Ring__DEFINE(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__Ring__DEFINE, p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20)
#endif

#define CRX__C__Ring__DEFINE__12(pARRAY_TYPE_NAME, pARRAY_MEMBER_FUNCTIONS_PREFIX, pELEMENT_TYPE, \
		pSIZE_T, pSIZE_T_MAX, pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
		pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__Ring__DEFINE(pARRAY_TYPE_NAME, pARRAY_MEMBER_FUNCTIONS_PREFIX, pELEMENT_TYPE, \
		pSIZE_T, pSIZE_T_MAX, pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
		pFUNC_ELEMENT_DESTRUCTOR, CRXM__FALSE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, CRXM__FALSE, \
\
		CRXM__OR(pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
		CRX__C__Ring__ECHO_SIZE_OF_INTERNAL_BUFFER(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, pThis, \
				pDEFAULT_SIZE_OF_INTERNAL_BUFFER), \
		CRXM__OR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, pSTART_INDEX_DEFAULT_ALIGN_FACTOR), \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
#define CRX__C__Ring__DEFINE__14(pARRAY_TYPE_NAME, pARRAY_MEMBER_FUNCTIONS_PREFIX, pELEMENT_TYPE, \
		pSIZE_T, pSIZE_T_MAX, pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
		pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, pIS_TO_ENABLE_COPY_ON_RIGHT) \
_CRX__C__Ring__DEFINE(pARRAY_TYPE_NAME, pARRAY_MEMBER_FUNCTIONS_PREFIX, pELEMENT_TYPE, \
		pSIZE_T, pSIZE_T_MAX, pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
		pFUNC_ELEMENT_DESTRUCTOR, CRXM__TRUE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, pIS_TO_ENABLE_COPY_ON_RIGHT, \
\
		CRXM__OR(pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
		CRX__C__Ring__ECHO_SIZE_OF_INTERNAL_BUFFER(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, pThis, \
				pDEFAULT_SIZE_OF_INTERNAL_BUFFER), \
		CRXM__OR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, pSTART_INDEX_DEFAULT_ALIGN_FACTOR), \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION()) \


#define _CRX__C__Ring__DEFINE(pARRAY_TYPE_NAME, pARRAY_MEMBER_FUNCTIONS_PREFIX, pELEMENT_TYPE, \
		pSIZE_T, pSIZE_T_MAX, pDEFAULT_SIZE_OF_INTERNAL_BUFFER, pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
		pFUNC_ELEMENT_DESTRUCTOR, pIS_COPYABLE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, pIS_TO_ENABLE_COPY_ON_RIGHT, \
		pHAS_INTERNAL_BUFFER, pTHIS_SIZE_OF_INTERNAL_BUFFER, pHAS_ALIGN_FACTOR, PUBLIC, PRIVATE) \
	typedef char pARRAY_TYPE_NAME ##__ERROR__INVALID_DEFAULT_SIZE_OF_INTERNAL_BUFFER__2[2 * !!( \
			(pDEFAULT_SIZE_OF_INTERNAL_BUFFER == 0) || \
			((pDEFAULT_SIZE_OF_INTERNAL_BUFFER & (pDEFAULT_SIZE_OF_INTERNAL_BUFFER - 1)) == 0)) - 1]; \
	\
	\
	PUBLIC size_t pARRAY_MEMBER_FUNCTIONS_PREFIX ## getCorrectCapacityBoundFor(size_t pCapacity) \
	{ \
		size_t vReturn = 1; \
	\
		while(vReturn < pCapacity) \
			{vReturn = (vReturn << 1);} \
	\
		return vReturn; \
	} \
	\
	CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
	PUBLIC size_t pARRAY_MEMBER_FUNCTIONS_PREFIX ## getByteSizeOf(pARRAY_TYPE_NAME const * pArray) \
	{ \
		return (sizeof(pARRAY_TYPE_NAME) + \
				(pArray->gSIZE_OF_INTERNAL_BUFFER - 1) * sizeof(pELEMENT_TYPE)); \
	}, ) \
	CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
	PUBLIC size_t pARRAY_MEMBER_FUNCTIONS_PREFIX ## getByteSizeFor(size_t pSizeOfInternalBuffer) \
	{ \
		assert((pSizeOfInternalBuffer > 0) || (pDEFAULT_SIZE_OF_INTERNAL_BUFFER > 0)); \
	\
		return (sizeof(pARRAY_TYPE_NAME) + ((((pSizeOfInternalBuffer == 0) ? \
				pDEFAULT_SIZE_OF_INTERNAL_BUFFER : pSizeOfInternalBuffer) - 1) * sizeof(pELEMENT_TYPE))); \
	}, ) \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD),  \
			CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(pARRAY_TYPE_NAME * pThis, size_t pCapacity), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(pARRAY_TYPE_NAME * pThis, size_t pCapacity, \
			size_t pSizeOfInternalBuffer)), \
			CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(pARRAY_TYPE_NAME * pThis, size_t pCapacity, \
			size_t pSizeOfInternalBuffer, signed char pStartIndexAlignFactor), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(pARRAY_TYPE_NAME * pThis, size_t pCapacity, \
			signed char pStartIndexAlignFactor))) \
	{ \
		/* assert(((pThis->gPrivate_externalBuffer == 0) || (pThis->gPrivate_externalBuffer == NULL)) && (pThis->gPrivate_length == 0)); */ \
		assert(pCapacity <= pSIZE_T_MAX); \
		assert((pCapacity & (pCapacity - 1)) == 0); \
		CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		assert((pSizeOfInternalBuffer == 0) || ((pSizeOfInternalBuffer & (pSizeOfInternalBuffer - 1)) == 0)); \
		assert(pSizeOfInternalBuffer <= pSIZE_T_MAX); \
		assert((pSizeOfInternalBuffer > 0) || (pDEFAULT_SIZE_OF_INTERNAL_BUFFER > 0));, ) \
	\
		pThis->gPrivate_externalBuffer = NULL; \
		pThis->gPrivate_length = 0; \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		pThis->gPrivate_isThreadPossible = false;, ) \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
			pThis->gSIZE_OF_INTERNAL_BUFFER = ((pSIZE_T)((pSizeOfInternalBuffer == 0) ? \
					pDEFAULT_SIZE_OF_INTERNAL_BUFFER : pSizeOfInternalBuffer));, )\
	\
			if(pCapacity > pTHIS_SIZE_OF_INTERNAL_BUFFER) \
			{ \
				pThis->gPrivate_externalBuffer = (pARRAY_TYPE_NAME ## _ExternalBuffer *)(malloc( \
						sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + (pCapacity * sizeof(pELEMENT_TYPE)))); \
	\
				if(pThis->gPrivate_externalBuffer != NULL) \
				{ \
					CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
					pThis->gPrivate_externalBuffer->gCount = 1;, ) \
					pThis->gPrivate_capacity = ((pSIZE_T)pCapacity); \
				} \
				else \
				{ \
					pThis->gPrivate_capacity = pTHIS_SIZE_OF_INTERNAL_BUFFER; \
				} \
			} \
			else \
			{ \
				pThis->gPrivate_capacity = pTHIS_SIZE_OF_INTERNAL_BUFFER; \
			} \
		) \
		( \
			if(pCapacity > 0) \
			{ \
				pThis->gPrivate_externalBuffer = (pARRAY_TYPE_NAME ## _ExternalBuffer *)(malloc( \
						sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + (pCapacity * sizeof(pELEMENT_TYPE)))); \
	\
				if(pThis->gPrivate_externalBuffer != NULL) \
				{ \
					CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
					pThis->gPrivate_externalBuffer->gCount = 1;, ) \
					pThis->gPrivate_capacity = ((pSIZE_T)pCapacity); \
				} \
				else \
					{pThis->gPrivate_capacity = 0;} \
			} \
			else \
				{pThis->gPrivate_capacity = 0;} \
		) \
	\
		CRXM__IFELSE(pHAS_ALIGN_FACTOR) \
		( \
			CRXM__IFELSE(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD) \
			( \
				if(pStartIndexAlignFactor == 0) \
					{pThis->gPrivate_startIndexAlignFactor = pSTART_INDEX_DEFAULT_ALIGN_FACTOR;} \
				else \
					{pThis->gPrivate_startIndexAlignFactor = pStartIndexAlignFactor;} \
		\
				if(pThis->gPrivate_startIndexAlignFactor > 0) \
					{pThis->gPrivate_startIndex = (pThis->gPrivate_capacity >> pThis->gPrivate_startIndexAlignFactor);} \
				else \
				{ \
					pThis->gPrivate_startIndex = pThis->gPrivate_capacity - \
							(pThis->gPrivate_capacity >> abs(pThis->gPrivate_startIndexAlignFactor)); \
				} \
			) \
			( \
				if(pSTART_INDEX_DEFAULT_ALIGN_FACTOR > 0) \
					{pThis->gPrivate_startIndex = (pThis->gPrivate_capacity >> pSTART_INDEX_DEFAULT_ALIGN_FACTOR);} \
				else \
				{ \
					pThis->gPrivate_startIndex = pThis->gPrivate_capacity - \
							(pThis->gPrivate_capacity >> abs(pSTART_INDEX_DEFAULT_ALIGN_FACTOR)); \
				} \
			) \
		) \
		( \
			pThis->gPrivate_startIndex = 0; \
		) \
	} \
	CRXM__IFELSE2(CRXM__AND(pHAS_INTERNAL_BUFFER, \
			CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveConstruct(pARRAY_TYPE_NAME * pThis, \
			pARRAY_TYPE_NAME * pArray) \
	{ \
		pThis->gPrivate_externalBuffer = pArray->gPrivate_externalBuffer; \
		pThis->gPrivate_startIndex = pArray->gPrivate_startIndex; \
		pThis->gPrivate_capacity = pArray->gPrivate_capacity; \
		CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		pThis->gSIZE_OF_INTERNAL_BUFFER = pArray->gSIZE_OF_INTERNAL_BUFFER;, )\
		CRXM__IFELSE2(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
		pThis->gPrivate_startIndexAlignFactor = pArray->gPrivate_startIndexAlignFactor;, )\
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		pThis->gPrivate_isThreadPossible = pArray->gPrivate_isThreadPossible;, ) \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer == NULL) \
			{ \
				pThis->gPrivate_length = 0; \
	\
				for(size_t tI = 0; tI < pArray->gPrivate_length; tI++) \
				{ \
					pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPush(pThis, pArray->gPrivate_buffer + \
							((pArray->gPrivate_startIndex + tI) & (pArray->gPrivate_capacity - 1))); \
	\
					CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
					pFUNC_ELEMENT_MOVE_DESTRUCTOR(pArray->gPrivate_buffer + \
							((pArray->gPrivate_startIndex + tI) & (pArray->gPrivate_capacity - 1))), ); \
				} \
			} \
			else \
			{ \
				pThis->gPrivate_length = pArray->gPrivate_length; \
	\
				pArray->gPrivate_externalBuffer = NULL; \
				pArray->gPrivate_capacity = CRX__C__Ring__ECHO_SIZE_OF_INTERNAL_BUFFER( \
						pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, pArray, pDEFAULT_SIZE_OF_INTERNAL_BUFFER); \
			} \
		) \
		( \
			pThis->gPrivate_length = pArray->gPrivate_length; \
	\
			pArray->gPrivate_externalBuffer = NULL; \
			pArray->gPrivate_capacity = 0; \
		) \
	\
		pArray->gPrivate_length = 0; \
	}, ) \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyConstruct(pARRAY_TYPE_NAME * pThis, \
			pARRAY_TYPE_NAME const * pArray) \
	{ \
		CRXM__IFELSE2(CRXM__NOT(pIS_COPYABLE), abort();, \
	\
		CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD),  \
				CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(pThis, CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, 0, \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## getCorrectCapacityBoundFor(pArray->gPrivate_length))), \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(pThis, CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, 0, \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## getCorrectCapacityBoundFor(pArray->gPrivate_length)), \
						pArray->gSIZE_OF_INTERNAL_BUFFER)), \
				CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(pThis, CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, 0, \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## getCorrectCapacityBoundFor(pArray->gPrivate_length)), \
						pArray->gSIZE_OF_INTERNAL_BUFFER, pArray->gPrivate_startIndexAlignFactor), \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(pThis, CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, 0, \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## getCorrectCapacityBoundFor(pArray->gPrivate_length)), \
						pArray->gPrivate_startIndexAlignFactor))); \
	\
		pThis->gPrivate_isThreadPossible = vArray->gPrivate_isThreadPossible; \
	\
		if(pArray->gPrivate_length > 0) \
		{ \
			/*WARNING: THE CODE BELOW DOES NOT FOLLOW THE FORMAT OF THE REST OF THE CODE.*/ \
			if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
					!vArray->gPrivate_isThreadPossible && \
					(pArray->gPrivate_externalBuffer != NULL), false)) \
			{ \
				/*NOTE: THE CHECK BELOW IS JUST IN CASE THE COMPILER DOES NOT OPTIMIZE THE CODE AWAY WHEN NEEDED.*/ \
				CRXM__IFELSE(pIS_TO_ENABLE_COPY_ON_RIGHT) \
				( \
					pArray->gPrivate_externalBuffer->gCount++; \
			\
					pThis->gPrivate_externalBuffer = pArray->gPrivate_externalBuffer; \
					pThis->gPrivate_startIndex = pArray->gPrivate_startIndex & \
							(pArray->gPrivate_capacity - 1); \
					pThis->gPrivate_length = pArray->gPrivate_length; \
					pThis->gPrivate_capacity = pArray->gPrivate_capacity; \
				)() \
			} \
			else \
			{ \
				/*WARNING: THE CODE BELOW DOES NOT FOLLOW THE FORMAT OF THE REST OF THE CODE.*/ \
				if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## ensureCapacity(pThis, pArray->gPrivate_length), true)) \
				{ \
					pELEMENT_TYPE * tTarget = NULL; \
					CRXM__IFELSE2(pHAS_ALIGN_FACTOR, \
					pSIZE_T tStartIndex = 0;, )\
			\
					CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
					( \
						if(pThis->gPrivate_externalBuffer != NULL) \
							{tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
						else \
							{tTarget = pThis->gPrivate_buffer;}	\
					) \
					( \
						tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer; \
					) \
			\
					CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
							pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pThis, tStartIndex) \
			\
					CRXM__IFELSE(pHAS_ALIGN_FACTOR) \
					( \
						if(pThis->gPrivate_capacity - tStartIndex < pArray->gPrivate_length) \
						{ \
							if(pArray->gPrivate_length > (pThis->gPrivate_capacity >> 1)) \
								{tStartIndex = 0;} \
							else \
								{tStartIndex = (pThis->gPrivate_capacity >> 1);} \
						} \
					)() \
			\
					pThis->gPrivate_startIndex = 0 CRXM__IFELSE2(pHAS_ALIGN_FACTOR, + tStartIndex, ); \
			\
					CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
					( \
						pELEMENT_TYPE const * tSource; \
			\
						if(pArray->gPrivate_externalBuffer != NULL) \
							{tSource = pArray->gPrivate_externalBuffer->gPrivate_buffer;} \
						else \
							{tSource = pArray->gPrivate_buffer;} \
			\
						CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
								tTarget, pThis->gPrivate_startIndex, pThis->gPrivate_capacity, 0, \
								tSource, pArray->gPrivate_startIndex, pArray->gPrivate_capacity, \
								0, pArray->gPrivate_length) \
					) \
					( \
						CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
								tTarget, pThis->gPrivate_startIndex, pThis->gPrivate_capacity, 0, \
								pArray->gPrivate_externalBuffer->gPrivate_buffer, pArray->gPrivate_startIndex, pArray->gPrivate_capacity, \
								0, pArray->gPrivate_length) \
					) \
			\
					pThis->gPrivate_length = pArray->gPrivate_length; \
				} \
			} \
		} \
	)} \
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD),  \
			CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_construct (pARRAY_TYPE_NAME * pThis, \
			size_t pCapacity), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_construct (pARRAY_TYPE_NAME * pThis, \
			size_t pSizeOfInternalBuffer, size_t pCapacity)), \
			CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_construct (pARRAY_TYPE_NAME * pThis, \
			size_t pSizeOfInternalBuffer, size_t pCapacity, signed char pStartIndexAlignFactor), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_construct (pARRAY_TYPE_NAME * pThis, \
			size_t pCapacity, signed char pStartIndexAlignFactor))) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD)) \
		( \
			CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD)) \
			( \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct (pThis, pCapacity); \
			) \
			( \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct (pThis, pSizeOfInternalBuffer, pCapacity); \
			) \
		) \
		( \
			CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD)) \
			( \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct (pThis, pCapacity, pStartIndexAlignFactor); \
			) \
			( \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct (pThis, pSizeOfInternalBuffer, pCapacity, \
						pStartIndexAlignFactor); \
			) \
		) \
	\
		pThis->gPrivate_isThreadPossible = true; \
	}, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD),  \
			CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(size_t pCapacity CRX_DEFAULT(0)), \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(size_t pCapacity CRX_DEFAULT(0), \
			size_t pSizeOfInternalBuffer)), \
			CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(size_t pCapacity CRX_DEFAULT(0), \
			size_t pSizeOfInternalBuffer CRX_DEFAULT(0), signed char pStartIndexAlignFactor CRX_DEFAULT(0)), \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(size_t pCapacity CRX_DEFAULT(0), \
			signed char pStartIndexAlignFactor CRX_DEFAULT(0)))) \
	{ \
		CRX_SCOPE_META \
		CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		assert((pSizeOfInternalBuffer == 0) || \
				((pSizeOfInternalBuffer & (pSizeOfInternalBuffer - 1)) == 0));, ) \
		CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		assert(pSizeOfInternalBuffer <= pSIZE_T_MAX);, ) \
		CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
		assert((pSizeOfInternalBuffer > 0) || (pDEFAULT_SIZE_OF_INTERNAL_BUFFER > 0));, ) \
	\
		CRX_SCOPE \
		pARRAY_TYPE_NAME * vReturn; \
	\
		CRXM__IFELSE(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD) \
		( \
			vReturn = (pARRAY_TYPE_NAME *)(calloc(1, \
					sizeof(pARRAY_TYPE_NAME) + ((((pSizeOfInternalBuffer > 0) ? \
					pSizeOfInternalBuffer : pDEFAULT_SIZE_OF_INTERNAL_BUFFER) - 1) * sizeof(pELEMENT_TYPE)))); \
	\
			if(vReturn != NULL) \
			{ \
				CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD), \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(vReturn, pCapacity, pSizeOfInternalBuffer), \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(vReturn, pCapacity, pSizeOfInternalBuffer, \
								pStartIndexAlignFactor)); \
			} \
		) \
		( \
			vReturn = (pARRAY_TYPE_NAME *)(calloc(1, sizeof(pARRAY_TYPE_NAME))); \
	\
			if(vReturn != NULL) \
			{ \
				CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD), \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(vReturn, pCapacity), \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## construct(vReturn, pCapacity, pStartIndexAlignFactor)); \
			} \
		) \
	\
		return vReturn; \
		CRX_SCOPE_END \
	} \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveNew(pARRAY_TYPE_NAME * pArray) \
	{ \
		pARRAY_TYPE_NAME * vReturn = ((pARRAY_TYPE_NAME *) calloc(1, \
				CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## getByteSizeOf(pArray), \
				sizeof(pARRAY_TYPE_NAME)))); \
	\
		if(vReturn != NULL) \
		{ \
			CRXM__IFELSE(CRXM__AND(pHAS_INTERNAL_BUFFER, \
					CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR))) \
			( \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveConstruct(vReturn, pArray); \
			) \
			( \
				memcpy(vReturn, pArray, CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## getByteSizeOf(pArray), \
						sizeof(pARRAY_TYPE_NAME))); \
			) \
		} \
	\
		return vReturn; \
	} \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyNew(pARRAY_TYPE_NAME const * pArray) \
	{ \
		CRXM__IFELSE2(CRXM__NOT(pIS_COPYABLE), abort();, \
	\
		pARRAY_TYPE_NAME * vReturn = ((pARRAY_TYPE_NAME *) calloc(1, \
				CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## getByteSizeOf(pArray), \
				sizeof(pARRAY_TYPE_NAME)))); \
	\
		if(vReturn != NULL) \
			{pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyConstruct(vReturn, pArray);} \
	\
		return vReturn; \
	)} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_new2(pARRAY_TYPE_NAME const * pArray, \
			size_t pStartIndex, size_t pWidth) \
	{ \
		CRX_SCOPE_META \
		assert(pStartIndex + pWidth <= pArray->gPrivate_length); \
	\
		CRX_SCOPE \
		pARRAY_TYPE_NAME * vReturn = CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD),  \
				CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, 0, \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## getCorrectCapacityBoundFor(pWidth))), \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, 0, \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## getCorrectCapacityBoundFor(pWidth)), 0)), \
				CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, 0, \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## getCorrectCapacityBoundFor(pWidth)), 0, 0), \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, 0, \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## getCorrectCapacityBoundFor(pWidth)), 0))); \
	\
		if((vReturn != NULL) && (pWidth > 0)) \
		{ \
			/*WARNING: THE CODE BELOW DOES NOT FOLLOW THE FORMAT OF THE REST OF THE CODE.*/ \
			if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
					!vArray->gPrivate_isThreadPossible && !vReturn->gPrivate_isThreadPossible && \
					(pArray->gPrivate_externalBuffer !== NULL) && \
					CRXM__IFELSE2(CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR), \
					true, ((pStartIndex == 0) && (pWidth == pArray->gPrivate_length))), false)) \
			{ \
				/*NOTE: THE CHECK BELOW IS JUST IN CASE THE COMPILER DOES NOT OPTIMIZE THE CODE AWAY WHEN NEEDED.*/ \
				CRXM__IFELSE(pIS_TO_ENABLE_COPY_ON_RIGHT) \
				( \
					pArray->gPrivate_externalBuffer->gCount++; \
			\
					vReturn->gPrivate_externalBuffer = pArray->gPrivate_externalBuffer; \
					vReturn->gPrivate_startIndex = (pArray->gPrivate_startIndex + pStartIndex) & \
							(pArray->gPrivate_capacity - 1); \
					vReturn->gPrivate_length = (pSIZE_T)pWidth; \
					vReturn->gPrivate_capacity = pArray->gPrivate_capacity; \
				)() \
			} \
			else \
			{ \
				/*WARNING: THE CODE BELOW DOES NOT FOLLOW THE FORMAT OF THE REST OF THE CODE.*/ \
				if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## ensureCapacity(vReturn, pWidth), true)) \
				{ \
					pELEMENT_TYPE * tTarget = NULL; \
					CRXM__IFELSE2(pHAS_ALIGN_FACTOR, \
					pSIZE_T tStartIndex = 0;, )\
			\
					CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
					( \
						if(vReturn->gPrivate_externalBuffer != NULL) \
							{tTarget = vReturn->gPrivate_externalBuffer->gPrivate_buffer;} \
						else \
							{tTarget = vReturn->gPrivate_buffer;}	\
					) \
					( \
						tTarget = vReturn->gPrivate_externalBuffer->gPrivate_buffer; \
					) \
			\
					CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
							pSTART_INDEX_DEFAULT_ALIGN_FACTOR, vReturn, tStartIndex) \
			\
					CRXM__IFELSE(pHAS_ALIGN_FACTOR) \
					( \
						if(vReturn->gPrivate_capacity - tStartIndex < pWidth) \
						{ \
							if(pWidth > (vReturn->gPrivate_capacity >> 1)) \
								{tStartIndex = 0;} \
							else \
								{tStartIndex = (vReturn->gPrivate_capacity >> 1);} \
						} \
					)() \
			\
					vReturn->gPrivate_startIndex = 0 CRXM__IFELSE2(pHAS_ALIGN_FACTOR, + tStartIndex, ); \
			\
					CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
					( \
						pELEMENT_TYPE const * tSource; \
			\
						if(pArray->gPrivate_externalBuffer != NULL) \
							{tSource = pArray->gPrivate_externalBuffer->gPrivate_buffer;} \
						else \
							{tSource = pArray->gPrivate_buffer;} \
			\
						CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
								tTarget, vReturn->gPrivate_startIndex, vReturn->gPrivate_capacity, 0, \
								tSource, pArray->gPrivate_startIndex, pArray->gPrivate_capacity, \
								pStartIndex, pWidth) \
					) \
					( \
						CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
								tTarget, vReturn->gPrivate_startIndex, vReturn->gPrivate_capacity, 0, \
								pArray->gPrivate_externalBuffer->gPrivate_buffer, pArray->gPrivate_startIndex, pArray->gPrivate_capacity, \
								pStartIndex, pWidth) \
					) \
			\
					vReturn->gPrivate_length = (pSIZE_T)pWidth; \
				} \
				else \
				{ \
					CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT) \
					( \
						CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## destruct(vReturn);, ) \
						free(vReturn); \
						vReturn = null; \
					)() \
				} \
			} \
		} \
	\
		return vReturn; \
		CRX_SCOPE_END \
	}, ) \
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD),  \
			CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_new(size_t pCapacity CRX_DEFAULT(0)), \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_new(size_t pCapacity CRX_DEFAULT(0), \
			size_t pSizeOfInternalBuffer)), \
			CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_new(size_t pCapacity CRX_DEFAULT(0), \
			size_t pSizeOfInternalBuffer CRX_DEFAULT(0), signed char pStartIndexAlignFactor CRX_DEFAULT(0)), \
	PUBLIC pARRAY_TYPE_NAME * pARRAY_MEMBER_FUNCTIONS_PREFIX ## threadPossible_new(size_t pCapacity CRX_DEFAULT(0), \
			signed char pStartIndexAlignFactor CRX_DEFAULT(0)))) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD)) \
		( \
			CRXM__IFELSE(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD)) \
			( \
				return pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(pCapacity); \
			) \
			( \
				return pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(pCapacity, pSizeOfInternalBuffer); \
			) \
		) \
		( \
			CRXM__IFELSE(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD) \
			( \
				return pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(pCapacity, pSizeOfInternalBuffer, \
						pStartIndexAlignFactor); \
			) \
			( \
				return pARRAY_MEMBER_FUNCTIONS_PREFIX ## new(pCapacity, pStartIndexAlignFactor); \
			) \
		) \
	\
		pThis->gPrivate_isThreadPossible = true; \
	}, ) \
	CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
	PRIVATE void pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pARRAY_TYPE_NAME * pThis, \
			size_t pStartIndex, size_t pEndIndex) \
	{ \
		size_t vStartIndex = (pThis->gPrivate_startIndex + pStartIndex) & (pThis->gPrivate_capacity - 1); \
		size_t vEndIndex = (pThis->gPrivate_startIndex + pEndIndex) & (pThis->gPrivate_capacity - 1); \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				if(vStartIndex <= vEndIndex) \
				{ \
					for(size_t tI = vStartIndex; tI <= vEndIndex; tI++) \
						{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + tI);} \
				} \
				else \
				{ \
					for(size_t tI = vStartIndex; tI < pThis->gPrivate_capacity; tI++) \
						{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + tI);} \
					for(size_t tI = 0; tI <= vEndIndex; tI++) \
						{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + tI);} \
				} \
			} \
			else \
			{ \
				if(vStartIndex <= vEndIndex) \
				{ \
					for(size_t tI = vStartIndex; tI <= vEndIndex; tI++) \
						{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_buffer + tI);} \
				} \
				else \
				{ \
					for(size_t tI = vStartIndex; tI < pThis->gPrivate_capacity; tI++) \
						{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_buffer + tI);} \
					for(size_t tI = 0; tI <= vEndIndex; tI++) \
						{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_buffer + tI);} \
				} \
			} \
		) \
		( \
			if(vStartIndex <= vEndIndex) \
			{ \
				for(size_t tI = vStartIndex; tI <= vEndIndex; tI++) \
					{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + tI);} \
			} \
			else \
			{ \
				for(size_t tI = vStartIndex; tI < pThis->gPrivate_capacity; tI++) \
					{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + tI);} \
				for(size_t tI = 0; tI <= vEndIndex; tI++) \
					{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + tI);} \
			} \
		) \
	}, )\
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## destruct(pARRAY_TYPE_NAME * pThis) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_TO_ENABLE_COPY_ON_RIGHT)) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
			( \
				if(pThis->gPrivate_length > 0) \
					{pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, 0, pThis->gPrivate_length - 1);} \
			)() \
		 \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				free(pThis->gPrivate_externalBuffer); \
		\
				pThis->gPrivate_externalBuffer = NULL; \
			} \
		) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				if(pThis->gPrivate_externalBuffer->gCount > 1) \
					{pThis->gPrivate_externalBuffer->gCount--;} \
				else \
				{ \
					CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
					( \
						if(pThis->gPrivate_length > 0) \
							{pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, 0, pThis->gPrivate_length - 1);} \
					)() \
		\
					free(pThis->gPrivate_externalBuffer); \
				} \
		\
				pThis->gPrivate_externalBuffer = NULL; \
			} \
			else \
			{ \
				CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
				( \
					if(pThis->gPrivate_length > 0) \
						{pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, 0, pThis->gPrivate_length - 1);} \
				)() \
			} \
		) \
	} \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## free(pARRAY_TYPE_NAME * pThis) \
		{free(pThis);} \
	\
	CRX__C__TYPE_BLUE_PRINT__DEFINE_GET_BLUE_PRINT( \
			pARRAY_TYPE_NAME, pARRAY_MEMBER_FUNCTIONS_PREFIX, \
			CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), CRXM__TRUE, \
			pIS_COPYABLE, CRXM__TRUE, \
			CRXM__AND(pHAS_INTERNAL_BUFFER, CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, \
					pFUNC_ELEMENT_MOVE_DESTRUCTOR)), CRXM__FALSE) \
	\
	PUBLIC pSIZE_T pARRAY_MEMBER_FUNCTIONS_PREFIX ## getLength(pARRAY_TYPE_NAME const * pThis) \
		{return pThis->gPrivate_length;} \
	PUBLIC pSIZE_T pARRAY_MEMBER_FUNCTIONS_PREFIX ## getCapacity(pARRAY_TYPE_NAME const * pThis) \
		{return pThis->gPrivate_capacity;} \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## isThreadPossible(pARRAY_TYPE_NAME * pThis) \
		{return pThis->gPrivate_isThreadPossible;} \
	\
	PRIVATE void pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_moveElements(pELEMENT_TYPE * pSourceBuffer, \
			size_t pStartIndex, size_t pLength, size_t pCapacity, pELEMENT_TYPE * pTargetBuffer) \
	{ \
		CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
		( \
			for(size_t tI = 0; tI < pLength; tI++) \
			{ \
				pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pTargetBuffer + tI, \
						pSourceBuffer + ((pStartIndex + tI) & (pCapacity - 1))); \
			} \
		) \
		( \
			size_t tEndIndex = (pStartIndex + pLength - 1) & (pCapacity - 1); \
		\
			if(tEndIndex < pStartIndex) \
			{ \
				memcpy(pTargetBuffer, \
						pSourceBuffer + pStartIndex, (pCapacity - pStartIndex) * sizeof(pELEMENT_TYPE)); \
				memcpy(pTargetBuffer + (pCapacity - pStartIndex), \
						pSourceBuffer, (tEndIndex + 1) * sizeof(pELEMENT_TYPE)); \
			} \
			else \
				{memcpy(pTargetBuffer, pSourceBuffer + pStartIndex, pLength * sizeof(pELEMENT_TYPE));} \
		) \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
		( \
			for(size_t tI = 0; tI < pLength; tI++) \
				{pFUNC_ELEMENT_MOVE_DESTRUCTOR(pSourceBuffer + ((pStartIndex + tI) & (pCapacity - 1)));} \
		)() \
	} \
	\
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## ensureCapacity(pARRAY_TYPE_NAME * pThis, size_t pCapacity) \
	{ \
		CRX_SCOPE_META \
		assert(pCapacity <= pSIZE_T_MAX); \
	\
		if((pCapacity <= pThis->gPrivate_capacity) && CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
				((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1)), true)) \
			{return true;} \
		else if(pCapacity > ((pSIZE_T_MAX >> 1) + 1)) \
			{return false;} \
	\
		CRX_SCOPE \
		pSIZE_T vCapacity = (CRXM__IFELSE2(pHAS_INTERNAL_BUFFER, \
				pThis->gPrivate_capacity, \
				pThis->gPrivate_capacity == 0 ? 1 : pThis->gPrivate_capacity) << 1); \
	\
		while(vCapacity < pCapacity) \
			{vCapacity = (vCapacity << 1);} \
	\
		if(pThis->gPrivate_externalBuffer == NULL) \
		{ \
			pThis->gPrivate_externalBuffer = (pARRAY_TYPE_NAME ## _ExternalBuffer *)(malloc( \
					sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + (vCapacity * sizeof(pELEMENT_TYPE)))); \
	\
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
				( \
					CRXM__IFELSE2(pHAS_ALIGN_FACTOR, \
					pSIZE_T tStartIndex = 0;, )\
	\
					CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
							pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pThis, tStartIndex) \
	\
					pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_moveElements(pThis->gPrivate_buffer, pThis->gPrivate_startIndex, \
							pThis->gPrivate_length, pThis->gPrivate_capacity, \
							pThis->gPrivate_externalBuffer->gPrivate_buffer CRXM__IFELSE2(pHAS_ALIGN_FACTOR, + tStartIndex, )); \
	\
					pThis->gPrivate_startIndex = 0 CRXM__IFELSE2(pHAS_ALIGN_FACTOR, + tStartIndex, ); \
				)() \
	\
				CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
				pThis->gPrivate_externalBuffer->gCount = 1;, ) \
				pThis->gPrivate_capacity = vCapacity; \
	\
				return true; \
			} \
			else \
				{return false;} \
		} \
		else \
		{ \
			/*WARNING: THE CODE BELOW DOES NOT FOLLOW THE FORMAT OF THE REST OF THE CODE.*/ \
			if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, pThis->gPrivate_externalBuffer->gCount == 1, true)) \
			{ \
				CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)) \
				( \
					pARRAY_TYPE_NAME ## _ExternalBuffer * tExternalBuffer = \
							(pARRAY_TYPE_NAME ## _ExternalBuffer *)(malloc( \
							sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + \
							(vCapacity * sizeof(pELEMENT_TYPE)))); \
		\
					if(tExternalBuffer != NULL) \
					{ \
						CRXM__IFELSE2(pHAS_ALIGN_FACTOR, \
						pSIZE_T tStartIndex = 0;, )\
			\
						CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
								pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pThis, tStartIndex) \
			\
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_moveElements(pThis->gPrivate_externalBuffer->gPrivate_buffer, \
								pThis->gPrivate_startIndex, \
								pThis->gPrivate_length, pThis->gPrivate_capacity, \
								tExternalBuffer->gPrivate_buffer CRXM__IFELSE2(pHAS_ALIGN_FACTOR, + tStartIndex, )); \
			\
						free(pThis->gPrivate_externalBuffer); \
						pThis->gPrivate_externalBuffer = tExternalBuffer; \
			\
						pThis->gPrivate_startIndex = 0 CRXM__IFELSE2(pHAS_ALIGN_FACTOR, + tStartIndex, ); \
						CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
						pThis->gPrivate_externalBuffer->gCount = 1;, ) \
						pThis->gPrivate_capacity = vCapacity; \
			\
						return true; \
					} \
					else \
						{return false;} \
				) \
				( \
					pARRAY_TYPE_NAME ## _ExternalBuffer * tExternalBuffer = \
							(pARRAY_TYPE_NAME ## _ExternalBuffer *)(realloc(pThis->gPrivate_externalBuffer, \
							sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + (vCapacity * sizeof(pELEMENT_TYPE)))); \
				\
					if(tExternalBuffer != NULL) \
					{ \
						size_t tEndIndex = (pThis->gPrivate_startIndex + pThis->gPrivate_length - 1) & (pThis->gPrivate_capacity - 1); \
			\
						if(tEndIndex < pThis->gPrivate_startIndex) \
						{ \
							memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + pThis->gPrivate_startIndex + \
									(pThis->gPrivate_capacity - pThis->gPrivate_startIndex), \
									pThis->gPrivate_externalBuffer->gPrivate_buffer, (tEndIndex + 1) * sizeof(pELEMENT_TYPE)); \
						} \
			\
						pThis->gPrivate_externalBuffer = tExternalBuffer; \
			\
						CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
						pThis->gPrivate_externalBuffer->gCount = 1;, ) \
						pThis->gPrivate_capacity = vCapacity; \
			\
						return true; \
					} \
					else \
						{return false;} \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE(pIS_TO_ENABLE_COPY_ON_RIGHT) \
				( \
					pARRAY_TYPE_NAME ## _ExternalBuffer * tExternalBuffer = \
							(pARRAY_TYPE_NAME ## _ExternalBuffer *)(malloc( \
							sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + (vCapacity * sizeof(pELEMENT_TYPE)))); \
		\
					if(tExternalBuffer != NULL) \
					{ \
						CRXM__IFELSE2(pHAS_ALIGN_FACTOR, \
						pSIZE_T tStartIndex = 0;, ) \
		\
						CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
								pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pThis, tStartIndex) \
		\
						CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
								tExternalBuffer->gPrivate_buffer, tStartIndex, vCapacity, 0, \
								pThis->gPrivate_externalBuffer->gPrivate_buffer, pThis->gPrivate_startIndex, \
								pThis->gPrivate_capacity, 0, pThis->gPrivate_gLength) \
		\
						pThis->gPrivate_externalBuffer = tExternalBuffer; \
		\
						pThis->gPrivate_startIndex = 0 CRXM__IFELSE2(pHAS_ALIGN_FACTOR, + tStartIndex, ); \
						CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
						pThis->gPrivate_externalBuffer->gCount = 1;, ) \
						pThis->gPrivate_capacity = vCapacity; \
		\
						return true; \
					} \
					else \
						{return false;} \
				)() \
			} \
		} \
		CRX_SCOPE_END \
	} \
	\
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## emptyAndEnsureCapacity(pARRAY_TYPE_NAME * pThis, \
			size_t pCapacity) \
	{ \
		CRX_SCOPE_META \
		assert(pCapacity <= pSIZE_T_MAX); \
	\
		if((pCapacity <= pThis->gPrivate_capacity) && (pThis->gPrivate_length == 0) && \
				CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
				((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1)), true)) \
			{return true;} \
		else if(pCapacity > ((pSIZE_T_MAX >> 1) + 1)) \
			{return false;} \
	\
		CRX_SCOPE \
		bool vIsNoError = true; \
		pARRAY_TYPE_NAME ## _ExternalBuffer * vExternalBuffer = NULL; \
		pSIZE_T vCapacity = pThis->gPrivate_capacity; \
	\
		CRXM__IFELSE(pIS_TO_ENABLE_COPY_ON_RIGHT) \
		( \
			if((pThis->gPrivate_externalBuffer != NULL) && (pThis->gPrivate_externalBuffer->gCount > 1)) \
			{ \
				vCapacity = (CRXM__IFELSE2(pHAS_INTERNAL_BUFFER, \
						pThis->gPrivate_capacity, \
						pThis->gPrivate_capacity == 0 ? 1 : pThis->gPrivate_capacity)); \
	\
				while(vCapacity < pCapacity) \
					{vCapacity = (vCapacity << 1);} \
	\
				vExternalBuffer = (pARRAY_TYPE_NAME ## _ExternalBuffer *)(malloc( \
						sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + \
						(vCapacity * sizeof(pELEMENT_TYPE)))); \
	\
				if(vExternalBuffer == NULL) \
					{vIsNoError = false;} \
			} \
		)() \
	\
		if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, (vExternalBuffer == NULL) && \
				vIsNoError, true) && (pCapacity > pThis->gPrivate_capacity)) \
		{ \
			vCapacity = (CRXM__IFELSE2(pHAS_INTERNAL_BUFFER, \
					pThis->gPrivate_capacity, \
					pThis->gPrivate_capacity == 0 ? 1 : pThis->gPrivate_capacity)); \
	\
			while(vCapacity < pCapacity) \
				{vCapacity = (vCapacity << 1);} \
	\
			CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)) \
			( \
				vExternalBuffer = (pARRAY_TYPE_NAME ## _ExternalBuffer *)(malloc( \
						sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + \
						(vCapacity * sizeof(pELEMENT_TYPE)))); \
			) \
			( \
				if(pThis->gPrivate_externalBuffer != NULL) \
				{ \
					vExternalBuffer = (pARRAY_TYPE_NAME ## _ExternalBuffer *)(realloc(pThis->gPrivate_externalBuffer, \
							sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + \
							(vCapacity * sizeof(pELEMENT_TYPE)))); \
				} \
				else \
				{ \
					vExternalBuffer = (pARRAY_TYPE_NAME ## _ExternalBuffer *)(malloc( \
							sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + \
							(vCapacity * sizeof(pELEMENT_TYPE)))); \
				} \
			) \
\
			if(vExternalBuffer == NULL) \
				{vIsNoError = false;} \
		} \
	\
		if(vIsNoError) \
		{ \
			CRXM__IFELSE2(pHAS_ALIGN_FACTOR, \
					pSIZE_T tStartIndex = 0;, )\
	\
			CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
					pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pThis, tStartIndex) \
	\
			CRXM__IFELSE(CRXM__NOT(pIS_TO_ENABLE_COPY_ON_RIGHT)) \
			( \
				CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
				( \
					if(pThis->gPrivate_length > 0) \
					{ \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, 0, \
								pThis->gPrivate_length - 1); \
					} \
				)() \
			) \
			( \
				if((pThis->gPrivate_externalBuffer != NULL) && (pThis->gPrivate_externalBuffer->gCount > 1)) \
				{ \
					pThis->gPrivate_externalBuffer->gCount--; \
					pThis->gPrivate_externalBuffer = NULL; \
				} \
				else \
				{ \
					CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
					( \
						if(pThis->gPrivate_length > 0) \
						{ \
							pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, 0, \
									pThis->gPrivate_length - 1); \
						} \
					) \
				} \
			) \
	\
			if(vExternalBuffer != NULL) \
			{ \
				free(pThis->gPrivate_externalBuffer); \
				pThis->gPrivate_externalBuffer = vExternalBuffer; \
	\
				CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
				pThis->gPrivate_externalBuffer->gCount = 1;, ) \
				pThis->gPrivate_capacity = vCapacity; \
			} \
	\
			pThis->gPrivate_length = 0; \
			pThis->gPrivate_startIndex = 0 CRXM__IFELSE2(pHAS_ALIGN_FACTOR, + tStartIndex, ); \
	\
			return true; \
		} \
		else \
			{return false;} \
		CRX_SCOPE_END \
	} \
	\
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## empty(pARRAY_TYPE_NAME * pThis) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_TO_ENABLE_COPY_ON_RIGHT)) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
			( \
				if(pThis->gPrivate_length == 0) \
					{return;} \
		\
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, 0, pThis->gPrivate_length - 1); \
		\
				CRXM__IFELSE(pHAS_ALIGN_FACTOR) \
				( \
					CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
							pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pThis, pThis->gPrivate_startIndex) \
				) \
				( \
					pThis->gPrivate_startIndex = 0; \
				) \
			)() \
		) \
		( \
			if((pThis->gPrivate_externalBuffer != NULL) && (pThis->gPrivate_externalBuffer->gCount > 1)) \
			{ \
				pThis->gPrivate_externalBuffer->gCount--; \
				pThis->gPrivate_externalBuffer = NULL; \
	\
				CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
				( \
					pThis->gPrivate_capacity = pTHIS_SIZE_OF_INTERNAL_BUFFER; \
				) \
				( \
					pThis->gPrivate_capacity = 0; \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
				( \
					if(pThis->gPrivate_length > 0) \
					{ \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, 0, \
								pThis->gPrivate_length - 1); \
					} \
				) \
			} \
	\
			CRXM__IFELSE(pHAS_ALIGN_FACTOR) \
			( \
				if(pThis->gPrivate_capacity > 0) \
				{ \
					CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
							pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pThis, pThis->gPrivate_startIndex) \
				} \
				else \
					{pThis->gPrivate_startIndex = 0;} \
			) \
			( \
				pThis->gPrivate_startIndex = 0; \
			) \
		) \
	\
		pThis->gPrivate_length = 0; \
	} \
	\
	PRIVATE bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_insertSpaceAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			size_t pWidth) \
	{ \
		CRX_SCOPE_META \
		assert(pIndex <= pThis->gPrivate_length); \
	\
		CRX_SCOPE \
		bool vIsNoError = true; \
	\
		if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, true, pWidth + pThis->gPrivate_length > pThis->gPrivate_capacity)) \
			{vIsNoError = pARRAY_MEMBER_FUNCTIONS_PREFIX ## ensureCapacity(pThis, pWidth + pThis->gPrivate_length);} \
	\
		if(!vIsNoError) \
			{return false;} \
		else \
		{ \
			CRX__C__Ring__ECHO_INSERT_SPACE_AT(pSIZE_T, pELEMENT_TYPE, \
					pTHIS_SIZE_OF_INTERNAL_BUFFER, pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
					pThis, pIndex, pWidth) \
	\
			return true; \
		} \
		CRX_SCOPE_END \
	} \
	PRIVATE void pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_fastInsertSpaceAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			size_t pWidth) \
	{ \
		assert(pIndex <= pThis->gPrivate_length); \
		assert(pWidth + pThis->gPrivate_length <= pThis->gPrivate_capacity); \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
	\
		CRX__C__Ring__ECHO_INSERT_SPACE_AT(pSIZE_T, pELEMENT_TYPE, \
				pTHIS_SIZE_OF_INTERNAL_BUFFER, pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
				pThis, pIndex, pWidth) \
	} \
	PRIVATE Crx_C_Ring_Private_IndexTransform pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_roundInsertSpaceAt( \
			pARRAY_TYPE_NAME * pThis, size_t pIndex, size_t pWidth) \
	{ \
		CRX_SCOPE_META \
		assert(pIndex <= pThis->gPrivate_length); \
		assert(pThis->gPrivate_capacity > 0); \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
	\
		CRX_SCOPE \
		Crx_C_Ring_Private_IndexTransform vReturn; \
	\
		CRX__SET_TO_ZERO(Crx_C_Ring_Private_IndexTransform, vReturn); \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
		( \
			if(pThis->gPrivate_length > 0) \
			{ \
				if(pWidth > pThis->gPrivate_capacity - pThis->gPrivate_length) \
				{ \
					if(pWidth >= pThis->gPrivate_capacity) \
					{ \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, 0, \
								pThis->gPrivate_length - 1); \
					} \
					else \
					{ \
						if(pWidth <= pThis->gPrivate_capacity - pThis->gPrivate_length + pIndex) \
						{ \
							pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, 0, \
									pWidth - (pThis->gPrivate_capacity - pThis->gPrivate_length) - 1); \
						} \
						else \
						{ \
							pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, 0, pIndex - 1); \
							pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, \
									pThis->gPrivate_length - (pWidth - (pThis->gPrivate_capacity - pThis->gPrivate_length) - pIndex), \
									pThis->gPrivate_length - 1); \
						} \
					} \
				} \
			} \
		)() \
	\
		if(pWidth < pThis->gPrivate_capacity) \
		{ \
			if(pIndex == 0) \
			{ \
				if(pThis->gPrivate_startIndex > pWidth) \
					{pThis->gPrivate_startIndex = ((pSIZE_T)(pThis->gPrivate_startIndex - pWidth));} \
				else \
					{pThis->gPrivate_startIndex = ((pSIZE_T)(pThis->gPrivate_capacity - (pWidth - pThis->gPrivate_startIndex)));} \
			} \
			else if(pIndex == pThis->gPrivate_length) \
				{} \
			else \
			{ \
				assert((((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)) != pThis->gPrivate_startIndex) && \
						(pWidth < pThis->gPrivate_capacity)); \
	\
				if(pWidth >= pThis->gPrivate_capacity - pThis->gPrivate_length + pIndex) \
				{ \
					pThis->gPrivate_startIndex = ((pSIZE_T)(pThis->gPrivate_startIndex + (pIndex & (pThis->gPrivate_capacity - 1)))); \
				} \
				else \
				{ \
					size_t tOldStartIndex = pThis->gPrivate_startIndex; \
					pELEMENT_TYPE * vTarget = NULL; \
	\
					CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
					( \
						if(pThis->gPrivate_externalBuffer == NULL) \
							{vTarget = pThis->gPrivate_buffer;} \
						else \
							{vTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
					) \
					( \
						vTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer; \
					) \
	\
					if((pThis->gPrivate_length >> 1) > pIndex) \
					{ \
						size_t tSegmentStartIndex; \
						size_t tSegmentEndIndex = pIndex - 1; \
	\
						if(pWidth < pThis->gPrivate_capacity - pThis->gPrivate_length) \
						{ \
							tSegmentStartIndex = 0; \
	\
							/*THE FOLLOWING IS SUBTRACTING pWidth*/ \
							pThis->gPrivate_startIndex = ((pSIZE_T)((pThis->gPrivate_startIndex + (pThis->gPrivate_capacity - pWidth)) & \
									(pThis->gPrivate_capacity - 1))); \
						} \
						else \
						{ \
							tSegmentStartIndex = pWidth - (pThis->gPrivate_capacity - pThis->gPrivate_length); \
	\
							pThis->gPrivate_startIndex = ((pSIZE_T)((pThis->gPrivate_startIndex + pThis->gPrivate_length) & \
									(pThis->gPrivate_capacity - 1))); \
						} \
	\
						CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)) \
						( \
							CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
							( \
								for(size_t tI = tSegmentStartIndex; tI <= tSegmentEndIndex; tI++) \
								{ \
									/*THE FOLLOWING IS SUBTRACTING pWidth*/ \
									pFUNC_ELEMENT_MOVE_CONSTRUCTOR( \
											vTarget + ((tOldStartIndex + tI + pThis->gPrivate_capacity - pWidth) & (pThis->gPrivate_capacity - 1)), \
											vTarget + ((tOldStartIndex + tI) & (pThis->gPrivate_capacity - 1))); \
	\
									CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, \
									pFUNC_ELEMENT_MOVE_DESTRUCTOR(vTarget + \
											((tOldStartIndex + tI) & (pThis->gPrivate_capacity - 1)));, ) \
								} \
							) \
							( \
								CRX_FOR(size_t tI = tSegmentStartIndex; tI <= tSegmentEndIndex; tI++) \
								{ \
									/*THE FOLLOWING IS SUBTRACTING pWidth*/ \
									memmove(vTarget + ((tOldStartIndex + tI + pThis->gPrivate_capacity - pWidth) & (pThis->gPrivate_capacity - 1)), \
											vTarget + ((tOldStartIndex + tI) & (pThis->gPrivate_capacity - 1)), \
											sizeof(pELEMENT_TYPE)); \
	\
									pFUNC_ELEMENT_MOVE_DESTRUCTOR(vTarget + \
											((tOldStartIndex + tI) & (pThis->gPrivate_capacity - 1))); \
								} \
							) \
						) \
						( \
							CRX__C__RING__ECHO__RAW_ROTATE_LEFT(pELEMENT_TYPE, vTarget, \
									(tOldStartIndex + tSegmentStartIndex) & (pThis->gPrivate_capacity - 1), \
									(tOldStartIndex + tSegmentEndIndex) & (pThis->gPrivate_capacity - 1), \
									pThis->gPrivate_capacity, pWidth, CRXM__FALSE) \
						) \
					} \
					else \
					{ \
						size_t tSegmentStartIndex = pIndex; \
						size_t tSegmentEndIndex = pThis->gPrivate_length - 1; \
	\
						if(pWidth >= pThis->gPrivate_capacity - pThis->gPrivate_length) \
						{ \
							pThis->gPrivate_startIndex = ((pSIZE_T)((pThis->gPrivate_startIndex + (pWidth - (pThis->gPrivate_capacity - pThis->gPrivate_length))) & \
										(pThis->gPrivate_capacity - 1))); \
						} \
	\
						CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)) \
						( \
							CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
							( \
								for(size_t tI = tSegmentEndIndex; tI >= tSegmentStartIndex; tI--) \
								{ \
									pFUNC_ELEMENT_MOVE_CONSTRUCTOR( \
											vTarget + ((tOldStartIndex + tI + pWidth) & (pThis->gPrivate_capacity - 1)), \
											vTarget + ((tOldStartIndex + tI) & (pThis->gPrivate_capacity - 1))); \
	\
									CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, \
									pFUNC_ELEMENT_MOVE_DESTRUCTOR(vTarget + \
											((tOldStartIndex + tI) & (pThis->gPrivate_capacity - 1)));, ) \
								} \
							) \
							( \
								for(size_t tI = tSegmentEndIndex; tI >= tSegmentStartIndex; tI--) \
								{ \
									memmove(vTarget + ((tOldStartIndex + tI + pWidth) & (pThis->gPrivate_capacity - 1)), \
											vTarget + ((tOldStartIndex + tI) & (pThis->gPrivate_capacity - 1)), \
											sizeof(pELEMENT_TYPE)); \
	\
									pFUNC_ELEMENT_MOVE_DESTRUCTOR(vTarget + \
											((tOldStartIndex + tI) & (pThis->gPrivate_capacity - 1))); \
								} \
							) \
						) \
						( \
							CRX__C__RING__ECHO__RAW_ROTATE_RIGHT(pELEMENT_TYPE, vTarget, \
									(tOldStartIndex + tSegmentStartIndex) & (pThis->gPrivate_capacity - 1), \
									(tOldStartIndex + tSegmentEndIndex) & (pThis->gPrivate_capacity - 1), \
									pThis->gPrivate_capacity, pWidth, CRXM__FALSE) \
						) \
					} \
	\
					if(pWidth < pThis->gPrivate_capacity - pThis->gPrivate_length) \
						{vReturn.gNewIndex = pIndex;} \
					else \
					{ \
						vReturn.gNewIndex = (pIndex + (pThis->gPrivate_capacity - \
								(pWidth - (pThis->gPrivate_capacity - pThis->gPrivate_length)))) & \
								(pThis->gPrivate_capacity - 1); \
					} \
				} \
			} \
	\
			pThis->gPrivate_length = pThis->gPrivate_length + ((pSIZE_T)pWidth); \
	\
			if(pThis->gPrivate_length > pThis->gPrivate_capacity) \
				{pThis->gPrivate_length = pThis->gPrivate_capacity;} \
	\
			vReturn.gNewCountToEnd = pWidth; \
		} \
		else \
			{vReturn.gNewCountToEnd = pThis->gPrivate_capacity;} \
	\
		return vReturn; \
		CRX_SCOPE_END \
	} \
	\
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyAssignFrom2(pARRAY_TYPE_NAME * pThis, \
			pARRAY_TYPE_NAME const * pArray, size_t pStartIndex, size_t pWidth) \
	{ \
		CRX_SCOPE_META \
		assert(pStartIndex + pWidth <= pArray->gPrivate_length); \
	\
		CRX_SCOPE \
		pARRAY_TYPE_NAME * vArray = ((pARRAY_TYPE_NAME *)pArray); \
		bool vIsSameArray = CRX__ARE_POINTERS_TO_SAME_OBJECT(pThis, pArray, true); \
		bool vReturn = false; \
	\
		if(vIsSameArray) \
		{ \
			CRXM__IFELSE(CRX__ARE_ONLY_POINTERS_TO_SAME_OBJECT_EQUAL_AND_ALWAYS) \
			( \
				if((pStartIndex == 0) && (pWidth == pThis->gPrivate_length)) \
					{return true;} \
			)() \
	\
			vArray = pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_new2(pArray, pStartIndex, pWidth); \
		} \
	\
		if(vArray != NULL) \
		{ \
			/*WARNING: THE CODE BELOW DOES NOT FOLLOW THE FORMAT OF THE REST OF THE CODE.*/ \
			if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
					!vArray->gPrivate_isThreadPossible && !pThis->gPrivate_isThreadPossible && \
					(vArray->gPrivate_externalBuffer !== NULL) && \
					CRXM__IFELSE2(CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR), \
					true, ((pStartIndex == 0) && (pWidth == vArray->gPrivate_length))), false)) \
			{ \
				/*NOTE: THE CHECK BELOW IS JUST IN CASE THE COMPILER DOES NOT OPTIMIZE THE CODE AWAY WHEN NEEDED.*/ \
				CRXM__IFELSE(pIS_TO_ENABLE_COPY_ON_RIGHT) \
				( \
					if(pThis->gPrivate_externalBuffer != NULL) \
					{ \
						if(pThis->gPrivate_externalBuffer->gCount > 1) \
							{pThis->gPrivate_externalBuffer->gCount--;} \
						else \
						{ \
							CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
							( \
								if(pThis->gPrivate_length > 0) \
								{ \
									pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, 0, \
											pThis->gPrivate_length - 1); \
								} \
							) \
			\
							free(pThis->gPrivate_externalBuffer); \
						} \
					} \
					else \
					{ \
						CRXM__IFELSE(CRXM__AND(pHAS_INTERNAL_BUFFER, pFUNC_ELEMENT_DESTRUCTOR)) \
						( \
							if(pThis->gPrivate_length > 0) \
							{ \
								pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, 0, \
										pThis->gPrivate_length - 1); \
							} \
						) \
					} \
			\
					vArray->gPrivate_externalBuffer->gCount++; \
			\
					pThis->gPrivate_externalBuffer = vArray->gPrivate_externalBuffer; \
					pThis->gPrivate_startIndex = (vArray->gPrivate_startIndex + pStartIndex) & \
							(vArray->gPrivate_capacity - 1); \
					pThis->gPrivate_length = ((pSIZE_T)pWidth); \
					pThis->gPrivate_capacity = vArray->gPrivate_capacity; \
				)() \
		\
				/**/ \
				vReturn = true; \
			} \
			else \
			{ \
				if(pARRAY_MEMBER_FUNCTIONS_PREFIX ## emptyAndEnsureCapacity(pThis, pWidth)) \
				{ \
					if(pWidth == 0) \
						{vReturn = true;} \
					else \
					{ \
						pELEMENT_TYPE * tTarget = NULL; \
						CRXM__IFELSE2(pHAS_ALIGN_FACTOR, \
						pSIZE_T tStartIndex = 0;, )\
			\
						CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
						( \
							if(pThis->gPrivate_externalBuffer != NULL) \
								{tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
							else \
								{tTarget = pThis->gPrivate_buffer;}	\
						) \
						( \
							tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer; \
						) \
			\
						CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
								pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pThis, tStartIndex) \
			\
						CRXM__IFELSE(pHAS_ALIGN_FACTOR) \
						( \
							if(pThis->gPrivate_capacity - tStartIndex < pWidth) \
							{ \
								if(pWidth > (pThis->gPrivate_capacity >> 1)) \
									{tStartIndex = 0;} \
								else \
									{tStartIndex = (pThis->gPrivate_capacity >> 1);} \
							} \
						)() \
			\
						pThis->gPrivate_startIndex = 0 CRXM__IFELSE2(pHAS_ALIGN_FACTOR, + tStartIndex, ); \
			\
						CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
						( \
							pELEMENT_TYPE * tSource; \
			\
							if(vArray->gPrivate_externalBuffer != NULL) \
								{tSource = vArray->gPrivate_externalBuffer->gPrivate_buffer;} \
							else \
								{tSource = vArray->gPrivate_buffer;} \
			\
							CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
									tTarget, pThis->gPrivate_startIndex, pThis->gPrivate_capacity, 0, \
									tSource, vArray->gPrivate_startIndex, vArray->gPrivate_capacity, \
									pStartIndex, pWidth) \
						) \
						( \
							CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
									pThis->gPrivate_externalBuffer->gPrivate_buffer, pThis->gPrivate_startIndex, pThis->gPrivate_capacity, 0, \
									vArray->gPrivate_externalBuffer->gPrivate_buffer, vArray->gPrivate_startIndex, vArray->gPrivate_capacity, \
									pStartIndex, pWidth) \
						) \
			\
						pThis->gPrivate_length = ((pSIZE_T)pWidth); \
			\
						vReturn = true; \
					} \
				} \
			} \
	\
			if(vIsSameArray) \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## destruct(vArray);, ) \
				free(vArray); \
			} \
		} \
	\
		return vReturn; \
		CRX_SCOPE_END \
	}, ) \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyAssignFrom(pARRAY_TYPE_NAME * pThis, \
			pARRAY_TYPE_NAME const * pArray) \
	{ \
		return pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyAssignFrom2(pThis, pArray, 0, \
				pArray->gPrivate_length); \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD), \
			CRXM__OR(pHAS_INTERNAL_BUFFER, pIS_TO_ENABLE_COPY_ON_RIGHT)), \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryToPilferSwapContentWith(pARRAY_TYPE_NAME * pThis, \
			pARRAY_TYPE_NAME * pArray) \
	{ \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		if(pThis->gPrivate_isThreadPossible != pArray->gPrivate_isThreadPossible) \
			{return false;}, ); \
	\
		if((pThis->gPrivate_externalBuffer != NULL) && (pArray->gPrivate_externalBuffer != NULL)) \
		{ \
			pELEMENT_TYPE * tExternalBuffer = pArray->gPrivate_externalBuffer; \
			pSIZE_T tStartIndex = pArray->gPrivate_startIndex; \
			pSIZE_T tLength = pArray->gPrivate_length; \
			pSIZE_T tCapacity = pArray->gPrivate_capacity; \
	\
			pArray->gPrivate_externalBuffer = pThis->gPrivate_externalBuffer; \
			pArray->gPrivate_startIndex = pThis->gPrivate_startIndex; \
			pArray->gPrivate_length = pThis->gPrivate_length; \
			pArray->gPrivate_capacity = pThis->gPrivate_capacity; \
	\
			pThis->gPrivate_externalBuffer = tExternalBuffer; \
			pThis->gPrivate_startIndex = tStartIndex; \
			pThis->gPrivate_length = tLength; \
			pThis->gPrivate_capacity = tCapacity; \
	\
			return true; \
		} \
		else \
			{return false;} \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pHAS_INTERNAL_BUFFER), CRXM__NOT(pIS_TO_ENABLE_COPY_ON_RIGHT)), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## pilferSwapContentWith(pARRAY_TYPE_NAME * pThis, \
			pARRAY_TYPE_NAME * pArray) \
	{ \
		pELEMENT_TYPE * tExternalBuffer = pArray->gPrivate_externalBuffer; \
		pSIZE_T tStartIndex = pArray->gPrivate_startIndex; \
		pSIZE_T tLength = pArray->gPrivate_length; \
		pSIZE_T tCapacity = pArray->gPrivate_capacity; \
	\
		pArray->gPrivate_externalBuffer = pThis->gPrivate_externalBuffer; \
		pArray->gPrivate_startIndex = pThis->gPrivate_startIndex; \
		pArray->gPrivate_length = pThis->gPrivate_length; \
		pArray->gPrivate_capacity = pThis->gPrivate_capacity; \
	\
		pThis->gPrivate_externalBuffer = tExternalBuffer; \
		pThis->gPrivate_startIndex = tStartIndex; \
		pThis->gPrivate_length = tLength; \
		pThis->gPrivate_capacity = tCapacity; \
	}, ) \
	\
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndSetAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE * pElement), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndSetAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE * pElement)) \
	{ \
		assert(pIndex <= pThis->gPrivate_length); \
	\
		CRXM__IFELSE(pIS_TO_ENABLE_COPY_ON_RIGHT) \
		( \
			if(!pARRAY_MEMBER_FUNCTIONS_PREFIX ## ensureCapacity(pThis, pThis->gPrivate_capacity)) \
				{return false;} \
		)() \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
						pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)));, ) \
	\
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
						pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_buffer + ((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)));, ) \
	\
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_buffer + ((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), \
							pElement, sizeof(pELEMENT_TYPE)); \
				) \
			} \
		) \
		( \
			CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
					pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
					((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)));, ) \
	\
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement); \
			) \
			( \
				memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement, \
						sizeof(pELEMENT_TYPE)); \
			) \
		) \
	\
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		return true;, ) \
	} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## setAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * pElement), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## setAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * pElement)) \
	{ \
		CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
		unsigned char * vElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		bool vReturn;, )\
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
			CRXM__IFELSE(pIS_TO_ENABLE_COPY_ON_RIGHT) \
			( \
				vReturn = pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndSetAt(pThis, pIndex, \
						((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndSetAt(pThis, pIndex, \
						((pELEMENT_TYPE *)vElement)); \
			) \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
				CRXM__IFELSE(pIS_TO_ENABLE_COPY_ON_RIGHT) \
				( \
					vReturn = pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndSetAt(pThis, pIndex, \
							((pELEMENT_TYPE *)vElement)); \
				) \
				( \
					pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndSetAt(pThis, pIndex, \
							((pELEMENT_TYPE *)vElement)); \
				) \
			) \
			( \
				CRXM__IFELSE(pIS_TO_ENABLE_COPY_ON_RIGHT) \
				( \
					vReturn = pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndSetAt(pThis, pIndex, \
							((pELEMENT_TYPE *)pElement)); \
				) \
				( \
					pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndSetAt(pThis, pIndex, \
							((pELEMENT_TYPE *)pElement)); \
				) \
			) \
		) \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_TO_ENABLE_COPY_ON_RIGHT)) \
		( \
			CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
							CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
					pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
		) \
		( \
			if(vReturn) \
			{ \
				CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
						CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
			} \
			else \
			{ \
				CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_DESTRUCTOR, \
						CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
				pFUNC_ELEMENT_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
			} \
	\
			return vReturn; \
		) \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## setAt2(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE pElement), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## setAt2(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE pElement)) \
	{ \
		CRXM__IFELSE(pIS_TO_ENABLE_COPY_ON_RIGHT) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
			( \
				if(return pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndSetAt(pThis, pIndex, \
						&pElement)) \
				{ \
					pFUNC_ELEMENT_MOVE_DESTRUCTOR(&pElement); \
		\
					return true; \
				} \
				else \
					{return false;} \
			) \
			( \
				return pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndSetAt(pThis, pIndex, \
						&pElement); \
			) \
		) \
		( \
			pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndSetAt(pThis, pIndex, &pElement); \
	\
			CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
			pFUNC_ELEMENT_MOVE_DESTRUCTOR(&pElement);, ) \
		) \
	}, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_COPY_ON_RIGHT), \
	PUBLIC pELEMENT_TYPE * pARRAY_MEMBER_FUNCTIONS_PREFIX ## get(pARRAY_TYPE_NAME * pThis, size_t pIndex), \
	PRIVATE pELEMENT_TYPE * pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_get(pARRAY_TYPE_NAME * pThis, size_t pIndex)) \
	{ \
		assert(pIndex < pThis->gPrivate_length); \
	 \
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				return (pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1))); \
			} \
			else \
				{return (pThis->gPrivate_buffer + ((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)));} \
		) \
		( \
			return (pThis->gPrivate_externalBuffer->gPrivate_buffer + \
					((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1))); \
		) \
	} \
	PUBLIC pELEMENT_TYPE const * pARRAY_MEMBER_FUNCTIONS_PREFIX ## constantGet( \
			pARRAY_TYPE_NAME const * pThis, size_t pIndex) \
	{ \
		CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_COPY_ON_RIGHT) \
		( \
			return pARRAY_MEMBER_FUNCTIONS_PREFIX ## get((pARRAY_TYPE_NAME *) pThis, pIndex); \
		) \
		( \
			return pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_get((pARRAY_TYPE_NAME *) pThis, \
					pIndex); \
		) \
	} \
	\
	CRXM__IFELSE2(pIS_COPYABLE, \
	CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_DESTRUCTOR), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyGetTo(pARRAY_TYPE_NAME const * pThis, \
			pELEMENT_TYPE * pReturn, size_t pIndex), \
	PUBLIC pELEMENT_TYPE pARRAY_MEMBER_FUNCTIONS_PREFIX ## copyGet(pARRAY_TYPE_NAME const * pThis, size_t pIndex)) \
	{ \
		assert(pIndex < pThis->gPrivate_length); \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_DESTRUCTOR)) \
				( \
					CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
					pFUNC_ELEMENT_DESTRUCTOR(pReturn);, ) \
	\
					CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
					( \
						pFUNC_ELEMENT_COPY_CONSTRUCTOR(pReturn, \
								pThis->gPrivate_externalBuffer->gPrivate_buffer + \
								((pThis->gPrivate_startIndex + pIndex) & \
								(pThis->gPrivate_capacity - 1))); \
					) \
					( \
						memcpy(pReturn, \
								pThis->gPrivate_externalBuffer->gPrivate_buffer + \
								((pThis->gPrivate_startIndex + pIndex) & \
								(pThis->gPrivate_capacity - 1)), sizeof(pELEMENT_TYPE)); \
					) \
				) \
				( \
					return *(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & \
							(pThis->gPrivate_capacity - 1))); \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_DESTRUCTOR)) \
				( \
					CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
					pFUNC_ELEMENT_DESTRUCTOR(pReturn);, ) \
	\
					CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
					( \
						pFUNC_ELEMENT_COPY_CONSTRUCTOR(pReturn, \
								pThis->gPrivate_buffer + \
								((pThis->gPrivate_startIndex + pIndex) & \
								(pThis->gPrivate_capacity - 1))); \
					) \
					( \
						memcpy(pReturn, \
								pThis->gPrivate_buffer + \
								((pThis->gPrivate_startIndex + pIndex) & \
								(pThis->gPrivate_capacity - 1)), sizeof(pELEMENT_TYPE)); \
					) \
				) \
				( \
					return *(pThis->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & \
							(pThis->gPrivate_capacity - 1))); \
				) \
			} \
		) \
		( \
			CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_DESTRUCTOR)) \
			( \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
				pFUNC_ELEMENT_DESTRUCTOR(pReturn);, ) \
	\
				CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_COPY_CONSTRUCTOR(pReturn, \
							pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & \
							(pThis->gPrivate_capacity - 1))); \
				) \
				( \
					memcpy(pReturn, \
							pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & \
							(pThis->gPrivate_capacity - 1)), sizeof(pELEMENT_TYPE)); \
				) \
			) \
			( \
				return *(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + pIndex) & \
						(pThis->gPrivate_capacity - 1))); \
			) \
		) \
	}, ) \
	\
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPush(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE * pElement) \
	{ \
		bool vIsNoError = true; \
	 \
		if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, true, \
				pThis->gPrivate_length + 1 > pThis->gPrivate_capacity)) \
			{vIsNoError = pARRAY_MEMBER_FUNCTIONS_PREFIX ## ensureCapacity(pThis, pThis->gPrivate_length + 1);} \
	\
		if(vIsNoError) \
		{ \
			CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
			( \
				if(pThis->gPrivate_externalBuffer != NULL) \
				{ \
					CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
					( \
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
								((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement); \
					) \
					( \
						memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
								((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement, \
								sizeof(pELEMENT_TYPE)); \
					) \
				} \
				else \
				{ \
					CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
					( \
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_buffer + \
								((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement); \
					) \
					( \
						memcpy(pThis->gPrivate_buffer + ((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), \
								pElement, sizeof(pELEMENT_TYPE)); \
					) \
				} \
			) \
			( \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			) \
	\
			pThis->gPrivate_length = pThis->gPrivate_length + 1; \
	\
			return true; \
		} \
		else \
			{return false;} \
	} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## push(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE const * pElement) \
	{ \
		CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
		unsigned char * vElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
		CRXM__IFELSE2(CRXM__AND(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
				CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
		bool vReturn;, )\
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
	\
			CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
					vReturn = , return) pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPush(pThis, ((pELEMENT_TYPE *)vElement)); \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
	\
				CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						vReturn = , return) pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPush(pThis, ((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				return pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPush(pThis, ((pELEMENT_TYPE *)pElement)); \
			) \
		) \
	\
		CRXM__IFELSE(CRXM__AND(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
				CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR))) \
		( \
			if(vReturn) \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
			} \
			else \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
				pFUNC_ELEMENT_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
			} \
	\
			return vReturn; \
		)() \
	}, ) \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPush(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE * pElement) \
	{ \
		assert(pThis->gPrivate_capacity > pThis->gPrivate_length); \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_buffer + ((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), \
							pElement, sizeof(pELEMENT_TYPE)); \
				) \
			} \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement); \
			) \
			( \
				memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement, \
						sizeof(pELEMENT_TYPE)); \
			) \
		) \
	\
		pThis->gPrivate_length = pThis->gPrivate_length + 1; \
	} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastPush(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE const * pElement) \
	{ \
		CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
		unsigned char * vElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
			pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPush(pThis, ((pELEMENT_TYPE *)vElement)); \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPush(pThis, ((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPush(pThis, ((pELEMENT_TYPE *)pElement)); \
			) \
		) \
	\
		CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
						CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
	}, ) \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundPush(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE * pElement) \
	{ \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
	\
		if(pThis->gPrivate_capacity == 0) \
			{return;} \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
				if(pThis->gPrivate_length == pThis->gPrivate_capacity) \
					{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + pThis->gPrivate_startIndex);}, ) \
	\
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
				if(pThis->gPrivate_length == pThis->gPrivate_capacity) \
					{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_buffer + pThis->gPrivate_startIndex);}, ) \
	\
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			} \
		) \
		( \
			CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
			if(pThis->gPrivate_length == pThis->gPrivate_capacity) \
				{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + pThis->gPrivate_startIndex);}, ) \
	\
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement); \
			) \
			( \
				memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1)), pElement, \
						sizeof(pELEMENT_TYPE)); \
			) \
		) \
	\
		if(pThis->gPrivate_length != pThis->gPrivate_capacity) \
			{pThis->gPrivate_length = pThis->gPrivate_length + 1;} \
		else \
		{ \
			if(pThis->gPrivate_startIndex == pThis->gPrivate_capacity - 1) \
				{pThis->gPrivate_startIndex = 0;} \
			else \
				{pThis->gPrivate_startIndex = pThis->gPrivate_startIndex + 1;} \
		} \
	} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundPush(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE const * pElement) \
	{ \
		CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
		unsigned char * vElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
			pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundPush(pThis, ((pELEMENT_TYPE *)vElement)); \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundPush(pThis, ((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundPush(pThis, ((pELEMENT_TYPE *)pElement)); \
			) \
		) \
	\
		CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
						CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## push2(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE pElement) \
	{ \
		CRXM__IFELSE(pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
		( \
			if(pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPush(pThis, &pElement)) \
			{ \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(&pElement); \
	\
				return true; \
			} \
			else \
				{return false;} \
		) \
		( \
			return pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPush(pThis, &pElement); \
		) \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastPush2(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE pElement) \
	{ \
		pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPush(pThis, &pElement); \
	\
		CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_DESTRUCTOR(&pElement);, ) \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundPush2(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE pElement) \
	{ \
		pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundPush(pThis, &pElement); \
	\
		CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_DESTRUCTOR(&pElement);, ) \
	}, ) \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## pop(pARRAY_TYPE_NAME * pThis) \
	{ \
		assert(pThis->gPrivate_length > 0); \
	\
		pThis->gPrivate_length--; \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
			( \
				if(pThis->gPrivate_externalBuffer != NULL) \
				{ \
					if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, pThis->gPrivate_externalBuffer->gCount == 1, true)) \
					{ \
						pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
								((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1))); \
					} \
				} \
				else \
				{ \
					pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1))); \
				} \
			)()\
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
			( \
				if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, pThis->gPrivate_externalBuffer->gCount == 1, true)) \
				{ \
					pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pThis->gPrivate_length) & (pThis->gPrivate_capacity - 1))); \
				} \
			)() \
		) \
	} \
	\
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPushToFront(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE * pElement) \
	{ \
		bool vIsNoError = true; \
	 \
		if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, true, pThis->gPrivate_length + 1 > pThis->gPrivate_capacity)) \
			{vIsNoError = pARRAY_MEMBER_FUNCTIONS_PREFIX ## ensureCapacity(pThis, pThis->gPrivate_length + 1);} \
	\
		if(vIsNoError) \
		{ \
			if(pThis->gPrivate_startIndex == 0) \
				{pThis->gPrivate_startIndex = pThis->gPrivate_capacity - 1;} \
			else \
				{pThis->gPrivate_startIndex = pThis->gPrivate_startIndex - 1;} \
	\
			CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
			( \
				if(pThis->gPrivate_externalBuffer != NULL) \
				{ \
					CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
					( \
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
								(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement); \
					) \
					( \
						memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
								(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement, \
								sizeof(pELEMENT_TYPE)); \
					) \
				} \
				else \
				{ \
					CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
					( \
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_buffer + \
								(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement); \
					) \
					( \
						memcpy(pThis->gPrivate_buffer + (pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement, \
								sizeof(pELEMENT_TYPE)); \
					) \
				} \
			) \
			( \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			) \
	\
			pThis->gPrivate_length = pThis->gPrivate_length + 1; \
	\
			return true; \
		} \
		else \
			{return false;} \
	} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## pushToFront(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE const * pElement) \
	{ \
		CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
		unsigned char * vElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
		CRXM__IFELSE2(CRXM__AND(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
				CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
		bool vReturn;, )\
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
	\
			CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
					vReturn = , return) pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPushToFront(pThis, ((pELEMENT_TYPE *)vElement)); \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
	\
				CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
					vReturn = , return) pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPushToFront(pThis, ((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				return pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPushToFront(pThis, ((pELEMENT_TYPE *)pElement)); \
			) \
		) \
	\
		CRXM__IFELSE(CRXM__AND(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
				CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR))) \
		( \
			if(vReturn) \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
			} \
			else \
			{ \
				CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR, \
				pFUNC_ELEMENT_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
			} \
	\
			return vReturn; \
		)() \
	}, ) \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPushToFront(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE * pElement) \
	{ \
		assert(pThis->gPrivate_capacity > pThis->gPrivate_length); \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
	\
		if(pThis->gPrivate_startIndex == 0) \
			{pThis->gPrivate_startIndex = pThis->gPrivate_capacity - 1;} \
		else \
			{pThis->gPrivate_startIndex = pThis->gPrivate_startIndex - 1;} \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_buffer + \
							(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_buffer + \
							(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			} \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement); \
			) \
			( \
				memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement, sizeof(pELEMENT_TYPE)); \
			) \
		) \
	\
		pThis->gPrivate_length = pThis->gPrivate_length + 1; \
	} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastPushToFront(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE const * pElement) \
	{ \
		CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
		unsigned char * vElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
			pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPushToFront(pThis, ((pELEMENT_TYPE *)vElement)); \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPushToFront(pThis, ((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPushToFront(pThis, ((pELEMENT_TYPE *)pElement)); \
			) \
		) \
	\
		CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
						CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
	}, ) \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundPushToFront(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE * pElement) \
	{ \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
	\
		if(pThis->gPrivate_capacity == 0) \
			{return;} \
	\
		if(pThis->gPrivate_startIndex == 0) \
			{pThis->gPrivate_startIndex = pThis->gPrivate_capacity - 1;} \
		else \
			{pThis->gPrivate_startIndex = pThis->gPrivate_startIndex - 1;} \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
				if(pThis->gPrivate_length == pThis->gPrivate_capacity) \
				{ \
					pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1))); \
				}, ) \
	\
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
				if(pThis->gPrivate_length == pThis->gPrivate_capacity) \
					{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_buffer + (pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)));}, ) \
	\
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_buffer + \
							(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_buffer + \
							(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			} \
		) \
		( \
			CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
			if(pThis->gPrivate_length == pThis->gPrivate_capacity) \
			{ \
				pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1))); \
			}, ) \
	\
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement); \
			) \
			( \
				memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						(pThis->gPrivate_startIndex & (pThis->gPrivate_capacity - 1)), pElement, \
						sizeof(pELEMENT_TYPE)); \
			) \
		) \
	\
		if(pThis->gPrivate_length != pThis->gPrivate_capacity) \
			{pThis->gPrivate_length = pThis->gPrivate_length + 1;} \
	} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundPushToFront(pARRAY_TYPE_NAME * pThis, \
			pELEMENT_TYPE const * pElement) \
	{ \
		CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
		unsigned char * vElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
			pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundPushToFront(pThis, ((pELEMENT_TYPE *)vElement)); \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundPushToFront(pThis, ((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundPushToFront(pThis, ((pELEMENT_TYPE *)pElement)); \
			) \
		) \
	\
		CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
						CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## pushToFront2(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE pElement) \
	{ \
		CRXM__IFELSE(pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
		( \
			if(pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPushToFront(pThis, &pElement)) \
			{ \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(&pElement); \
	\
				return true; \
			} \
			else \
				{return false;} \
		) \
		( \
			return pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndPushToFront(pThis, &pElement); \
		) \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastPushToFront2(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE pElement) \
	{ \
		pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastPushToFront(pThis, &pElement); \
	\
		CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_DESTRUCTOR(&pElement);, ) \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundPushToFront2(pARRAY_TYPE_NAME * pThis, pELEMENT_TYPE pElement) \
	{ \
		pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundPushToFront(pThis, &pElement); \
	\
		CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_DESTRUCTOR(&pElement);, ) \
	}, ) \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## popFromFront(pARRAY_TYPE_NAME * pThis) \
	{ \
		assert(pThis->gPrivate_length > 0); \
	\
		size_t vIndexOfReturn = pThis->gPrivate_startIndex; \
	\
		pThis->gPrivate_length--; \
	\
		if(pThis->gPrivate_startIndex == pThis->gPrivate_capacity - 1) \
			{pThis->gPrivate_startIndex = 0;} \
		else \
			{pThis->gPrivate_startIndex = pThis->gPrivate_startIndex + 1;} \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
			( \
				if(pThis->gPrivate_externalBuffer != NULL) \
				{ \
					if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, pThis->gPrivate_externalBuffer->gCount == 1, true)) \
					{ \
						pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
								(vIndexOfReturn & (pThis->gPrivate_capacity - 1))); \
					} \
				} \
				else \
					{pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_buffer + (vIndexOfReturn & (pThis->gPrivate_capacity - 1)));} \
			)() \
		) \
		( \
			if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, pThis->gPrivate_externalBuffer->gCount == 1, true)) \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
						pFUNC_ELEMENT_DESTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + (vIndexOfReturn & (pThis->gPrivate_capacity - 1)));, ) \
			} \
		) \
	} \
	\
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndInsertElementAt(pARRAY_TYPE_NAME * pThis, \
			size_t pIndex, pELEMENT_TYPE * pElement) \
	{ \
		assert(pIndex <= pSIZE_T_MAX); \
	\
		if(pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_insertSpaceAt(pThis, pIndex, 1)) \
		{ \
			CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
			( \
				if(pThis->gPrivate_externalBuffer != NULL) \
				{ \
					CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
					( \
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
								((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement); \
					) \
					( \
						memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
								((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement, \
								sizeof(pELEMENT_TYPE)); \
					) \
				} \
				else \
				{ \
					CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
					( \
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_buffer + \
								((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement); \
					) \
					( \
						memcpy(pThis->gPrivate_buffer + \
								((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement, \
								sizeof(pELEMENT_TYPE)); \
					) \
				} \
			) \
			( \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			) \
	\
			return true; \
		} \
		else \
			{return false;} \
	} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertElementAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * pElement) \
	{ \
		CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
		unsigned char * vElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
		CRXM__IFELSE2(CRXM__AND(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
				CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
		bool vReturn;, )\
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
	\
			CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
					vReturn = , return) pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndInsertElementAt( \
							pThis, pIndex, ((pELEMENT_TYPE *)vElement)); \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
	\
				CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
					vReturn = , return) pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndInsertElementAt( \
							pThis, pIndex, ((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				return pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndInsertElementAt( \
						pThis, pIndex, ((pELEMENT_TYPE *)pElement)); \
			) \
		) \
	\
		CRXM__IFELSE(CRXM__AND(CRXM__OR(pFUNC_ELEMENT_DESTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
				CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR))) \
		( \
			if(vReturn) \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
			} \
			else \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
				pFUNC_ELEMENT_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
			} \
	\
			return vReturn; \
		)() \
	}, ) \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastInsertElementAt( \
			pARRAY_TYPE_NAME * pThis, size_t pIndex, pELEMENT_TYPE * pElement) \
	{ \
		assert(pIndex <= pSIZE_T_MAX); \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
	\
		pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_fastInsertSpaceAt(pThis, pIndex, 1);\
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				)\
			} \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement); \
			) \
			( \
				memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1)), pElement, \
						sizeof(pELEMENT_TYPE)); \
			) \
		) \
	} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertElementAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * pElement) \
	{ \
		CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
		unsigned char * vElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
			pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastInsertElementAt(pThis, pIndex, ((pELEMENT_TYPE *)vElement)); \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastInsertElementAt(pThis, pIndex, ((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastInsertElementAt(pThis, pIndex, ((pELEMENT_TYPE *)pElement)); \
			) \
		) \
	\
		CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
						CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
	}, ) \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundInsertElementAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE * pElement) \
	{ \
		assert(pIndex <= pSIZE_T_MAX); \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
	\
		Crx_C_Ring_Private_IndexTransform vIndexTransform = \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_roundInsertSpaceAt(pThis, pIndex, 1); \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + vIndexTransform.gNewIndex) & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + vIndexTransform.gNewIndex) & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + vIndexTransform.gNewIndex) & (pThis->gPrivate_capacity - 1)), pElement); \
				) \
				( \
					memcpy(pThis->gPrivate_buffer + \
							((pThis->gPrivate_startIndex + vIndexTransform.gNewIndex) & (pThis->gPrivate_capacity - 1)), pElement, \
							sizeof(pELEMENT_TYPE)); \
				) \
			} \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + vIndexTransform.gNewIndex) & (pThis->gPrivate_capacity - 1)), pElement); \
			) \
			( \
				memcpy(pThis->gPrivate_externalBuffer->gPrivate_buffer + \
						((pThis->gPrivate_startIndex + vIndexTransform.gNewIndex) & (pThis->gPrivate_capacity - 1)), pElement, \
						sizeof(pELEMENT_TYPE)); \
			) \
		) \
	} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertElementAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * pElement) \
	{ \
		CRXM__IFELSE2(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
		unsigned char * vElement = (unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE));, ) \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
			pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundInsertElementAt(pThis, pIndex, ((pELEMENT_TYPE *)vElement)); \
		) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundInsertElementAt(pThis, pIndex, ((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundInsertElementAt(pThis, pIndex, ((pELEMENT_TYPE *)pElement)); \
			) \
		) \
	\
		CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
						CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
	}, ) \
	\
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertElementAt2(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE pElement) \
	{ \
		CRXM__IFELSE(pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
		( \
			if(pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndInsertElementAt(pThis, pIndex, \
					&pElement)) \
			{ \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(&pElement); \
	\
				return true; \
			} \
			else \
				{return false;} \
		) \
		( \
			return pARRAY_MEMBER_FUNCTIONS_PREFIX ## tryMoveAndInsertElementAt(pThis, pIndex, \
					&pElement); \
		) \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertElementAt2(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE pElement) \
	{ \
		pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndFastInsertElementAt(pThis, pIndex, &pElement); \
	\
		CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_DESTRUCTOR(&pElement);, ) \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertElementAt2(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE pElement) \
	{ \
		pARRAY_MEMBER_FUNCTIONS_PREFIX ## moveAndRoundInsertElementAt(pThis, pIndex, &pElement); \
	\
		CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_DESTRUCTOR(&pElement);, ) \
	}, ) \
	\
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertElementsAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pARRAY_TYPE_NAME const * pArray, size_t pStartIndex, size_t pWidth) \
	{ \
		CRX_SCOPE_META \
		assert(pIndex <= pSIZE_T_MAX); \
		assert(pStartIndex <= pSIZE_T_MAX); \
		assert(pWidth <= pSIZE_T_MAX); \
	\
		if(pWidth == 0) \
			{return true;} \
	\
		CRX_SCOPE \
		pARRAY_TYPE_NAME * vArray = ((pARRAY_TYPE_NAME *)pArray); \
		bool vIsSameArray = CRX__ARE_POINTERS_TO_SAME_OBJECT(pThis, pArray, true); \
		bool vReturn = false; \
	\
		if(vIsSameArray) \
		{ \
			CRXM__IFELSE(CRX__ARE_ONLY_POINTERS_TO_SAME_OBJECT_EQUAL_AND_ALWAYS) \
			( \
				if((pStartIndex == 0) && (pWidth == pThis->gPrivate_length)) \
					{return true;} \
			)() \
	\
			vArray = pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_new2(pArray, pStartIndex, pWidth); \
		} \
	\
		if(vArray != NULL) \
		{ \
			/*WARNING: THE CODE BELOW DOES NOT FOLLOW THE FORMAT OF THE REST OF THE CODE.*/ \
			if(CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
					!vArray->gPrivate_isThreadPossible && !pThis->gPrivate_isThreadPossible && \
					(vArray->gPrivate_externalBuffer != NULL) && (pThis->gPrivate_length == 0) && \
					CRXM__IFELSE2(CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR), \
					true, ((pStartIndex == 0) && (pWidth == vArray->gPrivate_length))), false))\
			{ \
				/*NOTE: THE CHECK BELOW IS JUST IN CASE THE COMPILER DOES NOT OPTIMIZE THE CODE AWAY WHEN NEEDED.*/ \
				CRXM__IFELSE(pIS_TO_ENABLE_COPY_ON_RIGHT) \
				( \
					if(pThis->gPrivate_externalBuffer != NULL) \
					{ \
						if(pThis->gPrivate_externalBuffer->gCount > 1) \
							{pThis->gPrivate_externalBuffer->gCount--;} \
						else \
							{free(pThis->gPrivate_externalBuffer);} \
					} \
	\
					vArray->gPrivate_externalBuffer->gCount++; \
	\
					pThis->gPrivate_externalBuffer = vArray->gPrivate_externalBuffer; \
					pThis->gPrivate_startIndex = (vArray->gPrivate_startIndex + pStartIndex) & \
							(pThis->gPrivate_capacity - 1); \
					pThis->gPrivate_capacity = vArray->gPrivate_capacity; \
					pThis->gPrivate_length = ((pSIZE_T)pWidth); \
				)() \
	\
				/**/ \
				vReturn = true; \
			} \
			else \
			{ \
				if(pWidth == 0) \
					{return true;} \
	\
				if(pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_insertSpaceAt(pThis, pIndex, pWidth)) \
				{ \
					CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
					( \
						pELEMENT_TYPE * tTarget; \
						pELEMENT_TYPE * tSource; \
	\
						if(pThis->gPrivate_externalBuffer != NULL) \
							{tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
						else \
							{tTarget = pThis->gPrivate_buffer;} \
	\
						if(vArray->gPrivate_externalBuffer != NULL) \
							{tSource = vArray->gPrivate_externalBuffer->gPrivate_buffer;} \
						else \
							{tSource = vArray->gPrivate_buffer;} \
	\
						CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
								tTarget, pThis->gPrivate_startIndex, pThis->gPrivate_capacity, pIndex, \
								tSource, vArray->gPrivate_startIndex, vArray->gPrivate_capacity, \
								pStartIndex, pWidth) \
					) \
					( \
						CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
								pThis->gPrivate_externalBuffer->gPrivate_buffer, pThis->gPrivate_startIndex, pThis->gPrivate_capacity, pIndex, \
								vArray->gPrivate_externalBuffer->gPrivate_buffer, vArray->gPrivate_startIndex, vArray->gPrivate_capacity, \
								pStartIndex, pWidth) \
					) \
	\
					vReturn = true; \
				} \
			} \
	\
			if(vIsSameArray) \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## destruct(vArray);, ) \
				free(vArray); \
			} \
		} \
	\
		return vReturn; \
		CRX_SCOPE_END \
	}, ) \
	\
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertElementsAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pARRAY_TYPE_NAME const * pArray, size_t pStartIndex, size_t pWidth) \
	{ \
		CRX_SCOPE_META \
		assert(pIndex <= pSIZE_T_MAX); \
		assert(pStartIndex <= pSIZE_T_MAX); \
		assert(pWidth <= pSIZE_T_MAX); \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
		assert(!CRX__ARE_POINTERS_TO_SAME_OBJECT(pThis, pArray, false)); \
	\
		if(pWidth == 0) \
			{return;} \
	\
		CRX_SCOPE \
		CRXM__IFELSE2(pHAS_INTERNAL_BUFFER, \
		pELEMENT_TYPE * tTarget;, ) \
		CRXM__IFELSE2(pHAS_INTERNAL_BUFFER, \
		pELEMENT_TYPE const * tSource;, ) \
	\
		pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_fastInsertSpaceAt(pThis, pIndex, pWidth);\
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
				{tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
			else \
				{tTarget = pThis->gPrivate_buffer;} \
	\
			if(pArray->gPrivate_externalBuffer != NULL) \
				{tSource = pArray->gPrivate_externalBuffer->gPrivate_buffer;} \
			else \
				{tSource = pArray->gPrivate_buffer;} \
	\
			CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
					tTarget, pThis->gPrivate_startIndex, pThis->gPrivate_capacity, pIndex, \
					tSource, pArray->gPrivate_startIndex, pArray->gPrivate_capacity, \
					pStartIndex, pWidth) \
		) \
		( \
			CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
					pThis->gPrivate_externalBuffer->gPrivate_buffer, pThis->gPrivate_startIndex, pThis->gPrivate_capacity, pIndex, \
					pArray->gPrivate_externalBuffer->gPrivate_buffer, pArray->gPrivate_startIndex, pArray->gPrivate_capacity, \
					pStartIndex, pWidth) \
		) \
		CRX_SCOPE_END \
	}, ) \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertElementsAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pARRAY_TYPE_NAME const * pArray, size_t pStartIndex, size_t pWidth) \
	{ \
		CRX_SCOPE_META \
		assert(pIndex <= pSIZE_T_MAX); \
		assert(pStartIndex <= pSIZE_T_MAX); \
		assert(pWidth <= pSIZE_T_MAX); \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
		assert(!CRX__ARE_POINTERS_TO_SAME_OBJECT(pThis, pArray, false)); \
	\
		if(pWidth == 0) \
			{return;} \
	\
		CRX_SCOPE \
		CRXM__IFELSE2(pHAS_INTERNAL_BUFFER, \
		pELEMENT_TYPE * tTarget;, ) \
		CRXM__IFELSE2(pHAS_INTERNAL_BUFFER, \
		pELEMENT_TYPE const * tSource;, ) \
		Crx_C_Ring_Private_IndexTransform vIndexTransform = \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_roundInsertSpaceAt(pThis, pIndex, pWidth);\
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
				{tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
			else \
				{tTarget = pThis->gPrivate_buffer;} \
	\
			if(pArray->gPrivate_externalBuffer != NULL) \
				{tSource = pArray->gPrivate_externalBuffer->gPrivate_buffer;} \
			else \
				{tSource = pArray->gPrivate_buffer;} \
	\
			CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
					tTarget, pThis->gPrivate_startIndex, pThis->gPrivate_capacity, vIndexTransform.gNewIndex, \
					tSource, pArray->gPrivate_startIndex, pArray->gPrivate_capacity, pStartIndex, \
					vIndexTransform.gNewCountToEnd) \
		) \
		( \
			CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, \
					pThis->gPrivate_externalBuffer->gPrivate_buffer, pThis->gPrivate_startIndex, pThis->gPrivate_capacity, vIndexTransform.gNewIndex, \
					pArray->gPrivate_externalBuffer->gPrivate_buffer, pArray->gPrivate_startIndex, pArray->gPrivate_capacity, pStartIndex, \
					vIndexTransform.gNewCountToEnd) \
		) \
		CRX_SCOPE_END \
	}, ) \
	\
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertCArrayAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * pArray, size_t pWidth) \
	{ \
		assert(pIndex <= pSIZE_T_MAX); \
		assert(pWidth <= pSIZE_T_MAX); \
	\
		if(pWidth == 0) \
			{return true;} \
	\
		if(pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_insertSpaceAt(pThis, pIndex, pWidth)) \
		{ \
			CRXM__IFELSE2(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			size_t tInsertIndex = (pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1);, ) \
			pELEMENT_TYPE * tTarget; \
	\
			CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
			( \
				if(pThis->gPrivate_externalBuffer != NULL) \
					{tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
				else \
					{tTarget = pThis->gPrivate_buffer;} \
			) \
			( \
				tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer; \
			) \
	\
			CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
			( \
				for(size_t tI = 0; tI < pWidth; tI++) \
				{ \
					pFUNC_ELEMENT_COPY_CONSTRUCTOR(tTarget + ((pThis->gPrivate_startIndex + pIndex + tI) & (pThis->gPrivate_capacity - 1)), \
							pArray + tI); \
				} \
			) \
			( \
				if((tInsertIndex < ((pThis->gPrivate_startIndex + pIndex + pWidth - 1) & (pThis->gPrivate_capacity - 1))) || \
						((pThis->gPrivate_capacity - tInsertIndex) >= pWidth)) \
					{memcpy(tTarget + tInsertIndex, pArray, pWidth * sizeof(pELEMENT_TYPE));} \
				else \
				{ \
					memcpy(tTarget + tInsertIndex, pArray, \
							(pThis->gPrivate_capacity - tInsertIndex) * sizeof(pELEMENT_TYPE)); \
					memcpy(tTarget, pArray + pThis->gPrivate_capacity - tInsertIndex, \
							(pWidth - (pThis->gPrivate_capacity - tInsertIndex)) * sizeof(pELEMENT_TYPE)); \
				} \
			) \
	\
			return true; \
		} \
		else \
			{return false;} \
	}, ) \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertCArrayAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * pArray, size_t pWidth) \
	{ \
		CRX_SCOPE_META \
		assert(pIndex <= pSIZE_T_MAX); \
		assert(pWidth <= pSIZE_T_MAX); \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
	\
		if(pWidth == 0) \
			{return;} \
	\
		CRX_SCOPE \
		CRXM__IFELSE2(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
		size_t vInsertIndex;, ) \
		pELEMENT_TYPE * vTarget; \
	\
		pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_fastInsertSpaceAt(pThis, pIndex, pWidth);\
	\
		CRXM__IFELSE2(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
		vInsertIndex = (pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1);, ) \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
				{vTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
			else \
				{vTarget = pThis->gPrivate_buffer;} \
		) \
		( \
			vTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer; \
		) \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			for(size_t tI = 0; tI < pWidth; tI++) \
			{ \
				pFUNC_ELEMENT_COPY_CONSTRUCTOR(vTarget + ((pThis->gPrivate_startIndex + pIndex + tI) & (pThis->gPrivate_capacity - 1)), \
						pArray + tI); \
			} \
		) \
		( \
			if((vInsertIndex < ((pThis->gPrivate_startIndex + pIndex + pWidth - 1) & (pThis->gPrivate_capacity - 1))) || \
					((pThis->gPrivate_capacity - vInsertIndex) >= pWidth)) \
				{memcpy(vTarget + vInsertIndex, pArray, pWidth * sizeof(pELEMENT_TYPE));} \
			else \
			{ \
				memcpy(vTarget + vInsertIndex, pArray, \
						(pThis->gPrivate_capacity - vInsertIndex) * sizeof(pELEMENT_TYPE)); \
				memcpy(vTarget, pArray + pThis->gPrivate_capacity - vInsertIndex, \
						(pWidth - (pThis->gPrivate_capacity - vInsertIndex)) * sizeof(pELEMENT_TYPE)); \
			} \
		) \
		CRX_SCOPE_END \
	}, ) \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertCArrayAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * pArray, size_t pWidth) \
	{ \
		CRX_SCOPE_META \
		assert(pIndex <= pSIZE_T_MAX); \
		assert(pWidth <= pSIZE_T_MAX); \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
	\
		if(pWidth == 0) \
			{return;} \
	\
		CRX_SCOPE \
		Crx_C_Ring_Private_IndexTransform vIndexTransform = \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_roundInsertSpaceAt(pThis, pIndex, pWidth);\
		CRXM__IFELSE2(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
		size_t vInsertIndex = (pThis->gPrivate_startIndex + vIndexTransform.gNewIndex) & (pThis->gPrivate_capacity - 1);, ) \
		pELEMENT_TYPE * vTarget; \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
				{vTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
			else \
				{vTarget = pThis->gPrivate_buffer;} \
		) \
		( \
			vTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer; \
		) \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			for(size_t tI = 0; tI < vIndexTransform.gNewCountToEnd; tI++) \
			{ \
				pFUNC_ELEMENT_COPY_CONSTRUCTOR(vTarget + \
								((pThis->gPrivate_startIndex + vIndexTransform.gNewIndex + tI) & \
								(pThis->gPrivate_capacity - 1)), \
						pArray + tI); \
			} \
		) \
		( \
			if((vInsertIndex < ((pThis->gPrivate_startIndex + vIndexTransform.gNewIndex + \
							vIndexTransform.gNewCountToEnd - 1) & (pThis->gPrivate_capacity - 1))) || \
					((pThis->gPrivate_capacity - vInsertIndex) >= vIndexTransform.gNewCountToEnd)) \
			{ \
				memcpy(vTarget + vInsertIndex, pArray, \
						vIndexTransform.gNewCountToEnd * sizeof(pELEMENT_TYPE)); \
			} \
			else \
			{ \
				memcpy(vTarget + vInsertIndex, pArray, \
						(pThis->gPrivate_capacity - vInsertIndex) * sizeof(pELEMENT_TYPE)); \
				memcpy(vTarget, pArray + pThis->gPrivate_capacity - vInsertIndex, \
						(vIndexTransform.gNewCountToEnd - (pThis->gPrivate_capacity - vInsertIndex)) * sizeof(pELEMENT_TYPE)); \
			} \
		) \
		CRX_SCOPE_END \
	}, ) \
	\
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertElementCopiesAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * pElement, size_t pNumberOfCopies) \
	{ \
		assert(pIndex <= pSIZE_T_MAX); \
		assert(pNumberOfCopies <= pSIZE_T_MAX); \
	\
		if(pNumberOfCopies == 0) \
			{return true;} \
	\
		if(pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_insertSpaceAt(pThis, pIndex, pNumberOfCopies)) \
		{ \
			CRXM__IFELSE2(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			size_t tInsertIndex = (pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1);, ) \
			pELEMENT_TYPE * tTarget; \
	\
			CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
			( \
				if(pThis->gPrivate_externalBuffer != NULL) \
					{tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
				else \
					{tTarget = pThis->gPrivate_buffer;} \
			) \
			( \
				tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer; \
			) \
	\
			CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
			( \
				for(size_t tI = 0; tI < pNumberOfCopies; tI++) \
				{ \
					pFUNC_ELEMENT_COPY_CONSTRUCTOR(tTarget + ((pThis->gPrivate_startIndex + pIndex + tI) & (pThis->gPrivate_capacity - 1)), \
							pElement); \
				} \
			) \
			( \
				if((tInsertIndex < ((pThis->gPrivate_startIndex + pIndex + pNumberOfCopies - 1) & (pThis->gPrivate_capacity - 1))) || \
						((pThis->gPrivate_capacity - tInsertIndex) >= pNumberOfCopies)) \
				{ \
					size_t tNumberOfCopies = 1; \
					size_t tRemainingNumberOfCopies = pNumberOfCopies - 1; \
	\
					memcpy(tTarget + tInsertIndex, pElement, sizeof(pELEMENT_TYPE));\
	\
					while(tRemainingNumberOfCopies > 0) \
					{ \
						if(tRemainingNumberOfCopies >= tNumberOfCopies) \
						{ \
							memcpy(tTarget + tInsertIndex + tNumberOfCopies, tTarget + tInsertIndex, \
									tNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
							tRemainingNumberOfCopies = tRemainingNumberOfCopies - tNumberOfCopies; \
							tNumberOfCopies = (tNumberOfCopies << 1); \
						} \
						else \
						{ \
							memcpy(tTarget + tInsertIndex + tNumberOfCopies, tTarget + tInsertIndex, \
									tRemainingNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
							break; \
						} \
					} \
				} \
				else \
				{ \
					size_t tNumberOfCopies = 1; \
					size_t tRemainingNumberOfCopies = pThis->gPrivate_capacity - tInsertIndex - 1; \
	\
					memcpy(tTarget + tInsertIndex, pElement, sizeof(pELEMENT_TYPE));\
	\
					while(tRemainingNumberOfCopies > 0) \
					{ \
						if(tRemainingNumberOfCopies >= tNumberOfCopies) \
						{ \
							memcpy(tTarget + tInsertIndex + tNumberOfCopies, tTarget + tInsertIndex, \
									tNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
							tRemainingNumberOfCopies = tRemainingNumberOfCopies - tNumberOfCopies; \
							tNumberOfCopies = (tNumberOfCopies << 1); \
						} \
						else \
						{ \
							memcpy(tTarget + tInsertIndex + tNumberOfCopies, tTarget + tInsertIndex, \
									tRemainingNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
							break; \
						} \
					} \
	\
					tRemainingNumberOfCopies = pNumberOfCopies - (pThis->gPrivate_capacity - tInsertIndex); \
	\
					if(tRemainingNumberOfCopies > pThis->gPrivate_capacity - tInsertIndex) \
					{ \
						tNumberOfCopies = pThis->gPrivate_capacity - tInsertIndex; \
	\
						memcpy(tTarget, tTarget + tInsertIndex, tNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
						tRemainingNumberOfCopies = tRemainingNumberOfCopies - tNumberOfCopies; \
	\
						while(tRemainingNumberOfCopies > 0) \
						{ \
							if(tRemainingNumberOfCopies >= tNumberOfCopies) \
							{ \
								memcpy(tTarget + tNumberOfCopies, tTarget, tNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
								tRemainingNumberOfCopies = tRemainingNumberOfCopies - tNumberOfCopies; \
								tNumberOfCopies = (tNumberOfCopies << 1); \
							} \
							else \
							{ \
								memcpy(tTarget + tNumberOfCopies, tTarget, tRemainingNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
								break; \
							} \
						} \
					} \
					else \
						{memcpy(tTarget, tTarget + tInsertIndex, tRemainingNumberOfCopies * sizeof(pELEMENT_TYPE));} \
	\
				} \
			) \
	\
			return true; \
		} \
		else \
			{return false;} \
	}, ) \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertElementCopiesAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * pElement, size_t pNumberOfCopies) \
	{ \
		CRX_SCOPE_META \
		assert(pIndex <= pSIZE_T_MAX); \
		assert(pNumberOfCopies <= pSIZE_T_MAX); \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
	\
		if(pNumberOfCopies == 0) \
			{return;} \
	\
		CRX_SCOPE \
		CRXM__IFELSE2(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
		size_t tInsertIndex = (pThis->gPrivate_startIndex + pIndex) & (pThis->gPrivate_capacity - 1);, ) \
		pELEMENT_TYPE * tTarget; \
	\
		pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_fastInsertSpaceAt(pThis, pIndex, pNumberOfCopies); \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
				{tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
			else \
				{tTarget = pThis->gPrivate_buffer;} \
		) \
		( \
			tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer; \
		) \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			for(size_t tI = 0; tI < pNumberOfCopies; tI++) \
			{ \
				pFUNC_ELEMENT_COPY_CONSTRUCTOR(tTarget + ((pThis->gPrivate_startIndex + pIndex + tI) & (pThis->gPrivate_capacity - 1)), \
						pElement); \
			} \
		) \
		( \
			if((tInsertIndex < ((pThis->gPrivate_startIndex + pIndex + pNumberOfCopies - 1) & (pThis->gPrivate_capacity - 1))) || \
					((pThis->gPrivate_capacity - tInsertIndex) >= pNumberOfCopies)) \
			{ \
				size_t tNumberOfCopies = 1; \
				size_t tRemainingNumberOfCopies = pNumberOfCopies - 1; \
	\
				memcpy(tTarget + tInsertIndex, pElement, sizeof(pELEMENT_TYPE));\
	\
				while(tRemainingNumberOfCopies > 0) \
				{ \
					if(tRemainingNumberOfCopies >= tNumberOfCopies) \
					{ \
						memcpy(tTarget + tInsertIndex + tNumberOfCopies, tTarget + tInsertIndex, \
								tNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
						tRemainingNumberOfCopies = tRemainingNumberOfCopies - tNumberOfCopies; \
						tNumberOfCopies = (tNumberOfCopies << 1); \
					} \
					else \
					{ \
						memcpy(tTarget + tInsertIndex + tNumberOfCopies, tTarget + tInsertIndex, \
								tRemainingNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
						break; \
					} \
				} \
			} \
			else \
			{ \
				size_t tNumberOfCopies = 1; \
				size_t tRemainingNumberOfCopies = pThis->gPrivate_capacity - tInsertIndex - 1; \
	\
				memcpy(tTarget + tInsertIndex, pElement, sizeof(pELEMENT_TYPE));\
	\
				while(tRemainingNumberOfCopies > 0) \
				{ \
					if(tRemainingNumberOfCopies >= tNumberOfCopies) \
					{ \
						memcpy(tTarget + tInsertIndex + tNumberOfCopies, tTarget + tInsertIndex, \
								tNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
						tRemainingNumberOfCopies = tRemainingNumberOfCopies - tNumberOfCopies; \
						tNumberOfCopies = (tNumberOfCopies << 1); \
					} \
					else \
					{ \
						memcpy(tTarget + tInsertIndex + tNumberOfCopies, tTarget + tInsertIndex, \
								tRemainingNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
						break; \
					} \
				} \
	\
				tRemainingNumberOfCopies = pNumberOfCopies - (pThis->gPrivate_capacity - tInsertIndex); \
	\
				if(tRemainingNumberOfCopies > pThis->gPrivate_capacity - tInsertIndex) \
				{ \
					tNumberOfCopies = pThis->gPrivate_capacity - tInsertIndex; \
	\
					memcpy(tTarget, tTarget + tInsertIndex, tNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
					tRemainingNumberOfCopies = tRemainingNumberOfCopies - tNumberOfCopies; \
	\
					while(tRemainingNumberOfCopies > 0) \
					{ \
						if(tRemainingNumberOfCopies >= tNumberOfCopies) \
						{ \
							memcpy(tTarget + tNumberOfCopies, tTarget, tNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
							tRemainingNumberOfCopies = tRemainingNumberOfCopies - tNumberOfCopies; \
							tNumberOfCopies = (tNumberOfCopies << 1); \
						} \
						else \
						{ \
							memcpy(tTarget + tNumberOfCopies, tTarget, tRemainingNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
							break; \
						} \
					} \
				} \
				else \
					{memcpy(tTarget, tTarget + tInsertIndex, tRemainingNumberOfCopies * sizeof(pELEMENT_TYPE));} \
	\
			} \
		) \
		CRX_SCOPE_END \
	}, ) \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertElementCopiesAt(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE const * pElement, size_t pNumberOfCopies) \
	{ \
		CRX_SCOPE_META \
		assert(pIndex <= pSIZE_T_MAX); \
		assert(pNumberOfCopies <= pSIZE_T_MAX); \
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		assert((pThis->gPrivate_externalBuffer == NULL) || (pThis->gPrivate_externalBuffer->gCount == 1));, ) \
	\
		if(pNumberOfCopies == 0) \
			{return;} \
	\
		CRX_SCOPE \
		Crx_C_Ring_Private_IndexTransform vIndexTransform = \
				pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_roundInsertSpaceAt(pThis, pIndex, pNumberOfCopies); \
		CRXM__IFELSE2(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
		size_t tInsertIndex = (pThis->gPrivate_startIndex + vIndexTransform.gNewIndex) & (pThis->gPrivate_capacity - 1);, ) \
		pELEMENT_TYPE * tTarget; \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
				{tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
			else \
				{tTarget = pThis->gPrivate_buffer;} \
		) \
		( \
			tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer; \
		) \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			for(size_t tI = 0; tI < vIndexTransform.gNewCountToEnd; tI++) \
			{ \
				pFUNC_ELEMENT_COPY_CONSTRUCTOR(tTarget + \
								((pThis->gPrivate_startIndex + vIndexTransform.gNewIndex + tI) & \
								(pThis->gPrivate_capacity - 1)), \
						pElement); \
			} \
		) \
		( \
			if((tInsertIndex < ((pThis->gPrivate_startIndex + vIndexTransform.gNewIndex + vIndexTransform.gNewCountToEnd - 1) & \
					(pThis->gPrivate_capacity - 1))) || \
					((pThis->gPrivate_capacity - tInsertIndex) >= vIndexTransform.gNewCountToEnd)) \
			{ \
				size_t tNumberOfCopies = 1; \
				size_t tRemainingNumberOfCopies = vIndexTransform.gNewCountToEnd - 1; \
	\
				memcpy(tTarget + tInsertIndex, pElement, sizeof(pELEMENT_TYPE));\
	\
				while(tRemainingNumberOfCopies > 0) \
				{ \
					if(tRemainingNumberOfCopies >= tNumberOfCopies) \
					{ \
						memcpy(tTarget + tInsertIndex + tNumberOfCopies, tTarget + tInsertIndex, \
								tNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
						tRemainingNumberOfCopies = tRemainingNumberOfCopies - tNumberOfCopies; \
						tNumberOfCopies = (tNumberOfCopies << 1); \
					} \
					else \
					{ \
						memcpy(tTarget + tInsertIndex + tNumberOfCopies, tTarget + tInsertIndex, \
								tRemainingNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
						break; \
					} \
				} \
			} \
			else \
			{ \
				size_t tNumberOfCopies = 1; \
				size_t tRemainingNumberOfCopies = pThis->gPrivate_capacity - tInsertIndex - 1; \
	\
				memcpy(tTarget + tInsertIndex, pElement, sizeof(pELEMENT_TYPE));\
	\
				while(tRemainingNumberOfCopies > 0) \
				{ \
					if(tRemainingNumberOfCopies >= tNumberOfCopies) \
					{ \
						memcpy(tTarget + tInsertIndex + tNumberOfCopies, tTarget + tInsertIndex, \
								tNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
						tRemainingNumberOfCopies = tRemainingNumberOfCopies - tNumberOfCopies; \
						tNumberOfCopies = (tNumberOfCopies << 1); \
					} \
					else \
					{ \
						memcpy(tTarget + tInsertIndex + tNumberOfCopies, tTarget + tInsertIndex, \
								tRemainingNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
						break; \
					} \
				} \
	\
				tRemainingNumberOfCopies = vIndexTransform.gNewCountToEnd - \
						(pThis->gPrivate_capacity - tInsertIndex); \
	\
				if(tRemainingNumberOfCopies > pThis->gPrivate_capacity - tInsertIndex) \
				{ \
					tNumberOfCopies = pThis->gPrivate_capacity - tInsertIndex; \
	\
					memcpy(tTarget, tTarget + tInsertIndex, tNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
					tRemainingNumberOfCopies = tRemainingNumberOfCopies - tNumberOfCopies; \
	\
					while(tRemainingNumberOfCopies > 0) \
					{ \
						if(tRemainingNumberOfCopies >= tNumberOfCopies) \
						{ \
							memcpy(tTarget + tNumberOfCopies, tTarget, \
									tNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
							tRemainingNumberOfCopies = tRemainingNumberOfCopies - tNumberOfCopies; \
							tNumberOfCopies = (tNumberOfCopies << 1); \
						} \
						else \
						{ \
							memcpy(tTarget + tNumberOfCopies, tTarget, \
									tRemainingNumberOfCopies * sizeof(pELEMENT_TYPE)); \
	\
							break; \
						} \
					} \
				} \
				else \
					{memcpy(tTarget, tTarget + tInsertIndex, tRemainingNumberOfCopies * sizeof(pELEMENT_TYPE));} \
	\
			} \
		) \
		CRX_SCOPE_END \
	}, ) \
	\
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertElementCopiesAt2(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE pElement, size_t pNumberOfCopies) \
	{ \
		return pARRAY_MEMBER_FUNCTIONS_PREFIX ## insertElementCopiesAt(pThis, pIndex, &pElement, pNumberOfCopies); \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertElementCopiesAt2(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE pElement, size_t pNumberOfCopies) \
	{ \
		pARRAY_MEMBER_FUNCTIONS_PREFIX ## fastInsertElementCopiesAt(pThis, pIndex, &pElement, pNumberOfCopies); \
	}, ) \
	CRXM__IFELSE2(CRXM__AND(pIS_COPYABLE, CRXM__AND(CRXM__NOT(pFUNC_ELEMENT_COPY_CONSTRUCTOR), \
			CRXM__NOT(pFUNC_ELEMENT_DESTRUCTOR))), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertElementCopiesAt2(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			pELEMENT_TYPE pElement, size_t pNumberOfCopies) \
	{ \
		pARRAY_MEMBER_FUNCTIONS_PREFIX ## roundInsertElementCopiesAt(pThis, pIndex, &pElement, pNumberOfCopies); \
	}, ) \
	\
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	PUBLIC bool pARRAY_MEMBER_FUNCTIONS_PREFIX ## removeElements(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			size_t pWidth), \
	PUBLIC void pARRAY_MEMBER_FUNCTIONS_PREFIX ## removeElements(pARRAY_TYPE_NAME * pThis, size_t pIndex, \
			size_t pWidth)) \
	{ \
		CRX_SCOPE_META \
		assert((pWidth == 0) || ((pIndex < pThis->gPrivate_length) && (pIndex + pWidth <= pThis->gPrivate_length))); \
	\
		if(pWidth == 0) \
			{return CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, true, );} \
	\
		CRXM__IFELSE(pIS_TO_ENABLE_COPY_ON_RIGHT) \
		( \
			if(!pARRAY_MEMBER_FUNCTIONS_PREFIX ## ensureCapacity(pThis, pThis->gPrivate_capacity) && \
					!pARRAY_MEMBER_FUNCTIONS_PREFIX ## ensureCapacity(pThis, pThis->gPrivate_length)) \
				{return false;} \
		)() \
	\
		CRX_SCOPE \
		pELEMENT_TYPE * tTarget; \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
				{tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
			else \
				{tTarget = pThis->gPrivate_buffer;} \
		) \
		( \
			tTarget = pThis->gPrivate_externalBuffer->gPrivate_buffer; \
		) \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
		( \
			pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_unsafeCallElementsDestruct(pThis, pIndex, \
					(((pIndex + pWidth) <= pThis->gPrivate_length) ? (pIndex + pWidth - 1) : pThis->gPrivate_length - 1)); \
		)() \
	\
		CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)) \
		( \
			CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
			( \
				if((pThis->gPrivate_length >> 1) > pIndex) \
				{ \
					for(size_t tI = 0; tI < pIndex; tI++) \
					{ \
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR(tTarget + \
										((pThis->gPrivate_startIndex + pIndex + pWidth - 1 - tI) & \
										(pThis->gPrivate_capacity - 1)), \
								tTarget + ((pThis->gPrivate_startIndex + pIndex - 1 - tI) & \
										(pThis->gPrivate_capacity - 1))); \
	\
						CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR(tTarget + \
								((pThis->gPrivate_startIndex + pIndex - 1 - tI) & (pThis->gPrivate_capacity - 1)));, ) \
					} \
	\
					pThis->gPrivate_startIndex = ((pSIZE_T)((pThis->gPrivate_startIndex + pWidth) & (pThis->gPrivate_capacity - 1))); \
				} \
				else \
				{ \
					for(size_t tI = 0 ; tI < pThis->gPrivate_length - pWidth - pIndex; tI++) \
					{ \
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR(tTarget + \
										((pThis->gPrivate_startIndex + tI + pIndex) & (pThis->gPrivate_capacity - 1)), \
								tTarget + ((pThis->gPrivate_startIndex + tI + pIndex + pWidth) & \
										(pThis->gPrivate_capacity - 1))); \
	\
						CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR(tTarget + \
								((pThis->gPrivate_startIndex + tI + pIndex + pWidth) & (pThis->gPrivate_capacity - 1)));, ) \
					} \
				} \
			) \
			( \
				if((pThis->gPrivate_length >> 1) > pIndex) \
				{ \
					for(size_t tI = 0; tI < pIndex; tI++) \
					{ \
						memmove(tTarget + ((pThis->gPrivate_startIndex + pIndex + pWidth - 1 - tI) & \
										(pThis->gPrivate_capacity - 1)), \
								tTarget + ((pThis->gPrivate_startIndex + pIndex - 1 - tI) & \
										(pThis->gPrivate_capacity - 1)), \
								sizeof(pELEMENT_TYPE)); \
	\
						pFUNC_ELEMENT_MOVE_DESTRUCTOR(tTarget + \
								((pThis->gPrivate_startIndex + pIndex - 1 - tI) & (pThis->gPrivate_capacity - 1))); \
					} \
	\
					pThis->gPrivate_startIndex = ((pSIZE_T)((pThis->gPrivate_startIndex + pWidth) & (pThis->gPrivate_capacity - 1))); \
				} \
				else \
				{ \
					for(size_t tI = 0 ; tI < pThis->gPrivate_length - pWidth - pIndex; tI++) \
					{ \
						memmove(tTarget + ((pThis->gPrivate_startIndex + tI + pIndex) & (pThis->gPrivate_capacity - 1)), \
								tTarget + ((pThis->gPrivate_startIndex + tI + pIndex + pWidth) & (pThis->gPrivate_capacity - 1)), \
								sizeof(pELEMENT_TYPE)); \
	\
						pFUNC_ELEMENT_MOVE_DESTRUCTOR(tTarget + \
								((pThis->gPrivate_startIndex + tI + pIndex + pWidth) & (pThis->gPrivate_capacity - 1))); \
					} \
				} \
			) \
		) \
		( \
			if((pThis->gPrivate_length >> 1) > pIndex) \
			{ \
				CRX__C__RING__ECHO__RAW_ROTATE_RIGHT(pELEMENT_TYPE, tTarget, \
						pThis->gPrivate_startIndex, ((pThis->gPrivate_startIndex + pIndex - 1) & (pThis->gPrivate_capacity - 1)), \
						pThis->gPrivate_capacity, pWidth, CRXM__FALSE) \
	\
				pThis->gPrivate_startIndex = ((pSIZE_T)((pThis->gPrivate_startIndex + pWidth) & (pThis->gPrivate_capacity - 1))); \
			} \
			else \
			{ \
				if(pIndex + pWidth < pThis->gPrivate_length) \
				{ \
					CRX__C__RING__ECHO__RAW_ROTATE_LEFT(pELEMENT_TYPE, tTarget, \
							((pThis->gPrivate_startIndex + pIndex + pWidth) & (pThis->gPrivate_capacity - 1)), \
							((pThis->gPrivate_startIndex + pThis->gPrivate_length - 1) & (pThis->gPrivate_capacity - 1)), \
							pThis->gPrivate_capacity, pWidth, CRXM__FALSE); \
				} \
			} \
		) \
	\
		pThis->gPrivate_length = ((pSIZE_T)(pThis->gPrivate_length - pWidth)); \
	\
		CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
		return true;, ) \
		CRX_SCOPE_END \
	} \
	\
	PRIVATE pELEMENT_TYPE * pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_doGetElementsPointer(pARRAY_TYPE_NAME * pThis) \
	{ \
		CRXM__IFELSE2(CRXM__NOT(pHAS_INTERNAL_BUFFER), \
		if(pThis->gPrivate_capacity == 0) \
			{return NULL;}, ) \
	\
		CRXM__IFELSE(pHAS_INTERNAL_BUFFER) \
		( \
			if(pThis->gPrivate_externalBuffer != NULL) \
			{ \
				if(pThis->gPrivate_startIndex == 0) \
					{return pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
				else if(pThis->gPrivate_startIndex <= ((pThis->gPrivate_startIndex + pThis->gPrivate_length - 1) & (pThis->gPrivate_capacity - 1))) \
					{return pThis->gPrivate_externalBuffer->gPrivate_buffer + pThis->gPrivate_startIndex;} \
				else \
				{ \
					CRXM__IFELSE(pHAS_ALIGN_FACTOR) \
					( \
						pSIZE_T tStartIndex = 0; \
						pSIZE_T tCapacity; \
						pARRAY_TYPE_NAME ## _ExternalBuffer * tExternalBuffer; \
	\
						CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
								pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pThis, tStartIndex) \
	\
						if(pThis->gPrivate_capacity - tStartIndex < pThis->gPrivate_length) \
						{ \
							if(pThis->gPrivate_length > (pThis->gPrivate_capacity >> 1)) \
								{tCapacity = pThis->gPrivate_capacity * 2;} \
							else \
							{ \
								tStartIndex = (pThis->gPrivate_capacity >> 1); \
								tCapacity = pThis->gPrivate_capacity; \
							} \
						} \
						else \
							{tCapacity = pThis->gPrivate_capacity;} \
	\
						tExternalBuffer = (pARRAY_TYPE_NAME ## _ExternalBuffer *)(malloc( \
								sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + \
								(tCapacity * sizeof(pELEMENT_TYPE)))); \
	\
						if(tExternalBuffer != NULL) \
						{ \
							pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_moveElements( \
									pThis->gPrivate_externalBuffer->gPrivate_buffer, \
									pThis->gPrivate_startIndex, pThis->gPrivate_length, pThis->gPrivate_capacity, \
									tExternalBuffer->gPrivate_buffer + tStartIndex); \
	\
							pThis->gPrivate_startIndex = tStartIndex; \
							pThis->gPrivate_capacity = tCapacity; \
	\
							free(pThis->gPrivate_externalBuffer); \
	\
							pThis->gPrivate_externalBuffer = tExternalBuffer; \
							CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
							pThis->gPrivate_externalBuffer->gCount = 1;, ) \
	\
							return pThis->gPrivate_externalBuffer->gPrivate_buffer + tStartIndex; \
						} \
						else \
							{return NULL;} \
					) \
					( \
						pARRAY_TYPE_NAME ## _ExternalBuffer * tExternalBuffer = \
								(pARRAY_TYPE_NAME ## _ExternalBuffer *)(malloc( \
								sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + \
								(pThis->gPrivate_capacity * sizeof(pELEMENT_TYPE)))); \
	\
						if(tExternalBuffer != NULL) \
						{ \
							pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_moveElements( \
									pThis->gPrivate_externalBuffer->gPrivate_buffer, \
									pThis->gPrivate_startIndex, pThis->gPrivate_length, pThis->gPrivate_capacity, \
									tExternalBuffer->gPrivate_buffer); \
	\
							pThis->gPrivate_startIndex = 0; \
	\
							free(pThis->gPrivate_externalBuffer); \
	\
							pThis->gPrivate_externalBuffer = tExternalBuffer; \
							CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
							pThis->gPrivate_externalBuffer->gCount = 1;, ) \
	\
							return tExternalBuffer->gPrivate_buffer; \
						} \
						else \
							{return NULL;} \
					) \
				} \
			} \
			else \
			{ \
				if(pThis->gPrivate_startIndex == 0) \
					{return pThis->gPrivate_buffer;} \
				else if(pThis->gPrivate_startIndex <= ((pThis->gPrivate_startIndex + pThis->gPrivate_length - 1) & (pThis->gPrivate_capacity - 1))) \
					{return pThis->gPrivate_buffer + pThis->gPrivate_startIndex;} \
				else \
				{ \
					pELEMENT_TYPE CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, \
							* tElements = CRX__ALLOCA(pThis->gPrivate_capacity),  \
							tElements[pDEFAULT_SIZE_OF_INTERNAL_BUFFER]); \
	\
					CRXM__IFELSE2(pHAS_ALIGN_FACTOR, \
					pSIZE_T tStartIndex = 0;, )\
	\
					CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
							pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pThis, tStartIndex) \
	\
					CRXM__IFELSE2(pHAS_ALIGN_FACTOR, \
					if(pThis->gPrivate_capacity - tStartIndex < pThis->gPrivate_length) \
					{ \
						tStartIndex = (pThis->gPrivate_capacity >> 1); \
	\
						if(pThis->gPrivate_capacity - tStartIndex < pThis->gPrivate_length) \
							{tStartIndex = 0;} \
					}, ) \
	\
					pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_moveElements(pThis->gPrivate_buffer, pThis->gPrivate_startIndex, \
							pThis->gPrivate_length, pThis->gPrivate_capacity, tElements); \
					pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_moveElements(tElements, 0, \
							pThis->gPrivate_length, pThis->gPrivate_capacity, \
							pThis->gPrivate_buffer CRXM__IFELSE2(pHAS_ALIGN_FACTOR, + tStartIndex, )); \
					pThis->gPrivate_startIndex = 0 CRXM__IFELSE2(pHAS_ALIGN_FACTOR, + tStartIndex, ); \
	\
					return pThis->gPrivate_buffer; \
				} \
			} \
		) \
		( \
			if(pThis->gPrivate_startIndex == 0) \
				{return pThis->gPrivate_externalBuffer->gPrivate_buffer;} \
			else if(pThis->gPrivate_startIndex <= ((pThis->gPrivate_startIndex + pThis->gPrivate_length - 1) & (pThis->gPrivate_capacity - 1))) \
				{return pThis->gPrivate_externalBuffer->gPrivate_buffer + pThis->gPrivate_startIndex;} \
			else \
			{ \
				CRXM__IFELSE(pHAS_ALIGN_FACTOR) \
				( \
					pSIZE_T tStartIndex = 0; \
					pSIZE_T tCapacity; \
					pARRAY_TYPE_NAME ## _ExternalBuffer * tExternalBuffer; \
	\
					CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, \
							pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pThis, tStartIndex) \
	\
					if(pThis->gPrivate_capacity - tStartIndex < pThis->gPrivate_length) \
					{ \
						if(pThis->gPrivate_length > (pThis->gPrivate_capacity >> 1)) \
							{tCapacity = pThis->gPrivate_capacity * 2;} \
						else \
						{ \
							tStartIndex = (pThis->gPrivate_capacity >> 1); \
							tCapacity = pThis->gPrivate_capacity; \
						} \
					} \
					else \
						{tCapacity = pThis->gPrivate_capacity;} \
	\
					tExternalBuffer = (pARRAY_TYPE_NAME ## _ExternalBuffer *)(malloc( \
							sizeof(pARRAY_TYPE_NAME ## _ExternalBuffer) + (tCapacity * sizeof(pELEMENT_TYPE)))); \
	\
					if(tExternalBuffer != NULL) \
					{ \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_moveElements( \
								pThis->gPrivate_externalBuffer->gPrivate_buffer, \
								pThis->gPrivate_startIndex, pThis->gPrivate_length, pThis->gPrivate_capacity, \
								tExternalBuffer->gPrivate_buffer + tStartIndex); \
	\
						pThis->gPrivate_startIndex = tStartIndex; \
						pThis->gPrivate_capacity = tCapacity; \
	\
						free(pThis->gPrivate_externalBuffer); \
	\
						pThis->gPrivate_externalBuffer = tExternalBuffer; \
						CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
						pThis->gPrivate_externalBuffer->gCount = 1;, ) \
	\
						return pThis->gPrivate_externalBuffer->gPrivate_buffer + tStartIndex; \
					} \
					else \
						{return NULL;} \
				) \
				( \
					pELEMENT_TYPE * tExternalBuffer = (pELEMENT_TYPE *)(malloc(pThis->gPrivate_capacity * \
							sizeof(pELEMENT_TYPE))); \
	\
					if(tExternalBuffer != NULL) \
					{ \
						pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_moveElements( \
								pThis->gPrivate_externalBuffer->gPrivate_buffer, \
								pThis->gPrivate_startIndex, pThis->gPrivate_length, pThis->gPrivate_capacity, \
								tExternalBuffer->gPrivate_buffer); \
	\
						pThis->gPrivate_startIndex = 0; \
	\
						free(pThis->gPrivate_externalBuffer); \
	\
						pThis->gPrivate_externalBuffer = tExternalBuffer; \
						CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
							pThis->gPrivate_externalBuffer->gCount = 1;, ) \
	\
						return tExternalBuffer->gPrivate_buffer; \
					} \
					else \
						{return NULL;} \
				) \
			} \
		) \
	} \
	CRXM__IFELSE2(CRXM__NOT(pIS_TO_ENABLE_COPY_ON_RIGHT), \
	PUBLIC pELEMENT_TYPE * pARRAY_MEMBER_FUNCTIONS_PREFIX ## getElementsPointer(pARRAY_TYPE_NAME * pThis) \
		{return pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_doGetElementsPointer(pThis);}, ) \
	CRXM__IFELSE2(pIS_TO_ENABLE_COPY_ON_RIGHT, \
	PUBLIC pELEMENT_TYPE const * pARRAY_MEMBER_FUNCTIONS_PREFIX ## constantGetElementsPointer(pARRAY_TYPE_NAME const * pThis) \
		{return pARRAY_MEMBER_FUNCTIONS_PREFIX ## private_doGetElementsPointer((pARRAY_TYPE_NAME *) pThis);}, )
//#END_DEFINE

#define CRX__C__Ring__DEFINE___SET_TO_ALIGN_FACTOR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, pSTART_INDEX_DEFAULT_ALIGN_FACTOR, pTHIS, T) \
	CRXM__IFELSE(CRXM__OR(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD, pSTART_INDEX_DEFAULT_ALIGN_FACTOR)) \
	( \
		CRXM__IFELSE(pIS_TO_ENABLE_ALIGN_FACTOR_FIELD) \
		( \
			if(pTHIS->gPrivate_startIndexAlignFactor > 0) \
				{T = (pTHIS->gPrivate_capacity >> pTHIS->gPrivate_startIndexAlignFactor);} \
			else \
			{ \
				T = pTHIS->gPrivate_capacity - (pTHIS->gPrivate_capacity >> abs(pTHIS->gPrivate_startIndexAlignFactor)); \
			} \
		) \
		( \
			if(pSTART_INDEX_DEFAULT_ALIGN_FACTOR > 0) \
				{T = (pTHIS->gPrivate_capacity >> pSTART_INDEX_DEFAULT_ALIGN_FACTOR);} \
			else \
			{ \
				T = pTHIS->gPrivate_capacity - (pTHIS->gPrivate_capacity >> abs(pSTART_INDEX_DEFAULT_ALIGN_FACTOR)); \
			} \
		) \
	)()
//#END_DEFINE
		
#define CRX__C__Ring__ECHO_SIZE_OF_INTERNAL_BUFFER(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, pTHIS, \
				pDEFAULT_SIZE_OF_INTERNAL_BUFFER) \
		CRXM__IFELSE2(pIS_TO_ENABLE_SIZE_OF_INTERNAL_BUFFER_FIELD, pTHIS->gSIZE_OF_INTERNAL_BUFFER, pDEFAULT_SIZE_OF_INTERNAL_BUFFER)

/*
WARNING:
	- It is assumed that there is sufficient space left for the insertion, otherwise the behavior is undefined.
	- It is assumed that the capacity is smaller than half the largest size_t value representable by the machine.
	- It is assumed that pWIDTH >= 1
*/
#define CRX__C__Ring__ECHO_INSERT_SPACE_AT(pSIZE_T, pELEMENT_TYPE, pTHIS_SIZE_OF_INTERNAL_BUFFER, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, pTHIS, pINDEX, pWIDTH) \
	{ \
		assert(pWIDTH <= (pTHIS->gPrivate_capacity - pTHIS->gPrivate_length)); \
	\
		if(pINDEX == 0) \
		{ \
			if(pTHIS->gPrivate_startIndex >= pWIDTH) \
				{pTHIS->gPrivate_startIndex = ((pSIZE_T)(pTHIS->gPrivate_startIndex - pWIDTH));} \
			else \
				{pTHIS->gPrivate_startIndex = ((pSIZE_T)(pTHIS->gPrivate_capacity - (pWIDTH - pTHIS->gPrivate_startIndex)));} \
		} \
		else if(pINDEX == pTHIS->gPrivate_length) \
			{} \
		else \
		{ \
			pELEMENT_TYPE * vTarget = NULL; \
			size_t vInsertIndex = (pTHIS->gPrivate_startIndex + pINDEX) & \
					(pTHIS->gPrivate_capacity - 1); \
	\
			assert(vInsertIndex != pTHIS->gPrivate_startIndex); \
	\
			CRXM__IFELSE(pTHIS_SIZE_OF_INTERNAL_BUFFER) \
			( \
				if(pTHIS->gPrivate_externalBuffer != NULL) \
					{vTarget = pTHIS->gPrivate_externalBuffer->gPrivate_buffer;} \
				else \
					{vTarget = pTHIS->gPrivate_buffer;} \
			) \
			( \
				vTarget = pTHIS->gPrivate_externalBuffer->gPrivate_buffer; \
			) \
	\
			CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)) \
			( \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					if((pTHIS->gPrivate_length >> 1) < pINDEX) \
					{ \
						CRX_FOR(size_t tI = pTHIS->gPrivate_length - 1, tI >= pINDEX, tI--) \
						{ \
							pFUNC_ELEMENT_MOVE_CONSTRUCTOR( \
									vTarget + ((pTHIS->gPrivate_startIndex + tI + pWIDTH) & \
											(pTHIS->gPrivate_capacity - 1)), \
									vTarget + ((pTHIS->gPrivate_startIndex + tI) & \
											(pTHIS->gPrivate_capacity - 1))); \
	\
							CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
							pFUNC_ELEMENT_MOVE_DESTRUCTOR(vTarget + \
									((pTHIS->gPrivate_startIndex + tI) & \
									(pTHIS->gPrivate_capacity - 1)));, ) \
						} \
						CRX_ENDFOR \
					} \
					else \
					{ \
						if(pTHIS->gPrivate_startIndex >= pWIDTH) \
						{ \
							CRX_FOR(size_t tI = 0, tI < pINDEX, tI++) \
							{ \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR( \
										vTarget + ((pTHIS->gPrivate_startIndex - pWIDTH + tI) & \
												(pTHIS->gPrivate_capacity - 1)), \
										vTarget + ((pTHIS->gPrivate_startIndex + tI) & \
												(pTHIS->gPrivate_capacity - 1))); \
	\
								CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR(vTarget + \
										((pTHIS->gPrivate_startIndex + tI) & \
										(pTHIS->gPrivate_capacity - 1)));, ) \
							} \
							CRX_ENDFOR \
	\
							pTHIS->gPrivate_startIndex = \
									((pSIZE_T)(pTHIS->gPrivate_startIndex - pWIDTH)); \
						} \
						else \
						{ \
							size_t tUpperIndex = (((pWIDTH - pTHIS->gPrivate_startIndex) > \
									pINDEX) ? pINDEX : (pWIDTH - pTHIS->gPrivate_startIndex)); \
	\
							CRX_FOR(size_t tI = 0, tI < tUpperIndex, tI++) \
							{ \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR( \
										vTarget + pTHIS->gPrivate_capacity - \
												(pWIDTH - pTHIS->gPrivate_startIndex) + tI, \
										vTarget + ((pTHIS->gPrivate_startIndex + tI) & \
												(pTHIS->gPrivate_capacity - 1))); \
	\
								CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR(vTarget + \
										((pTHIS->gPrivate_startIndex + tI) & \
										(pTHIS->gPrivate_capacity - 1)));, ) \
							} \
							CRX_ENDFOR \
	\
							if(tUpperIndex < pINDEX) \
							{ \
								CRX_FOR(size_t tI = tUpperIndex, tI < pINDEX, tI++) \
								{ \
									pFUNC_ELEMENT_MOVE_CONSTRUCTOR( \
											vTarget + ((pTHIS->gPrivate_startIndex + tI - pWIDTH) & \
													(pTHIS->gPrivate_capacity - 1)), \
											vTarget + ((pTHIS->gPrivate_startIndex + tI) & \
													(pTHIS->gPrivate_capacity - 1))); \
	\
									CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
									pFUNC_ELEMENT_MOVE_DESTRUCTOR(vTarget + \
											((pTHIS->gPrivate_startIndex + tI) & \
											(pTHIS->gPrivate_capacity - 1)));, ) \
								} \
								CRX_ENDFOR \
							} \
	\
							pTHIS->gPrivate_startIndex = ((pSIZE_T)(pTHIS->gPrivate_capacity - \
									(pWIDTH - pTHIS->gPrivate_startIndex))); \
						} \
					} \
				) \
				( \
					/*THIS CODE IS NOT OPTIMAL.*/ \
					if((pTHIS->gPrivate_length >> 1) < pINDEX) \
					{ \
						CRX_FOR(size_t tI = pTHIS->gPrivate_length - 1, tI >= pINDEX, tI--) \
						{ \
							memmove(vTarget + ((pTHIS->gPrivate_startIndex + tI + pWIDTH) & \
											(pTHIS->gPrivate_capacity - 1)), \
									vTarget + ((pTHIS->gPrivate_startIndex + tI) & \
											(pTHIS->gPrivate_capacity - 1)), \
									sizeof(pELEMENT_TYPE)); \
	\
							pFUNC_ELEMENT_MOVE_DESTRUCTOR(vTarget + \
									((pTHIS->gPrivate_startIndex + tI) & \
									(pTHIS->gPrivate_capacity - 1))); \
						} \
						CRX_ENDFOR \
					} \
					else \
					{ \
						if(pTHIS->gPrivate_startIndex >= pWIDTH) \
						{ \
							CRX_FOR(size_t tI = 0, tI < pINDEX, tI++) \
							{ \
								memmove(vTarget + ((pTHIS->gPrivate_startIndex - pWIDTH + tI) & \
												(pTHIS->gPrivate_capacity - 1)), \
										vTarget + ((pTHIS->gPrivate_startIndex + tI) & \
												(pTHIS->gPrivate_capacity - 1)), \
										sizeof(pELEMENT_TYPE)); \
	\
								pFUNC_ELEMENT_MOVE_DESTRUCTOR(vTarget + \
										((pTHIS->gPrivate_startIndex + tI) & \
										(pTHIS->gPrivate_capacity - 1))); \
							} \
							CRX_ENDFOR \
	\
							pTHIS->gPrivate_startIndex = \
									((pSIZE_T)(pTHIS->gPrivate_startIndex - pWIDTH)); \
						} \
						else \
						{ \
							size_t tUpperIndex = (((pWIDTH - pTHIS->gPrivate_startIndex) > \
									pINDEX) ? pINDEX : (pWIDTH - pTHIS->gPrivate_startIndex)); \
	\
							CRX_FOR(size_t tI = 0, tI < tUpperIndex, tI++) \
							{ \
								memmove(vTarget + \
												pTHIS->gPrivate_capacity - \
												(pWIDTH - pTHIS->gPrivate_startIndex) + tI, \
										vTarget + ((pTHIS->gPrivate_startIndex + tI) & \
												(pTHIS->gPrivate_capacity - 1)), \
										sizeof(pELEMENT_TYPE)); \
	\
								pFUNC_ELEMENT_MOVE_DESTRUCTOR(vTarget + \
										((pTHIS->gPrivate_startIndex + tI) & \
										(pTHIS->gPrivate_capacity - 1))); \
							} \
							CRX_ENDFOR \
	\
							if(tUpperIndex < pINDEX) \
							{ \
								CRX_FOR(size_t tI = tUpperIndex, tI < pINDEX, tI++) \
								{ \
									memmove(vTarget + \
													((pTHIS->gPrivate_startIndex + tI - pWIDTH) & \
													(pTHIS->gPrivate_capacity - 1)), \
											vTarget + ((pTHIS->gPrivate_startIndex + tI) & \
													(pTHIS->gPrivate_capacity - 1)), \
											sizeof(pELEMENT_TYPE)); \
	\
									pFUNC_ELEMENT_MOVE_DESTRUCTOR(vTarget + \
											((pTHIS->gPrivate_startIndex + tI) & \
											(pTHIS->gPrivate_capacity - 1))); \
								} \
								CRX_ENDFOR \
							} \
	\
							pTHIS->gPrivate_startIndex = ((pSIZE_T)(pTHIS->gPrivate_capacity - \
									(pWIDTH - pTHIS->gPrivate_startIndex))); \
						} \
					} \
				) \
			) \
			( \
				if((pTHIS->gPrivate_length >> 1) >= pINDEX) \
				{ \
					if(pTHIS->gPrivate_startIndex >= pWIDTH) \
					{ \
						if(pTHIS->gPrivate_startIndex + 1 <= vInsertIndex) \
						{ \
							memmove(vTarget + pTHIS->gPrivate_startIndex - pWIDTH, \
									vTarget + pTHIS->gPrivate_startIndex, (vInsertIndex - pTHIS->gPrivate_startIndex) * sizeof(pELEMENT_TYPE)); \
						} \
						else \
						{ \
							memmove(vTarget + pTHIS->gPrivate_startIndex - pWIDTH, \
									vTarget + pTHIS->gPrivate_startIndex, (pTHIS->gPrivate_capacity - pTHIS->gPrivate_startIndex) * sizeof(pELEMENT_TYPE)); \
		\
							if(vInsertIndex <= pWIDTH) \
							{ \
								memmove(vTarget + pTHIS->gPrivate_capacity - pWIDTH, \
										vTarget, vInsertIndex * sizeof(pELEMENT_TYPE)); \
							} \
							else \
							{ \
								memmove(vTarget + pTHIS->gPrivate_capacity - pWIDTH, \
										vTarget, pWIDTH * sizeof(pELEMENT_TYPE)); \
								memmove(vTarget, \
										vTarget + pWIDTH, \
										(vInsertIndex - pWIDTH) * sizeof(pELEMENT_TYPE)); \
							} \
						} \
		\
						pTHIS->gPrivate_startIndex = \
								((pSIZE_T)(pTHIS->gPrivate_startIndex - pWIDTH)); \
					} \
					else \
					{ \
						if(pWIDTH < vInsertIndex) \
						{ \
							memmove(vTarget + pTHIS->gPrivate_capacity - (pWIDTH - pTHIS->gPrivate_startIndex), \
									vTarget + pTHIS->gPrivate_startIndex, \
									(pWIDTH - pTHIS->gPrivate_startIndex) * sizeof(pELEMENT_TYPE)); \
							memmove(vTarget, vTarget + pWIDTH, \
									(vInsertIndex - pWIDTH) * sizeof(pELEMENT_TYPE)); \
						} \
						else \
						{ \
							memmove(vTarget + pTHIS->gPrivate_capacity - (pWIDTH - pTHIS->gPrivate_startIndex), \
									vTarget + pTHIS->gPrivate_startIndex, \
									(vInsertIndex - pTHIS->gPrivate_startIndex) * sizeof(pELEMENT_TYPE)); \
						} \
						pTHIS->gPrivate_startIndex = ((pSIZE_T)(pTHIS->gPrivate_capacity - \
								(pWIDTH - pTHIS->gPrivate_startIndex))); \
					} \
				} \
				else \
				{ \
					size_t tEndIndex = (pTHIS->gPrivate_startIndex + pTHIS->gPrivate_length - 1) & (pTHIS->gPrivate_capacity - 1); \
		\
					if(pTHIS->gPrivate_capacity - 1 - tEndIndex >= pWIDTH) \
					{ \
						if(tEndIndex + 1 >= vInsertIndex) \
						{ \
							memmove(vTarget + vInsertIndex + pWIDTH, \
									vTarget + vInsertIndex, \
									(tEndIndex  + 1 - vInsertIndex) * sizeof(pELEMENT_TYPE)); \
						} \
						else \
						{ \
							memmove(vTarget + pWIDTH, vTarget, (tEndIndex + 1) * sizeof(pELEMENT_TYPE)); \
		\
							if(pTHIS->gPrivate_capacity - vInsertIndex <= pWIDTH) \
							{ \
								memmove(vTarget + pWIDTH - (pTHIS->gPrivate_capacity - vInsertIndex), \
										vTarget + vInsertIndex, \
										(pTHIS->gPrivate_capacity - vInsertIndex) * sizeof(pELEMENT_TYPE)); \
							} \
							else \
							{ \
								memmove(vTarget, vTarget + pTHIS->gPrivate_capacity - pWIDTH, \
										pWIDTH * sizeof(pELEMENT_TYPE)); \
								memmove(vTarget + vInsertIndex + pWIDTH, vTarget + vInsertIndex, \
										(pTHIS->gPrivate_capacity - pWIDTH - vInsertIndex) * sizeof(pELEMENT_TYPE)); \
							} \
						} \
					} \
					else \
					{ \
						if(pTHIS->gPrivate_capacity - pWIDTH > vInsertIndex) \
						{ \
							memmove(vTarget, vTarget + pTHIS->gPrivate_capacity - pWIDTH, \
									(tEndIndex + pWIDTH + 1 - pTHIS->gPrivate_capacity) * sizeof(pELEMENT_TYPE)); \
							memmove(vTarget + vInsertIndex + pWIDTH, vTarget + vInsertIndex, \
									(pTHIS->gPrivate_capacity - pWIDTH - vInsertIndex) * sizeof(pELEMENT_TYPE)); \
						} \
						else \
						{ \
							memmove(vTarget, vTarget + vInsertIndex, \
									(tEndIndex + 1 - vInsertIndex) * sizeof(pELEMENT_TYPE)); \
						} \
					} \
				} \
			) \
		} \
	\
		pTHIS->gPrivate_length = pTHIS->gPrivate_length + ((pSIZE_T)pWIDTH); \
	}
//#END_DEFINE

#define CRX__C__RING__ECHO__COPY_FROM_RING_RANGE(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pELEMENT_TYPE, pTHIS_ELEMENTS, \
				pTHIS_START_INDEX, pTHIS_CAPACITY, pINDEX, pARRAY_ELEMENTS, \
				pARRAY_START_INDEX, pARRAY_CAPACITY, pSTART_INDEX, pWIDTH)  \
	{ \
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			CRX_FOR(size_t tI = 0, tI < pWIDTH, tI++) \
			{ \
				pFUNC_ELEMENT_COPY_CONSTRUCTOR(pTHIS_ELEMENTS + ((pTHIS_START_INDEX + tI + pINDEX) & (pTHIS_CAPACITY - 1)), \
						pARRAY_ELEMENTS + ((pARRAY_START_INDEX + tI + pSTART_INDEX) & (pARRAY_CAPACITY - 1))); \
			} \
			CRX_ENDFOR \
		) \
		( \
			size_t tTargetStartIndex = ((pTHIS_START_INDEX + pINDEX) & (pTHIS_CAPACITY - 1)); \
			size_t tTargetSegmentLength = ((tTargetStartIndex >= pTHIS_START_INDEX) ? \
					((((pTHIS_START_INDEX + pINDEX + pWIDTH - 1) & (pTHIS_CAPACITY - 1)) >= tTargetStartIndex) ? \
							pWIDTH : (pTHIS_CAPACITY - tTargetStartIndex)) : \
					pWIDTH); \
			size_t tSourceStartIndex = ((pARRAY_START_INDEX + pSTART_INDEX) & (pARRAY_CAPACITY - 1)); \
			size_t tSourceSegmentLength = ((tSourceStartIndex >= pARRAY_START_INDEX) ? \
					((((pARRAY_START_INDEX + pSTART_INDEX + pWIDTH - 1) & (pARRAY_CAPACITY - 1)) >= tSourceStartIndex) ? \
							pWIDTH : (pARRAY_CAPACITY - tSourceStartIndex)) : \
					pWIDTH); \
	\
			if(tTargetSegmentLength <= tSourceSegmentLength) \
			{ \
				memcpy(pTHIS_ELEMENTS + tTargetStartIndex, pARRAY_ELEMENTS + tSourceStartIndex, \
						tTargetSegmentLength * sizeof(pELEMENT_TYPE)); \
	\
				if(tTargetSegmentLength < pWIDTH) \
				{ \
					assert(((pTHIS_START_INDEX + pINDEX + tTargetSegmentLength) & (pTHIS_CAPACITY - 1)) == 0); \
	\
					memcpy(pTHIS_ELEMENTS, pARRAY_ELEMENTS + tSourceStartIndex + tTargetSegmentLength, \
							(tSourceSegmentLength - tTargetSegmentLength) * sizeof(pELEMENT_TYPE)); \
	\
					if(tSourceSegmentLength < pWIDTH) \
					{ \
						assert(((pARRAY_START_INDEX + tSourceStartIndex + tSourceSegmentLength) & (pTHIS_CAPACITY - 1)) == 0); \
	\
						memcpy(pTHIS_ELEMENTS + tSourceSegmentLength - tTargetSegmentLength, \
								pARRAY_ELEMENTS, (pWIDTH - tSourceSegmentLength) * sizeof(pELEMENT_TYPE)); \
					} \
				} \
			} \
			else \
			{ \
				memcpy(pTHIS_ELEMENTS + tTargetStartIndex, pARRAY_ELEMENTS + tSourceStartIndex, \
						tSourceSegmentLength * sizeof(pELEMENT_TYPE)); \
	\
				assert(((pARRAY_START_INDEX + pSTART_INDEX + tSourceSegmentLength) & (pTHIS_CAPACITY - 1)) == 0); \
	\
				memcpy(pTHIS_ELEMENTS + tTargetStartIndex + tSourceSegmentLength, pARRAY_ELEMENTS, \
						(tTargetSegmentLength - tSourceSegmentLength) * sizeof(pELEMENT_TYPE)); \
	\
				if(tTargetSegmentLength < pWIDTH) \
				{ \
					assert(((pTHIS_START_INDEX + pINDEX + tTargetSegmentLength) & (pTHIS_CAPACITY - 1)) == 0); \
	\
					memcpy(pTHIS_ELEMENTS, pARRAY_ELEMENTS + tTargetSegmentLength - tSourceSegmentLength, \
							(pWIDTH - tTargetSegmentLength) * sizeof(pELEMENT_TYPE)); \
				} \
			} \
		) \
	}
//#END_DEFINE

/*WARNING: THE FOLLOWING ASSUMES THAT THE REMAINING SPACE IS LARGER THAN pWIDTH. THIS MEANS THAT
		IT IS ASSUMED THAT THE TAIL WILL NEVER HIT THE ORIGINAL LOCATION OF THE HEAD AFTER ROTATION.*/
#define CRX__C__RING__ECHO__RAW_ROTATE_RIGHT(pELEMENT_TYPE, pELEMENTS, \
		pRAW_START_INDEX, pRAW_END_INDEX, pCAPACITY, pWIDTH, pNEW_RAW_END_INDEX) \
	{ \
		assert(pWIDTH > 0); \
\
		size_t tStartIndex = pRAW_START_INDEX; \
		size_t tEndIndex = pRAW_END_INDEX; \
		size_t tEmptySpaceBeforeEnd; \
\
		if(tEndIndex < tStartIndex) \
			{tEmptySpaceBeforeEnd = 0;} \
		else \
			{tEmptySpaceBeforeEnd = pCAPACITY - tEndIndex - 1;} \
\
		if(tEndIndex < tStartIndex) \
		{ \
			memmove(pELEMENTS + pWIDTH, pELEMENTS, \
					/*tEndIndex * sizeof(pELEMENT_TYPE));*/ \
					(tEndIndex + 1) * sizeof(pELEMENT_TYPE)); \
		} \
\
		if(pWIDTH <= tEmptySpaceBeforeEnd) \
		{ \
			memmove(pELEMENTS + tStartIndex + pWIDTH, pELEMENTS + tStartIndex, \
					(tEndIndex + 1 - tStartIndex) * sizeof(pELEMENT_TYPE)); \
\
			CRXM__IFELSE2(pNEW_RAW_END_INDEX, \
			pNEW_RAW_END_INDEX = tEndIndex + pWIDTH;, ) \
		} \
		else \
		{ \
			if(pWIDTH < pCAPACITY - tStartIndex) \
			{ \
				memcpy(pELEMENTS, pELEMENTS + pCAPACITY - (pWIDTH - tEmptySpaceBeforeEnd), \
							(pWIDTH - tEmptySpaceBeforeEnd) * sizeof(pELEMENT_TYPE)); \
\
				memmove(pELEMENTS + tStartIndex + pWIDTH, pELEMENTS + tStartIndex, \
						(pCAPACITY - tStartIndex  - pWIDTH) * sizeof(pELEMENT_TYPE)); \
\
				CRXM__IFELSE2(pNEW_RAW_END_INDEX, \
				pNEW_RAW_END_INDEX = pWIDTH - tEmptySpaceBeforeEnd - 1;, ) \
			} \
			else \
			{ \
				memcpy(pELEMENTS + pWIDTH - (pCAPACITY - tStartIndex), pELEMENTS + tStartIndex, \
						(pCAPACITY - tEmptySpaceBeforeEnd - tStartIndex) * sizeof(pELEMENT_TYPE)); \
\
				CRXM__IFELSE2(pNEW_RAW_END_INDEX, \
				pNEW_RAW_END_INDEX = pWIDTH - tEmptySpaceBeforeEnd - 1;, ) \
			} \
		} \
	}
//#END_DEFINE

/*WARNING: THE FOLLOWING ASSUMES THAT THE REMAINING SPACE IS LARGER THAN pWIDTH. THIS MEANS THAT
		IT IS ASSUMED THAT THE HEAD WILL NEVER HIT THE ORIGINAL LOCATION OF THE TAIL AFTER ROTATION.*/
#define CRX__C__RING__ECHO__RAW_ROTATE_LEFT(pELEMENT_TYPE, pELEMENTS, \
		pRAW_START_INDEX, pRAW_END_INDEX, pCAPACITY, pWIDTH, pNEW_RAW_START_INDEX) \
	{ \
		assert(pWIDTH > 0); \
\
		size_t tStartIndex = pRAW_START_INDEX; \
		size_t tEndIndex = pRAW_END_INDEX; \
		size_t tIndexOfFirstElementFromLeftSide; \
\
		if(tStartIndex > tEndIndex) \
			{tIndexOfFirstElementFromLeftSide = 0;} \
		else \
			{tIndexOfFirstElementFromLeftSide = tStartIndex;} \
\
		if(tStartIndex > tEndIndex) \
		{ \
			memmove(pELEMENTS + tStartIndex - pWIDTH, pELEMENTS + tStartIndex, \
					(pCAPACITY - tStartIndex) * sizeof(pELEMENT_TYPE)); \
		} \
\
		if(pWIDTH <= tIndexOfFirstElementFromLeftSide) \
		{ \
			memcpy(pELEMENTS + tStartIndex - pWIDTH, pELEMENTS + tStartIndex, \
					/*(tStartIndex + 1 - tStartIndex) * sizeof(pELEMENT_TYPE));*/ \
					(tEndIndex + 1 - tStartIndex) * sizeof(pELEMENT_TYPE)); \
\
			CRXM__IFELSE2(pNEW_RAW_START_INDEX, \
			pNEW_RAW_START_INDEX = tStartIndex - pWIDTH;, ) \
		} \
		else \
		{ \
			if(pWIDTH <= tEndIndex) \
			{ \
				memcpy(pELEMENTS + pCAPACITY + tIndexOfFirstElementFromLeftSide - pWIDTH, \
						pELEMENTS + tIndexOfFirstElementFromLeftSide, \
						(pWIDTH - tIndexOfFirstElementFromLeftSide) * sizeof(pELEMENT_TYPE)); \
\
				memcpy(pELEMENTS, pELEMENTS + pWIDTH, \
						(tEndIndex + 1 - pWIDTH) * sizeof(pELEMENT_TYPE)); \
\
				CRXM__IFELSE2(pNEW_RAW_START_INDEX, \
				pNEW_RAW_START_INDEX = pCAPACITY - (pWIDTH - tIndexOfFirstElementFromLeftSide);, ) \
			} \
			else \
			{ \
				memcpy(pELEMENTS + pCAPACITY + tIndexOfFirstElementFromLeftSide - pWIDTH, \
						pELEMENTS + tIndexOfFirstElementFromLeftSide, \
						(tEndIndex + 1 - tIndexOfFirstElementFromLeftSide) * sizeof(pELEMENT_TYPE)); \
\
				CRXM__IFELSE2(pNEW_RAW_START_INDEX, \
				pNEW_RAW_START_INDEX = pCAPACITY - (pWIDTH - tIndexOfFirstElementFromLeftSide);, ) \
			} \
		} \
	}
//#END_DEFINE

/*WARNING: THE FOLLOWING IS VERBATIM FROM Ring.h . DO NOT MODIFY HERE*/
typedef struct Crx_C_Ring
{
	Crx_C_TypeBluePrint const * CRX_NOT_MINE gPrivate_typeBluePrint;
	size_t gSIZE_OF_INTERNAL_BUFFER;
	unsigned char * gPrivate_elements;
	unsigned char * gPrivate_internalBuffer;
	size_t gPrivate_startIndex;
	size_t gPrivate_length;
	signed char gPrivate_startIndexAlignFactor; /*KEEP THIS HERE. HELPS WITH ALIGNING gPrivate_buffer*/
	bool gPrivate_isInternalBufferExternal;
	size_t gPrivate_capacity;
	unsigned char gPrivate_buffer[1 /*N*/]; /*KEEP THIS ALIGNED AT 16 BYTES RELATIVE TO STRUCTURE WHEN 64BIT*/
} Crx_C_Ring;

CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_ring_getCorrectCapacityBoundFor(size_t pCapacity);
CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_ring_getByteSizeOf(
		Crx_C_Ring const * CRX_NOT_NULL pArray);
CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_ring_getByteSizeFor(
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint, 
		bool pIsInternalBufferExternal, size_t pSizeOfInternalBuffer);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_doInit(Crx_C_Ring * pThis, 
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint, 
		size_t pSizeOfInternalBuffer, size_t pCapacity, 
		signed char pStartIndexAlignFactor);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_construct(Crx_C_Ring * pThis, 
		Crx_C_TypeBluePrint const * CRX_NOT_NULL
		pTypeBluePrint, size_t pSizeOfInternalBuffer, size_t pCapacity, 
		signed char pStartIndexAlignFactor);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_construct2(Crx_C_Ring * pThis, 
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint, 
		unsigned char * CRX_NOT_NULL pBufferOnStack, 
		size_t pSizeOfBufferOnStack, size_t pCapacity, signed char pStartIndexAlignFactor);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_moveConstruct(Crx_C_Ring * pThis, 
		Crx_C_Ring * CRX_NOT_NULL pArray);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_copyConstruct(Crx_C_Ring * pThis, 
		Crx_C_Ring const * CRX_NOT_NULL pArray);
CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_Ring * crx_c_ring_new(Crx_C_TypeBluePrint const * pTypeBluePrint, 
		size_t pSizeOfInternalBuffer CRX_DEFAULT(0), size_t pCapacity CRX_DEFAULT(0),
		signed char pStartIndexAlignFactor CRX_DEFAULT(0));
CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_Ring * crx_c_ring_new2(
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint, 
		unsigned char * CRX_NOT_NULL pBufferOnStack, size_t pSizeOfBufferOnStack CRX_DEFAULT(0), 
		size_t pCapacity CRX_DEFAULT(0), signed char pStartIndexAlignFactor CRX_DEFAULT(0));
CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_Ring * crx_c_ring_moveNew(Crx_C_Ring * pArray);
CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_Ring * crx_c_ring_copyNew(Crx_C_Ring const * pArray);
CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_Ring * crx_c_ring_private_new2(Crx_C_Ring * pArray,
		size_t pStartIndex, size_t pWidth);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_ring_private_unsafeCallElementsDestruct(
		Crx_C_Ring * pThis, size_t pStartIndex, size_t pEndIndex);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_destruct(Crx_C_Ring * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_free(Crx_C_Ring * pThis);
CRX__C__TYPE_BLUE_PRINT__GENERIC__DECLARE_GET_BLUE_PRINT(
		Crx_C_Ring, crx_c_ring_,
		CRXM__FALSE, CRXM__TRUE,
		CRXM__TRUE, CRXM__TRUE,
		CRXM__TRUE, CRXM__FALSE);
CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_ring_getLength(Crx_C_Ring * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() size_t crx_c_ring_getCapacity(Crx_C_Ring * pThis);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_ring_private_moveElements(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pSourceBuffer, size_t pStartIndex, size_t pLength, size_t pCapacity, 
		void * CRX_NOT_NULL pTargetBuffer);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_ensureCapacity(Crx_C_Ring * pThis, size_t pCapacity);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_emptyAndEnsureCapacity(Crx_C_Ring * pThis, 
		size_t pCapacity);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_empty(Crx_C_Ring * pThis);
CRX__LIB__PRIVATE_C_FUNCTION() bool crx_c_ring_private_insertSpaceAt(Crx_C_Ring * pThis, 
		size_t pIndex, size_t pWidth);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_ring_private_fastInsertSpaceAt(Crx_C_Ring * pThis, 
		size_t pIndex, size_t pWidth);
CRX__LIB__PRIVATE_C_FUNCTION() Crx_C_Ring_Private_IndexTransform crx_c_ring_private_roundInsertSpaceAt(
		Crx_C_Ring * pThis, size_t pIndex, size_t pWidth);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_copyAssignFrom2(Crx_C_Ring * pThis, 
		Crx_C_Ring * CRX_NOT_NULL pArray, size_t pStartIndex, size_t pWidth);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_copyAssignFrom(Crx_C_Ring * pThis, 
		Crx_C_Ring * CRX_NOT_NULL pArray);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_moveAndSetAt(Crx_C_Ring * pThis, size_t pIndex, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_setAt(Crx_C_Ring * pThis, size_t pIndex, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() unsigned char * crx_c_ring_get(Crx_C_Ring * pThis, size_t pIndex);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_copyGetTo(Crx_C_Ring const * pThis, 
		unsigned char * CRX_NOT_NULL pReturn, size_t pIndex);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_tryMoveAndPush(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_push(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_moveAndFastPush(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_fastPush(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_moveAndRoundPush(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_roundPush(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_pop(Crx_C_Ring * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_tryMoveAndPushToFront(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_pushToFront(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_moveAndFastPushToFront(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_fastPushToFront(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_moveAndRoundPushToFront(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_roundPushToFront(Crx_C_Ring * pThis, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_popFromFront(Crx_C_Ring * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_tryMoveAndInsertElementAt(Crx_C_Ring * pThis, 
		size_t pIndex, void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_insertElementAt(Crx_C_Ring * pThis, size_t pIndex, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_moveAndFastInsertElementAt(Crx_C_Ring * pThis, 
		size_t pIndex, void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_fastInsertElementAt(Crx_C_Ring * pThis, size_t pIndex, 
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_moveAndRoundInsertElementAt(Crx_C_Ring * pThis, 
		size_t pIndex, void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_roundInsertElementAt(Crx_C_Ring * pThis, 
		size_t pIndex, void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_insertElementsAt(Crx_C_Ring * pThis, size_t pIndex,
		Crx_C_Ring * CRX_NOT_NULL pArray, size_t pStartIndex, size_t pWidth);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_fastInsertElementsAt(Crx_C_Ring * pThis, 
		size_t pIndex, Crx_C_Ring * CRX_NOT_NULL pArray, size_t pStartIndex, size_t pWidth);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_roundInsertElementsAt(Crx_C_Ring * pThis, 
		size_t pIndex, Crx_C_Ring * CRX_NOT_NULL pArray, size_t pStartIndex, size_t pWidth);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_insertCArrayAt(Crx_C_Ring * pThis, size_t pIndex,
		void * CRX_NOT_NULL pArray, size_t pWidth);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_fastInsertCArrayAt(Crx_C_Ring * pThis, size_t pIndex,
		void * CRX_NOT_NULL pArray, size_t pWidth);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_roundInsertCArrayAt(Crx_C_Ring * pThis, size_t pIndex,
		void * CRX_NOT_NULL pArray, size_t pWidth);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_ring_insertElementCopiesAt(Crx_C_Ring * pThis, 
		size_t pIndex, void * CRX_NOT_NULL pElement, size_t pNumberOfCopies);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_fastInsertElementCopiesAt(Crx_C_Ring * pThis, 
		size_t pIndex, void * CRX_NOT_NULL pElement, size_t pNumberOfCopies);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_roundInsertElementCopiesAt(Crx_C_Ring * pThis, 
		size_t pIndex, void * CRX_NOT_NULL pElement, size_t pNumberOfCopies);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_ring_removeElements(Crx_C_Ring * pThis, size_t pIndex,
		size_t pWidth);
CRX__LIB__PUBLIC_C_FUNCTION() unsigned char * crx_c_ring_getElementsPointer(Crx_C_Ring * pThis);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_ring_private_doInsertSpaceAt(Crx_C_Ring * pThis, 
		size_t pIndex, size_t pWidth);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_ring_private_copyFromRingRange(Crx_C_Ring * pThis, 
		size_t pIndex, Crx_C_Ring const * CRX_NOT_NULL pArray, size_t pStartIndex, size_t pWidth);
/*WARNING: THE FOLLOWING ASSUMES THAT THE REMAINING SPACE IS LARGER THAN pWIDTH. THIS MEANS THAT
		IT IS ASSUMED THAT THE TAIL WILL NEVER HIT THE ORIGINAL LOCATION OF THE HEAD AFTER ROTATION.*/
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_ring_private_rawRotateRight(Crx_C_Ring * pThis, 
		unsigned char * CRX_NOT_NULL pElements, size_t pRawStartIndex, size_t pRawEndIndex, 
		size_t pWidth /*, bool pIsToSetNewRawEndIndex*/);
/*WARNING: THE FOLLOWING ASSUMES THAT THE REMAINING SPACE IS LARGER THAN pWIDTH. THIS MEANS THAT
		IT IS ASSUMED THAT THE HEAD WILL NEVER HIT THE ORIGINAL LOCATION OF THE TAIL AFTER ROTATION.*/
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_ring_private_rawRotateLeft(Crx_C_Ring * pThis, 
		unsigned char * CRX_NOT_NULL pElements, size_t pRawStartIndex, size_t pRawEndIndex, 
		size_t pWidth /*, bool pIsToSetNewRawStartIndex*/);

CRX__LIB__C_CODE_END()

#if(CRXM__IS(CRX__LIB__MODE, CRX__LIB__MODE__HEADER_ONLY))
	//INCLUDE THE CORRESPONDING .c.h FILE FROM THE CRXed CODE. DO NOT INCLUDE ANY OTHER FILE
	#include "Crx/C.H/crx/c/Ring.c.h"
#endif
#if(CRX__PREPROCESSOR__HAS_PUSH_MACRO)
	#pragma pop_macro("CRX__LIB__MODE")
#endif

#endif