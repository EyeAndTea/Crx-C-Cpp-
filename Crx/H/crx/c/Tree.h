#if(!defined(CRX__C__TREE___h__))
#define CRX__C__TREE___h__

#include <boost/version.hpp>
#include "Crx/H/crx/crx.h"
#if(CRX__PREPROCESSOR__HAS_PUSH_MACRO)
	#pragma push_macro("CRX__LIB__MODE")
	#undef CRX__LIB__MODE
	#if(!defined(CRX__CONFIG__MODE))
		#define CRX__CONFIG__MODE CRX__LIB__MODE__STAND_ALONE
	#endif
	#define CRX__LIB__MODE CRX__CONFIG__MODE
#else
	#undef CRX__LIB__MODE
	#if(!defined(CRX__LIB__C_MODE))
		#define CRX__LIB__C_MODE CRX__LIB__MODE__STAND_ALONE
	#endif
	#define CRX__LIB__MODE CRX__LIB__C_MODE
#endif
//<<START>>	INCLUDE ".h" OF C NON CRXed CODE THAT THIS HEADER NEEDS.
//			INCLUDE ".h", NOT ".c.h", OF C CRXed CODE.
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <malloc.h>
#include "Crx/H/crx/nonCrxed/standard/stdint.h"
#include "Crx/H/crx/c/TypeBluePrint.h"
//<<END>>

CRX__LIB__C_CODE_BEGIN()

/*
	WARNING: THE IMPLEMENTATION BELOW CURRENTLY ASSUMES THAT NULL == 0
	WARNING: THE CODE BELOW CONTAINS MANY FORMAL ERRORS. THIS CODE SHOULD NOT BE USED FOR
			FORMAL REFERENCE.
*/
/* TERMINOLOGY:
		- This terminology is specific to this type only currently.
		- Index (Type 2): 
			- An index (type 2) is a key, as defined in my standard, derived from the element 
					itself. 
			- I(a) is the index derived from element 'a'.
			- An index has its own ordering defined over it. Elements must also have their own
					ordering defined over them.
			- There are two types of indices, other than the usual index defined from arrays:
				- Weak: If  I(a) != I (b)  then  a != b. But if 'a' != 'b', I(a) might be equal to
						I(b).
				- Strong: 
					- Are weak indices with extra requirements.
					- If  I(a) > I(b)  then  a > b. Note that one is an ordering over the indices,
							while the other is an ordering over the elements.
					- If  I(a) < I(b)  then  a < b. Note that one is an ordering over the indices,
							while the other is an ordering over the elements.
					- Note that if  I(a) == I(b),  the relation between 'a' and 'b' is not known.
		- Imaginary index: This is an index (Type 1), as defined in my standard, for an array
				such as the array is treated as if a -infinity element is appended to it. Hence,
				at index 0, the value is -infinity, and at index X, where X > 0, 
				the value is the element at X - 1 in the original array, meaning array[X - 1].
		- Guide: A guide is either an index (Type 2), or the element itself.
		- Element entry: This is either the element or a pointer to it. Entry can also include the
				associated index in some contexts (TODO: THIS NEEDS TO BE FIXED).
		- Transfer: Remember that formally a moving function calls the Move Construct function and
				the caller calls the Move Destruct function. Currently, from the many formal 
				violations of this code, there are functions that call the Move Construct and 
				Move Destruct themselves. These use the verb transfer. Such functions can not
				work work correctly in C++. This is why tryMoveAndInsertElement() exists the way
				it does. Notice how the operation does two moves eventually, once in 
				tryMoveAndInsertElement(), and once when the function transferAndInsertElement()
				is called. Remember, in C++, if transferAndInsertElement() was to be the
				tryMoveAndInsertElement() itself, then, being a formal violation, in C++ the Move
				Destruct function can be called twice, once explictly by code, and once by the C++
				compiler. I hope to get rid of the "transfer" functions in the future.
*/
/* NOTES:
	- BACKGROUND:
		- SORTED TREES ARE SOMETHING I AVOIDED FOR A LONG TIME IN C BECAUSE OF THE COMPLEX NATURE OF
				MY FORMAL CODE. ONE, WRITING TEMPLATES AND GENERICS IS NOT EASY, AND TWO ALL MY WORK
				ON THE CORRECT FORM IN C AND WHEN IT COMES TO WHAT PERTAINS HAS BEEN BASED ON
				ARRAYS. THIS MEANS THAT FOR DATA CONTAINERS, I NEED THEM TO BE BASED ON ARRAYS, OR
				WHAT IS CALLED IN THE STANDARD, THE NATURAL DATA TYPE. ARRAYS ARE IMPORTANT IN
				THE STANDARD, BUT THEY ARE ALSO IMPORTANT IN DIFFERENT WAYS IN C WHEN IT COMES TO
				THE CORRECT FORM. FOR EXAMPLE, ARRAYS DO NOT ALLOW FOR TYPES FROM CATEGORIES THAT
				ARE NOT OF A FIXED SIZE. HAD I IMPLEMENTED A BINARY TREE, I WOULD HAVE TO REVISE MY
				ENTIRE CODE BASE IN C WHEN IT COMES TO TEMPLATES TO ALLOW TEMPLATES BE AWARE OF THE
				PERTAINING FORMAL PARAMETERS WHEN IT COMES TO THE CATEGORIES OF TYPES. HOWEVER, THIS
				IS STILL SOMETHING THAT NEEDS TO BE DONE SOMEWHEN IN THE FUTURE. REMEMBER THAT THE
				ARRAY TEMPLATES COULD PRODUCE TYPES THAT ARE NOT OF A FIXED SIZE ALREADY, THE
				GENERICS ARE ALREADY PASSED SUCH RUNTIME INFORMATION.
				
				IN ANY CASE, I NEEDED THE PERFECT TREE, AND THE CLOSEST THAT I FOUND WAS THE AVL
				TREE. HOWEVER, I WAS NOT SATISFIED WITH THE AMOUNT OF WORK REQUIRED TO IMPLEMENT
				SUCH LIMITED DATA STRUCTURE. EVENTUALLY, I CAME ACROSS THE BTREES. BTREES WERE
				THE CLOSEST I COULD GET FOR A SORTED TREE TO AN ARRAY. AND WHEN A DESIGN IS TOO
				SPECIFIC, ONE MUST ABSTRACT, GENERALIZE, AND INSTEAD OF SEEKING THE PERFECT TREE,
				I WAS SEEKING THE PERFECT ABSTRACT TREE, THE PERFECT SET OF TREES. SIMILAR TO MY
				WORK ELSEWHERE, I WAS SEEKING A FACTOR ALGORITHM AS DEFINED IN MY STANDARD.
				
				THE FACTOR ALGORITHM STILL NEEDED TO BE THE AVL TREE, AND THIS PLAYED A BIG PART IN
				THE DESIGN OF THIS SET OF TREE. IT SHOULD ALSO BE NOTED THAT THE FACTOR THAT I
				EVENTUALLY DERIVED IS NOT FORMALLY CORRECT, STRICTLY SPEAKING, BUT I REALY DO NOT
				WANT TO COME BACK TO THIS PROJECT, I WANT TO SOLVE FOR TREES ONCE IN C AND NEVER
				COME NEAR THEM AGAIN.
				
				PART OF THE GOAL OF THE DESIGN WAS ENCOMPASSING A BTREE WITH A LOWER WORST CASE 
				MULTIPLIER WHEN IT COMES TO MEMORY CONSUMPTION. THERE IS ANOTHER BTREE THAT 
				GUARANTEES THAT IT IS NEVER LESS THAN 1/3 EMPTY, GIVING IT A MULTIPLIER OF 1.5,
				INSTEAD OF 2. HOWEVER THE 'R' DESIGN, SEE BELOW, PROVED TO EXIST, BUT NOT PASS MY 
				REQUIREMENTS. THE 'R' DESIGN EXISTING MEANS THAT THE MULTIPLIER COULD BE 
				GENERALIZED, INSTEAD OF HAVING TO EXPLICITLY IMPLEMENT ANOTHER SPECIFIC
				VALUE. THIS IS THE REASON I DID NOT TRY TO SOLVE FOR THAT SPECIFIC BTREE, AND
				BECAUSE I WAS NOT SATISFIED BY THE 'R' DESIGN BECAUSE OF ITS EFFECT TO PERFORMANCE,
				I DID NOT IMPLEMENT THE GENERALIZATION OF THE MULTIPLIER EITHER.
	- 'N'
		- INSTEAD OF ORDER, I DEFINE THE TREE SIZE BASED ON 'N'.
		- THE CAPACITY OF EACH NODE IS 2N - 1. THIS MAKES THE CAPACITY ALWAYS ODD.
		- THE NUMBER OF CHILD NODES PER NODE IS 2N. THIS MAKES THE NUMBER OF CHILD NODES EVEN.
		- IN THE CODE, N IS Tree::gPrviate_countOfMidElementInNode
		- THE SMALLEST ALLOWED NUMBER OF ENTRIES A NODE IS ALLOWED TO HOLD IS N - 1.
	- THE FACTOR ALGORITHM:
		- IS CONSERVATIVE ON THE DOWNSTREAM. THIS MEANS WHEN TREE NODES NEED TO BE MERGED, THE
				ALGORITHM TRIES TO AVOID. THIS IS PROBABLY NECESSARY FOR ANY BTREE ALROGITHM
				BECAUSE 	 TWO OR MORE NODES REQUIRES THAT THE TOTAL NUMBER OF ELEMENTS IN 
				THEM CAN INDEED BE STORED IN THE LESSER NUMBER OF NODES. REMEMBER THAT IN OUR
				ALGORITHM WE ONLY MERGE TWO NODES, AND OF COURSE, THESE ARE MERGED TO ONE NODE.
		- IS PRE EMPTIVE. THIS MEANS THAT THE ALGORITHM WILL PRE EMPTIVELY SPLIT OR MERGE NODES,
				INSTEAD OF WAITING UNTILL IT IS CERTAINLY NEEDED. THIS REDUCES THE EFFECTIVE
				'N' OF THE TREE; NODES THAT ARE FULL DO NOT LAST LONG IN THAT STATE FOR EXAMPLE.
				FORMALLY, THE REPRESENTATIVE PROBLEM OF PRE EMPTION, IF I AM NOT WRONG, IS
				THE LACK OF POINTERS TO PARENTS IN THE NODES.
		- IN A NODE, THERE ARE NOT ONE, BUT UP TO THREE VARIABLE LENGTH ARRAYS, WHICH MAKES THE
				NODE TYPE ITSELF HAVE A VARIABLE BYTE SIZE. REMEMBER THAT THIS IS A FORMAL 
				VIOLATION AS PROVEN IN MY STANDARD, BUT I DECIDED TO CONTINUE TO ALLOW MORE THAN
				ONE VARIABLE LENGTH ARRAY FOR PERFORMANCE. THE NODE IS LAYED OUT SUCH AS IT'S
				HOT REGION, ITS MOST ACCESSED REGION, IS AS CONCENTRATED AS POSSIBLE.
		- THE ALGORITHM GUARANTEES THE FOLLOWING:
			- ALL LEAVES ARE AT THE SAME DEPTH.
			- A SIBLING OF A LEAF IS A LEAF.
			- ALL PARENT NODES ARE NON LEAVES (INTERNAL NODES).
			- LEAVES REMAIN LEAVES, AND NON LEAVES REMAIN NON LEAVES. A NODE NEVER CHANGES ITS TYPE.
			- NO NODE IS EVER EMPTY. THE ALGORITHM ACTUALLY GUARANTEES N - 1 AS A MINIMUM.
			- THE LAST ENTRY IS ALWAYS IN A LEAF.
			- MEMORY ALLOCATION FAILURE IS NOT DESTRUCTIVE, DOES NOT REQUIRE RECOVERY. THIS IS
					A DEFAULT PROPERTY OF PRE EMPTION.
		- ELEMENTS(E) AND CHILD NODES(N) EFFECTIVELY FOLLOW THE FOLLOWING PATTERN,
						N E N E N E N .... E N
				NOTE HOW AN ELEMENT IS GUARANTEED TO BE BETWEEN TWO CHILD NODES.
				NOTE THAT ONLY ONE ELEMENT EXISTS BETWEEN TWO CHILD NODES.
				IF THERE ARE INDEX, I, THE PATTERN BECOMES
						N  E I  N  E I  N  E I  N .... E I  N
		- THE TREE GROWS IN HEIGHT FROM THE TOP, AND GROWS IN WIDTH BY THE NODES SPLITTING		
			- THE ROOT NODE STARTS OUTS AS A LEAF NODE, AND LIKE EVERY LEAF NODE GETS SPLIT
					ONCE FULL. WHEN SPLIT, THE ROOT NODE BECOMES A NEW INTERNAL NODE THAT GETS
					INSERTED, MAKING THE TREE HEIGHT GROW, AND THE TWO SPLIT NODES BECOME ITS 
					CHILDREN. FROM THEN ON THE ROOT REMAINS AN INTERNAL NODE AS LONG AS ELEMENTS
					ARE ONLY GETTING ADDED. THE ROOT HERE REFERS TO THE ROOT POSITION.
			- THE ALGORITHM WORKS BY FILLING LEAF NODES BEFORE SPLITTING THEM, AND
					WHEN SPLIT THEY INDIRECTLY FILL THEIR PARENT INTERNAL NODES. WHILE THE TREE 
					GROWS IN HEIGHT FROM TOP TO BOTTOM, MEANING IN TERMS OF ITS NODES WHICH ADD TO 
					THE HEIGHT, BUT IN TERMS OF ELEMENTS, THE TREE IS FILLED FROM THE BOTTOM UP. 
					INTERNAL NODES ARE ONLY FILLED BY CHILD NODES FILLING. 
	- DERIVED ALGORITHMS:
		- THIS IS A BTREE PRIMARILY. IT HAS 7 OPTIONS LEADING TO 96 VARIATIONS
		- OPTION INDEX:
			- CONTROLED BY pHAS_INDEX
			- WITHOUT INDEX: 
				- WHEN THERE IS NO INDEX, IT IS IRELEVANT WHICH ELEMENT IS FOUND WHEN
						SEARCHING THE TREE. IT IS STILL EXPECTED THAT THERE CAN BE MORE THAN ONE 
						"EQUAL" ELEMENTS. THIS IS PER THE FACTOR ALGORITHM.
				- IF THE ENTRIES OF ELEMENTS ARE STORED AT THE LEAVES ONLY, IT IS IMPORTANT THAT
						WHEN SPLITTING A LEAF NODE, THAT THE ELEMENT FROM WHICH A COPY IS 
						MOVED UP FALLS ON THE RIGHT LEAF NODE, GIVING IT N ELEMENTS, WHILE 
						N - 1 ELEMENTS FOR THE LEFT NODE. I HAVE PROVED THAT THIS RELATION WOULD 
						CONTINUE HOLDING AS THE UPPER NODES ARE SPLIT. IN OTHER WORDS, WHERE 
						THE COPY IS, IT IS GUARANTEED THAT ITS CORRESPONDING ELEMENT IS IN THE 
						SUBTREE WHOSE ROOT IS THE NODE ON THE RIGHT OF THE INDEX.
			- WITH INDEX: 
				- IT IS IMPORTANT THAT THE ELEMENT FOUND IS EQUAL TO THE ELEMENT SEARCHED FOR.
						REMEMBER THAT TWO UNEQUEAL ELEMENTS CAN HAVE TWO EQUAL INDICES.
				- IF THE ENTRIES OF ELEMENTS ARE STORED AT THE LEAVES ONLY, IT IS IMPORTANT THAT
						WHEN SPLITTING A LEAF NODE, THAT THE ELEMENT FROM WHICH THE INDEX IS 
						MOVED UP FALLS ON THE RIGHT LEAF NODE, GIVING IT N ELEMENTS, WHILE 
						N - 1 ELEMENTS FOR THE LEFT NODE. I HAVE PROVED THAT THIS RELATION WOULD 
						CONTINUE HOLDING AS THE UPPER NODES ARE SPLIT. IN OTHER WORDS, WHERE 
						THE INDEX IS, IT IS GUARANTEED THAT ITS CORRESPONDING ELEMENT IS IN THE 
						SUBTREE WHOSE ROOT IS THE NODE ON THE RIGHT OF THE INDEX.
			- THESE ARE WEAK INDICES. THIS REQUIREMENT CAME FROM THE DESIGN 
					DECISION OF HAVING AN 'EDGE' OPTION. IN TREE VARIATIONS THAT HAVE AN INDEX, 
					BUT NOT IN THE LEAVES, TO SUPPORT 'EDGE' SEARCHING, THE INDEX ITSELF OF THE 
					ELEMENTS IN THE LEAVES MUST BE USED. THIS IS BECAUSE THE ORDERING DEFINED 
					FOR THE ELEMENTS MIGHT NOT BE THE SAME AS THE ORDERING DEFINED FOR THE 
					INDICES.
			- INDICES HELP REDUCE MEMORY REQUIREMENT WITHIN THE NODE FOR ITS MOST ACCESSED
					REGION TO KEEP CPU CACHE INVALIDATION EFFECT TO A MINIMUM.
			- INDICES HELP REDUCE MEMORY REQUIREMENT WITHIN THE INTERNAL NODES WHEN THE TREE
					VARIATION IS SUCH AS THE ELEMENTS ENTRIES ARE STORED IN THE LEAVES ONLY.
					IF NO INDICES ARE USED, COPIES OF THESE ENTRIES WOULD HAVE TO BE STORED
					IN THE INTERNAL NODES TOO.
			- INDICES HELP AVOID JUMPS IN MEMORY THAT WOULD BE REQUIRED WHEN THE ELEMENTS
					ARE STORED OUTSIDE THE TREE. WITHOUT INDICES, THE TREE WOULD HAVE THE COST
					OF A BINARY TREE IN THIS CASE WHEN IT COMES TO THE CPU CACHE SYSTEM.
			- A TREE WITH AN INDEX IS NOT AN ASSOCIATIVE CONTAINER. THE INDEX CAN NEVER BE USED
					DIRECTLY BY THE USER.
			- THE INDEX TYPE MUST BE TRIVIALLY DESTRUCTABLE, AND RAW COPYABLE.
				- CURRENTLY WHEN STRICTLY SPEAKING, MOVING IS REQUIRED, AND NOT COPYING, THE CODE
						WILL MOVE INDEX, INSTEAD OF DOING THE RAW COPY, AND SIMPLY LETTING GO OF
						THE ORIGINAL. THIS WOULD ASSUME A RELATION SUCH AS TWO EQUAL INDICES UNDER
						THE INDEX ORDERING, ARE NECESSARILY BYTE WISE EQUAL.
						WHILE I TRIED TO AVOID THIS ASSUMPTION ORIGINALLY IN THE CODE, TREE THAT
						HAVE THEIR PRIMARY ENTRIES IN THE LEAVES ONLY, AND HAVE AN INDEX, WILL
						VIOLATE THIS DURING A REMOVAL OF ENTRY. THIS HAPPENS WHEN THE INDEX IS FOUND
						IN AN INTERNAL NODE. INSTEAD OF ATTEMPTING TO FIND THE EXACT INDEX FOR
						THE EXACT ELEMENT THAT IS TO BE REMOVED FROM THE LEAVES, THE ALGORITHM 
						SIMPLY STOPS AT THE FIRST INDEX FOUND. IN OTHER WORDS, WHATEVER THE ACTUAL
						INDEX THAT WAS CREATED FROM THE ELEMENT, IF ANY AT ALL, WILL BE EQUAL
						TO THE INDEX FOUND EVEN IF NOT THE ACTUAL INDEX CREATED FROM IT.
						
						IN THE FUTURE YOU MAY WANT TO ABANDON THE CURRENT APPROACH, AND ALLOW A
						FASTER ALTERNATIVE WHENEVER THE CODE CURRENTLY ATTEMPS TO MOVE AN INDEX
						AND A FASTER ALTERNATIVE IS POSSBLE.
		- OPTION WHEN INDEX USED, INDEX IN LEAVES, NO INDEX IN LEAVES: 
			- THIS IS TO ALLOW REDUCTION IN MEMORY REQUIREMENT WHEN INDICES ARE DESIRED, BUT IT 
					SACRIFICES SOME PERFORMACE. THE LEAVES ARE THE LARGEST DETERMINER OF HOW MUCH 
					MEMORY A TREE VARIATION USES WHEN THE TREE IS FULL.
			- DESIGN, HISTORY
				- WITHOUT SAVING INDICES IN LEAVES, WHEN LEAVES ARE ENCOUNTERED, THE ELEMENTS NEED 
						TO BE SIFTED THROUGH. THIS CAN BE DONE BY EITHER
					- COMPUTING THE INDEX FROM THE ELEMENTS AND THEN COMPARING THEM: THIS HAS THE
							PROBLEM OF BEING COMPUTATIONALLY EXPENSIVE BECAUSE THE INDICES ALWAYS
							HAVE TO BE COMPUTED BEFORE COMPARISON WHEN WE ARE IN THE LEAVES.
					- COMPARE THE ELEMENTS THEMSELVES: THIS APPROACH HAS THE PROBLEM THAT IT
							CREATES A REQUIREMENT IN THE ORDERING OF INDICES AS THEY RELATE TO
							THE ORDERING OF ELEMENTS. ESSENTIALLY, THE INDEX, WHICH IS TYPE 2, MUST
							BE A STRONG INDEX AS DEFINED ELSEWHERE.
				- BECAUSE OF THE REQUIREMENT OF THE "EDGE" FEATURE OF 
						Tree::Iterator::setToPositionOf() THE APPROACH USED FOR SIFTING THROUGH 
						THE LEAVES WHEN NO INDICES ARE STORED THERE MUST BE THE APPROACH THAT 
						INVOLVES COMPARING THE INDICES BY COMPUTING THEM FIRST. OTHERWISE, THE 
						"EDGE" FEATURE WOULD HAVE TO BE DISABLED IF AN OPTION IS 
						ADDED TO DECIDE ON AN APPROACH AND THE APPROACH IS TO COMPARE THE ELEMENTS 
						THEMSELVES INSTEAD. THIS IS WHY, TREE ONLY EXPECTS WEAK TYPE2 INDICES.
		- OPTION PRESISTANCE
			- PERSISTANCE. ELEMENTS STORED OUTSIDE THE TREE GIVES PERSISTANCE AS DEFINED IN MY
					FORMAL WORK.
			- ELEMENTS ARE STORED OUTSIDE THE TREE GUARANTEE A FIXED SIZE OF THEIR ENTRIES 
					WITHIN THE TREE, THE SIZE OF A POINTER. WHEN ELEMENTS ARE LARGE, STORING
					POINTERS IN THE TREE INSTEAD MAKES MODIFICATION OF THE ARRAY HOLDING
					THE ENTRIES FASTER.
			- NOTE THAT PERSISTANCE OF ELEMENTS DOES NOT EXTEND TO ITERATORS. THE ELEMENTS ARE
					ALWAYS NON PERSISTANT WITH RESPECT TO THE ITERATORS. HOWEVER AN ITERATOR USED TO
					ADD AND ELEMENT CAN BE EASILY CORRECTED, AND AN ITERATOR USED TO REMOVE AN
					ELEMENT IS ALREADY CORRECTED BY THE ALGORITHM. UNINVOLVED ITERATORS WOULD STILL
					BE INVALIDATED.
		- OPTION SEQUANTIAL ARRAYS, RINGS: 
			- THESE CONTROL THE STRUCTURE USED TO STORE THAT DATA INSIDE THE NODES. THERE ARE
					UP TO THREE ARRAYS INVOLVED, ONE FOR THE INDICES, ONE FOR THE CHILD NODES'
					POINTERS, AND ONE FOR THE ELEMENT ENTRIES. INSTEAD OF ARRAYS, RINGS
					COULD BE USED.
			- USING RINGS CAN SPEED UP MODIFICATION OF THE NODES, BUT USES MORE MEMORY. EXTRA
					MEMORY IS USED TO STORE THE START INDEX, AND EXTRA MEMORY IS USED TO
					KEEP THE SIZE OF ALL ARRAYS IN THE NODE 2^X WHERE X IS A POSITIVE NATURAL
					NUMBER. REMEMBER, THERE ARE  2N - 1  INDICES, AND ELEMENTS, AND 2^N 
					CHILD NODES, IN EACH NODE. WHEN RINGS ARE USED, THE ARRAYS HOLDING THE
					ELEMENTS ARE INDICES HAVE 2N ACTUAL CAPACITY, BUT THEIR EFFECTIVE CAPACITY
					REMAINS  2N - 1.
		- OPTION PRIMARY ELEMENT ENTRIES ARE FOUND IN ALL NODES, PRIMARY ELEMENT ENTRIES ARE FOUND 
				IN LEAVES ONLY.
			- WHEN THE PRIMARY ELEMENT ENTRIES ARE FOUND IN LEAVES ONLY, ITERATION RATE, AS DEFINED 
					IN MY STANDARD, IS FASTER. THE LEAVES BECOME A LINKED LIST OF ARRAYS OF 
					VARIABLE CURRENT SIZE, BUT EQUAL CAPACITY.
			- ALL ENTRIES ARE PRIMARY IF THE PRIMARY ENTRIES ARE NOT IN THE LEAVES ONLY.
					OTHERWISE, ENTRIES THAT ARE NOT IN THE LEAVES ARE NOT PRIMARY, AND ARE EITHER
					COPIES OF SOME OF THE PRIMARY ENTRIES IN THE LEAVES, OR INDICES OF SOME OF THE
					PRIMARY ENTRIES IN THE LEAVES. NOTE THAT A COPY OF AN ENTRY COULD BE EITHER A
					COPY OF THE ELEMENT, OR A POINTER TO THE ELEMENT DEPENDING ON PERSISTANCE.
			- WHEN THE PRIMARY ELEMENT ENTRIES ARE IN THE LEAVES ONLY, AND NO INDEX IS USED, THEREBY
					REQUIRING A COPY OF THE ELEMENT ENTRIES, AND IF THE TREE IS NOT PERSISTANCE, IT
					BECOMES MANDATORY THAT THE ELEMENTS THEMSELVES ARE COPIED INTO THE INTERNAL
					NODES. HENCE, IN THIS CASE IF THE ELEMENT TYPE IS NOT COPYABLE, SUCH A TREE
					IS IMPOSSIBLE. NOTE THAT IF ONE WOULD RESORT TO USING POINTERS TO THE ELEMENTS
					IN THE LEAVES IN THIS CASE, THE ALGORITHM WOULD STILL NOT WORK WITHOUT CONSTANT
					CORRECTION BECAUSE THOSE ELEMENTS IN THE LEAVES WOULD MOVE AROUND.
					CURRENTLY, I DECIDED NOT TO ADD SUPPORT FOR THIS SCENARIO. THIS MAKES THE
					IMPLEMENTATOIN INCOMPLETE.
		- OPTION CONSERVATIVE ALGORITHM, NORMAL ALGORITHM.
			- THE CONSERVATIVE ALGORITHM IS ALSO CONSERVATIVE ON THE UPSTREAM, TRYING TO AVOID NODE 
					SPLITTING IF POSSIBLE. 
			- THIS DOES NOT CHANGE THE WORST CASE SCENARIO OF MEMORY CONSUMPTION OF SUCH TREE,
					VARIATIONS BUT MAKES THIS SCENARIO LESS LIKELY. THIS IS IMPORTANT BECAUSE
					WITH THE NORMAL ALGORITHM IT IS VERY EASY TO HIT THE WORST SCENARIO, MEANING
					THE TREE ALWAYS ONLY HALF FULL. THIS HAPPENS IF THE TREE IS FILLED WITH
					ORDERED DATA, OR SEMI ORDERED DATA (STRONGLY ORDERED DATA AS I CALL IT 
					ELSEWHERE).
		- OPTION PRE EMPTIVE ALGORITHM, NON PRE EMPTIVE ALGORITHM.
			- IT WAS DECIDED THAT DELETING ENTRIES WHILE LOOPING OVER THE TREE SHOULD BE SUPPORTED.
					THIS WAS PRIMARILY FOR THE PERCIEVED SPEED THAT COULD OFFER FOR DELETION, BUT
					IT ALSO ADDING SUPPORT TO AN ITERATOR THAT WOULD NOT BE INVALIDATED IF DELETION
					HAPPENS BY IT.

					SUCH A DELETION WOULD START WITH EXACTLY THE ELEMENT ENTRY TO DELETE, AND NOW
					THE ALGORITHM WOULD HAVE TO MOVE UP TO ACCOUNT FOR ANY NODE MERGER. IF THE
					TREE IS SUCH AS ELEMENT ENTRIES ARE STORED IN ALL NODES, THIS IS NOT A PROBLEM
					BECAUSE ITS ITERATOR HAS A TRACE THAT ALLOWS TRAVERSING UP THE TREE, MEANING
					NODE PARENTS AND THE INDICES OF THE CHILD NODES THAT GOT US TO THE PARENTS.
					HOWEVER IF THE TREE ONLY ALLOWS ELEMENT ENTRIES IN THE LEAVES, THIS DELETE
					OPERATION CAN NO LONGER BE DONE EFFICIENTLY. YOU WOULD STILL HAVE TO START
					FROM THE TOP TO DO THE DELETION AND SEARCH FOR THE EXACT ELEMENT ENTRY POINTED
					TO BY THE ITERATOR.
					
					BECAUSE OF THIS, I HAD TO INTRODUCE A PARENT NODE POINTER IN THE NODE TYPE. 
					THIS UNDOES A MAIN APPLICATION OF THE PREEMPTIVE ALGORITHM, WHICH IS AVOIDING
					A PARENT NODE POINTER DATA MEMBER IN NODES.

					THE NEW NON PRE EMPTIVE ALGORITHM IN INSERTION CONTINUES TO RESEMBLE THE PRE
					EMPTIVE ALGORITHM BY GOING UP THE TREE STEP BY STEP UNTIL IT IS NO LONGER
					REQUIRED TO SPLIT NODES, THEN GO BACK DOWN AND SPLIT THE NODES. THE REASON
					FOR THIS IS TO ALLOW ERROR RECOVERY. WITH THIS APPROACH IF AN ALLOCATION 
					ERROR HAPPENS WHILE MOVING DOWN, WHICH IS THE SAME WITH THE PRE EMPTIVE
					ALGORITHM, IT IS NOT A PROBLEM. ON THE OTHER IF SPLITTING BEGAN FROM THE
					BOTTOM, AND AN ALLOCATION ERROR HAPPENS AS WE ARE MOVING UP, RECOVERY IS
					BOTH NECESSARY AND DIFFICULT.
					
					WHEN IT COMES TO DELETION, IT WAS NOT NECESSARY TO IMPLEMENT A NEW ALGORITHM
					FOR THE NON PRE EMPTIVE CASE, AND THAT WOULD HAVE BEEN DESIRABLE BECAUSE IT
					MAKES THE TREE MORE CONSERVATIVE WHEN IT COMES TO MEMORY CONSUMPTION. HOWEVER
					I DECIDED TO IMPLEMENT AN ALGORITHM FOR THE NON PRE EMPTIVE CASE FOR DELETION
					TO KEEP SYMMETRY.
					
					NOTE THAT WHEN THE OPTION FOR THE NON PRE EMPTIVE ALGORITHM IS ENABLED, THE
					NODES WOULD HAVE POINTERS TO THEIR PARENTS. ALSO NOTE THAT WHILE DELETION BASED
					ON ITERATORS ON TRESS THAT ONLY ALLOW ELEMENT ENTRIES IN THE LEAVES WOULD NO
					LONGER REQUIRE US TRAVERSING THE TREE FROM THE VERY TOP, WE STILL REQUIRE
					WHEN GETTING TO A PARENT TO SEARCH FOR THE IMMEDIATE CHILD THAT WE GOT THERE
					FROM.
		- OPTIONS DELEGATION OR NO DELEGATION.
			- DELEGATION IS FOR TREES THAT HAVE THE PRIMARY ENTRIES IN THE LEAVES ONLY.
			- DELEGATION MEANS THAT THE ENTRIES IN THE INTERNAL NODES ALWAYS HAVE A CORRESPONDING
					ENTRY IN THE LEAVES. IDEALLY, THE CORRESPONDING ENTRIES MUST BE THE VERY SAME
					ENTRIES USED TO CREATE THE ENTRIES IN THE LEAVES. HOWEVER, THE CODE BELOW DOES
					NOT ACHIEVE THAT, AND INSTEAD BYTE EQUALITY IS ASSUMED WHEN DEALING WITH LOGICAL
					EQUALITY. THIS MEANS THAT, GIVEN AN ENTRY IN THE INTERNAL NODES FOR EXAMPLE, AND
					ASSUMIONG THE TREE HAS NO INDEX, THEN IT IS GUARANTEED THAT THERE EXISTS, AND
					WHERE IT SHOULD, A PRIMARY ENTRY SUCH AS THE ELEMENT IS LOGICALL EQUAL TO THE 
					ELEMENT IN THE INTERNAL NODE. REMEMBER THAT ALL PRIMARY ENTRIES ARE IN THE
					LEAVES.
			- ORIGINALLY DELEGATION WAS USED FOR ALL TREES. DURING THE VERIFICATION WORK OF
					THE TWO REMOVAL FUNCTIONS, A CASE WAS DISCOVERED THAT MEANT THAT 'N' MUST
					ALWAYS BE LARGER THAN 2, RATHER THAN 1 AS IT WAS PREVIOUSLY, BUT NOT FOR
					ALL THE TREE. SEE THE HISTORY BELOW.
					
					ALLOWING TREE WITHOUT DELEGATION, WOULD ALLOW N TO BE AS SMALL AS 2, AND ALSO
					ALLOW THE REMOVAL FUNCTION THAT IS ON Tree::Iterator TO WORK FASTER FOR SUCH
					TREES. I ALMOST DECIDED TO REMOVE DELEGATION ALL TOGETHER, BUT SOME OF THE
					TREE END UP USING MORE MEMORY IF DELEGATION IS NOT USED. SEE THE HISTORY
					BELOW.
					
					IN THE END, I WAS UNABLE TO DEDUCE A REPRESENTATIVE PROBLEM FOR DELEGATION,
					AND DECIDED TO ADD IT AS A 'FEATURE' AS IS UNFORTUANTELY.
			- HISTORY
					(THE FOLLOWING WERE NOTES FOR Tree::construct())
					NOTE THAT WHEN THE PRIMARY ENTRIES ARE IN THE LEAVES ONLY, AND THE ALGORITHM
						IS NOT PREEMPTIVE, 'N' MUST BE LARGER THAN 2. REMEMEBER THAT THE SMALLEST
						LENGTH ALLOWED FOR A NODE IS N - 1, BUT DURING REMOVAL, IF THE ALGORITHM
						IS NOT PRE EMPTIVE, A NODE CAN BRIEFLY HAVE A LENGTH OF N - 2 BEFORE THE
						SITUATION IS CORRECT, MEANING BEFORE THE NODE IS MERGED WITH ANOTHER. IF
						N IS 2, THE NODE CAN BE BRIEFLY EMPTY. REMEMBER THAT WHEN THE PRIMARY 
						ENTRIES ARE IN THE LEAVES ONLY, HOISTING IS SUCH AS AFTER DELETION OF THE
						FOUND ELEMENT FROM THE LEAF, THE A COPY OF THE FIRST ELEMENT IN THE LEAF,
						OR AN INDEX, IS TO BE HOISTED UP, AND HENCE THERE HAS TO BE ONE ELEMENT
						REMAINING. THIS IS UNLIKE THE CAUSE WHERE THE PRIMARY ENTRIES ARE STORED
						IN ALL NODES, BECAUSE IN THAT CASE HOISTING INVOLVES THE VERY ELEMENT TO
						BE PASSED UP, NOT A COPY OF IT OR ONLY AN INDEX.
						
						A SOLUTION TO KEEPING THE REQUIREMENT N >= 2 FOR ALL THE TREES IS TO AVOID
						THE USE OF DELEGATES IN THE TREES THAT HAVE THE PRIMARY ENTRIES IN THE 
						LEAVES ONLY, AND REMEMBER THAT FOR OTHER TREES, THERE ARE NO DELEGATES. THIS 
						MEANS THAT DURING INSERTION 'DELEGATES' ARE CREATED FROM THE ELEMENTS AS 
						NECESSARY WHEN ELEMENTS ARE INSERTED. HOWEVER, DURING REMOVAL A DELEGATE IS 
						NOT REMOVED SIMPLY BECAUSE WHAT IT IS A DELEGATE FOR HAS BEEN REMOVED. THIS 
						MAKES IT NOT TRULY A DELEGATE. HOWEVER NOTE THE FOLLOWING,
								- IF ENTRIES IN INTERNAL NODES ARE NOT DELEGATES:
									- TREES THAT ARE PERSISTANT AND DO NOT USE AN INDEX WOULD NOT
											WORK. THESE MUST USE DELEGATES AS ENTRIES IN THE
											INTERNAL NODES, BECAUSE THESE ENTRIES ARE POINTERS
											TO ELEMENTS, THE SAME ELEMENTS POINTED TO BY THE
											LEAVES, UNLESS WE WANT TO MAKE COPIES OF THOSE ELEMENTS
											AS WELL.
									- REMOVAL BY ITERATOR WOULD BE MUCH CHEAPER IN GENERAL BECAUSE
											WE NO LONGER NEED TO REMOVE THE DELEGATE, AND HENCE
											FOR TREES THAT REQUIRE A TRACE CREATED BECAUSE THE
											ITERATOR ITSELF DOES NOT HAS IT, THE CREATION CAN MORE
											OFTEN BE AVOIDED.
									- A SEARCHING OF EXISTANCE WOULD BE SLOWER. WITH DELEGATES, A
											SEARCH OF EXISTANCE CAN BE MADE FASTER WHEN DELEGATES
											ARE COPIES OF THE ELEMENTS OR THEIR POINTERS. IF
											THE ENTRIES IN THE INTERNAL NODES ARE NOT DELEGATES,
											SEARCHING ALWAYS HAS TO GO TO THE LEAVES WHERE THE
											PRIMARY ENTRIES ARE.
								- THE N >= 3 PROBLEM ONLY EXISTS WHEN THE ALGORITHM IS NOT PRE 
										EMPTIVE. MEANING ONLY THEN, AND WHEN DEALING WITH THESE 
										TREES, MEANING TREES THAT HAVE THE PRIMARY ENTRIES IN THE 
										LEAVES ONLY, MUST N >= 3. HOWEVER, THE VERY COSTLY TRACE 
										CALCULATION FOR REMOVAL BY ITERATOR HAPPENS WHEN THE 
										ALGORITHM IS PRE EMPTIVE, MEANING WHERE NODES HAVE NO 
										POINTERS TO THEIR PARENT NODES. HAVING NO DELEGATES SOLVES
										BOTH PROBLEMS, AND THEREFOR THE REPRESENTATIVE PROBLEM OF 
										THE EXISTANCE OF DELEGATES CAN NOT BE IN TERMS OF PRE 
										EMPTION.
								- CURRENTLY, OUR DELEGATES ARE LIMITED BECAUSE THEY ARE IMPLEMENTED 
										SUCH AS, IF THEY ARE INDICES, THEY EXPECT LOGICALLY EQUAL 
										INDICES TO BE BINARY EQUAL, OR AT LEAST IF THEY ARE NOT, THE 
										BINARY INEQUALITY NOT TO MATTER.
		- ALGORITHM DESIGN/HISTORY
			- I FAILED AT TRYING TO GENERALIZE THE ALGORITHM OF AVL TREE SUCH AS THE BTREE CAN TRANSFORM
					TO IT UNDER CERTAIN CONFIGURATIONS. BINARY TREES BENEFIT FROM BEING ABLE TO DEFINE
					A DIFFERENTIAL BETWEEN THE NODES. IN PARTICULAR THE DIFFERENTIAL BETWEEN THE HIGHT
					OF THE SUBTREE THAT IS THE LEFT NODE, AND THE HEIGHT OF THE SUBTREE THAT IS THE
					RIGHT NODE, WHICH IS WHAT AN AVL TREE RELIES ON. I WAS UNABLE TO DEFINE SUCH A 
					DIFFERENTIAL FOR THE BTREE NODES SUCH AS IT IS USEFUL. IN THE END, YOU INSTEAD NEED
					TO STORE THE ACTUAL HEIGHT AT EACH NODE. AN ALGORITHM RELYING ON THE WHOLE NUMBER
					CAN NOT TRANSFORM TRIVIALLY TO AN ALGORITHM THAT RELIES ON DIFFERENTIALS INSTEAD.
			- R DESIGN
				- IT IS GUARANTEED THAT NO LEAF IS EMPTY, UNLESS IT IS THE ROOT. HENCE, N - 1, THE 
						MINIMAL NUMBER OF ELEMENTS IN A NODE, MUST NOT BE ZERO, MEANING N MUST BE 
						BIGGER THAN 1. IF YOU LATER INTRODUCE A 'R' FEATURE TO DELAY JOINING OF 
						NODES, THEN N - R, MUST NOT BE ZERO, MEANING N > R. 
						REMEMBER, I SHALL BE NOT PERSUING THE R DESIGN. THE ABOVE IS HISTORY ONLY.
				- 'r'
					- THIS WOULD CONTROL THE SMALLEST NUMBER OF ELEMENTS NODES MUST HOLD.
					- IF 0, 'r' IS EFFECTIVELY 1, BUT THE REMOVED NODES ARE KEPT IN A POOL INSTEAD 
							OF FREED.
					- AT FIRST GLANCE, 2N - 1 > r, BUT INSTEAD IT MUST BE THAT N > r.
							IF r > N - 1, MEANING r >= N, YOU NEED AN ALGORITHM THAT WHEN MERGING 
							THE NODES, ENDS UP CREATING A NEW THIRD NODE, INSTEAD OF MERGING THE 
							TWO. THIS IS BECAUSE THE SUM OF THE ELEMENTS IN BOTH NODES WOULD BE 
							LARGER THAN WHAT A SINGLE NODE CAN CARRY. HENCE,
									N > r
							FOR THE CURRENT ALGORITHM BELOW.
							NOTE THAT FOR r > N - 1, AN ALGORITHM CAN NOT EXIST FOR ADDITION, 
							MEANING FOR SPLITTING THE NODE WHEN FULL WHILE MAINTAINING r. CONSIDER 
							SIMPLY SHARING WITH THE NEXT NODE, AND NOW THEY ARE BOTH FULL. GIVEN, 
							AS AN EXAMPLE, 2N - 1 = 15, THE TWO NODES HAVE 30 ELEMENTS. SHARING 
							WITH A NEW THIRD NODE, LEAVES EACH WITH 10 ELEMENTS. IF r WAS 12, THIS 
							WOULD HAVE VIOLATED THE REQUIREMENT. WE WOULD HAVE TO INCREASE THE 
							NUMBER OF ADJACENT NODES TO BE EXAMINED TO DIVIDE THE ELEMENTS BETWEEN 
							THEM TO ACHIEVE THE GRANUALITY. THIS IS A TEDIOUS COMPUTATION. AS FOR 
							DELETION, AN ALGORITHM FOR DELETION CAN NOT BE PREEMPTIVE. THIS IS 
							BECAUSE THE ALGORITHM IS GOING TO ENCOUNTER THE 'VIOLATING' NODES 
							CONTAINING 10 IN OUR EXAMPLE, AND MUST LEAVE THEM ALONE. IF IT IS NOT
							PREEMPTIVE, MEANING THE ALGORITHM ADDRESSES THE UNDER FILLED NODES WHEN 
							NEEDED, MEANING WHEN THE NODE LOSING THE ELEMENT HAS LESS THAN r, 12 IN 
							OUR EXAMPLE, THE ALGORITHM WOULD HAVE TO SHARE THE REMAINING NODES WITH 
							ADJACENT NODES, AND THESE MIGHT NOT HAVE ENOUGH SPACE FOR THESE 12. 
							HENCE r CAN NOT BE ARIBITRARILY LARGER THAN N - 1. IN OTHER WORDS, 
							TO SOLVE THIS, WE WOULD NEED TO ENSURE THAT AFTER SPLITTING ALL NODES
							HAVE EXACTLY 12, OR ATLEAST MORE THAN 12. IN OUR EXAMPLE WE WOULD NEED
							TO SPLIT 4 NODES INTO 5, BUT THIS BRINGS US BACK TO THE TEDIOUS
							COMPUTATION.
							
							NOTE THAT THE B* TREE VARIATION ESSENTIALLY HAS r SUCH AS IT AMOUNTS 
							TO 2/3 THE NUMBER OF ELEMENTS A NODE CAN HAVE. COMBINING THIS RESULT, 
							WITH THE ANALYSIS PERTAINING TO MEMORY USAGE AND BEATING THE AVL TREE 
							LEADS TO THE CONCLUSION THAT AN 'r' OPTION IS CURRENTLY NOT USEFUL.
					- WHEN 'r' IS 1, THE WORST CASE HEIGHT IS STIL SMALLER THAN 64 ON 64BIT SYSTEMS
				- r2
					- THIS WOULD CONTROL THE SMALLEST NUMBER OF ELEMENTS NODES MUST HOLD. IT IS 
							MEANT TO SOMEWHAT SOLVE THE DIFFICULTY OF r OVER THE 50% RANGE.
					- r2 > 1
					- THE GUARANTEED MINIMAL NUMBER OF ELEMENTS IN A NODE WOULD REMAIN N - 1.
					- THE CONTENT OF THE NODES MUST BE STORED IN A RING, NOT AN ARRAY.
					- r2 WOULD KICK IN DURING THE SAME PRE EMPTIVE ALGORITHM THAT IS EMPLOYED.
					- A NODE THAT HAS MORE THAN 2N - r2 ELEMENTS MUST CHECK ITS TWO ADJACENT 
							SIBLINGS, AND PASS ONE ELEMENT TO EITHER ONE THAT HAD LESS THAN 
							2N - r2 ELEMENTS.
					- THIS APPROACH DOES NOT CHANGE THE WORST CASE SCENARIO FOR MEMORY CONSUMPTIONS 
							IN THE SCENARIOS OF COMPETING WITH THE AVL, MEANING IN THE FREQUENT 
							MODIFICATION SCENARIO AND THE REQUIRED OTHER OPTIONS TO INSTANTIATE 
							THE TREE. HOWEVER, THE WORST CASE SCENARIO IS MADE LESS LIKELY WITH 
							THIS APPROACH. INSERTION OF ORDERED DATA WOULD NO LONGER AMOUNT TO A 
							HALF FULL TREE, FOR EXAMPLE.
					- THE PROBLEM WITH THIS APPROACH IS THAT ONCE A PARTICULAR NODE AND ITS TWO 
							ADJACENT SIBLINGSS HAS 2N - r2 OR MORE ELEMENTS, THE NODE CAN BE BECOME 
							"HAMMERED". THIS MEANS THAT EVERY TIME AN INSERTION IS REQUIRED IN THE 
							DECENDENTS OF THAT NODE, THE NODE'S ADJACENT NODES WOULD BE CHECKED 
							EVEN THOUGH NOTHING WILL BE DONE. THE HAMMERING CAN BE REDUCED BY A 
							FLAG ON THE NODE THAT IT WOULD SET WHEN IT SEES ITS ADJACENT REQUIRE NO 
							MORE ELEMENTS, AND NODE WOULD UNSET ON ITS ADJACENTS WHEN IT LOSES AN 
							ELEMENT SUCH AS IT NOW HAS LESS THAN 2N - r2.
					- THE AIM OF r2 IS NOT SIMPLY TO REDUCE THE LIKELY HOOD OR THE WORST CASE 
							SCENARIO, BUT TO MAKE IT MORE DIFFICULT FOR AN 'ATTACKER' TO THROW THE 
							TREE OFF AND MAKE IT HIT THE WORST CASE. HOWEVER, ANY r2 OTHER THAN 2 
							MAKES THINGS WORSE. THIS IS THE BIRTH OF THE CONSERVATIVE ALGORITHM 
							MEANTIONED ELSEWHERE.
				- THE CONSERVATIVE ALGORITHM:
					- SIMILAR TO HOW THE ALGORITHM FOR r2 WOULD HAVE WORKED, BUT DURING INSERTION, 
							THE ALGORITHM CHECKS A NODE AS IT PASSES IT, AND ONLY MOVES AN ELEMENT 
							TO ONE OF ITS ADJACENT IF THE NODE HAS 2N - 1 ELEMENTS, AND THE 
							ADJACENT MOVED TO HAS LESS THAN 2N - 2 ELEMENTS.
					- LIKE THE r2 ALGORITHM, THE GUARANTEED MINIMAL NUMBER OF ELEMENTS IN A NODE IS 
							STILL N - 1.
					- LIKE THE r2 ALGORITHM, THE WORST CASE MEMORY USAGE UNDER THE CONDITIONS OF 
							BEATING THE AVL TREE IS NOT CHANGED.
					- NOTE THAT WHEN IT COMES TO THE RING, NO MORE MEMORY WOULD BE USED IN THE NODE. 
							THIS IS BECAUSE THE PADDING BYTES WILL BE USED FOR THE NEW DATA REQUIRED 
							FOR THE RING. 
							HOWEVER, WHEN INTRODUCING THE OPTION OF NOT ALLOWING A RUNTIME CHOICE 
							FOR N, THE PADDING BYTES MIGHT BE SMALLER THAN THE EXTARA MEMORY 
							REQUIRED BY THE RING, AND THE RING WOULD USE MORE MEMORY.
				- Memory usage:
					- Most memory is used by the leaves. Given our factor algorithm, a tree with
							N child nodes has roughly (N - 1)/N of its nodes as leaf nodes. If N is 
							10, that is 90% of the nodes.
					- The main factor costing us when it to comes to memory consumption and trying 
							to beat a binary tree is the worst case scenario of the B-Tree being 
							its nodes only  half full.
					- Beating the AVL tree. 
						- It is desirable to beat the AVL tree, in terms of speed under frequent 
								modifiction. When the tree below is configured for that, it is also 
								desirable that it is not worse than the AVL tree in terms of memory 
								usage.
						- Given:
										E: byte size of element
										P: byte size of pointer
										I: byte size of index
										S: number of elements per node.
										Q: proportion of S that may be empty in a node. Strictly, it is
												1 - ((N - 1) / (2N - 1)) = 1 - ((S - 1) / 2S)
								The AVL tree itself uses
										E + 3P
								bytes per element. This assumes a parent pointer in each node, and this 
								seems to be the necessary case in C++ std usage of trees, such as 
								::std::map. To beat the AVL tree under frequent modification, and keeping 
								in mind that in general Q is roughly 1/2, and in the worst case scenario, 
								S is 3, and in which case Q is 2/3, one could
							- Save elements outside the tree, and keep an index, and no parent pointers 
									in nodes. Average memory usage per element: 
											(1/(1-Q))(((2P + I + P/S) + (P + I)S) / (1 + S)) + E
									Therefore, when Q is 1/2, it would be required that
											(2(2P + I + P/S) + 2(P + I)S) / (1 + S) + E < E + 3P
														=>							 2I < P   ;S => INF
									And if S is 3 and P = 4 (therefore 1/1-Q = 3),
																				4P + 3I < 3P
																				16 + 3I < 12
																					 3I < -4
									In other words, we are always using more memory than the binary tree
									in the worst case.
									
									If indices are not allowed in the nodes, the above becomes,
											(1/(1-Q))(((2P + I + P/S) + PS) / (1 + S)) + E
									and when Q is 1/2
																					  0 < P		;S => INF
									And if S is 3 and P = 4 (therefore 1/1-Q = 3),
																			4P + (3/4)I < 3P
																			16 + (3/4)I < 12
																					  I < -8/3
									In other words, we still do not beat the binary tree in the worst case
									even when indices are not allowed in the leaves.
							- Save elements inside the tree and without an index, and no parent pointers in 
									nodes. Memory usage per element: (1/(1-Q))(E + P + P/S)
									Average memory usage per element: 
											(1/(1-Q))(((P + E + P/S) + ES) / (1 + S))
									Therefore, when Q is 1/2, it would be required that
													  (2(P + E + P/S) + 2ES) / (1 + S) < E + 3P
														=> 							  E < 3P	; S => INF
									And if S is 3 and P = 4 (therefore 1/1-Q = 3),
																				 P + 3E < E + 3P
																					 2E < 8
																					  E < 4
						- The above shows that using the option 'r' to try and beat the AVL under frequent 
								modification, meaning a small 'r', or atleast 'r' < N - 1, is not viable. A 
								small 'r' makes 'Q', above, closer to 1, leading to more wasted space in 
								the worst case scenario.
						- Note that the calculations above takes an average of (S + 1) nodes, where S nodes
								would be leaves, and 1 node would be internal.
								It also uses (1/(1-Q)) as multiplier for the worst case used space.
			- PROBLEMS TO AVOID:
				- THE PING PONG EFFECT: THIS IS DEFINED AS THE EFFECT OF SIBLING NODES PASSING THE SAME
						ELEMENT BACK AND FORTH BETWEEN THEM BETWEEN ONE OPERATION AND THE OTHER. THIS IS 
						WHY IN THE r2 DESIGN, A FULL NODE ONLY PASS AN ELEMENT TO ITS SIBLING IF THE 
						SIBLING AFTER GETTING THE ELEMENT IS NOT FULL.
				- HAMMERING: THIS IS DEFINED AS THE EFFECT OF A NODE CONTINOUSLY SPLITTING AND MERGING
						BETWEEN ONE OPERATION AND ANOTHER. DESPITE MY WORK ON THE r2 DESIGN, THE CURRENT
						ALGORITHM CONTINUES TO SUFFER FROM HAMMERING. THIS HAPPENS WHEN A LEAF NODE
						AND ITS SIBLING HAVE EXACTLY THE MINIMAL REQUIRED NUMBER OF ELEMENTS, AND AN
						ELEMENT THAT WOULD LAND IN IT IS CONTINUOUSLY ADDED AND REMOVED ONE OPERATION
						AFTER ANOTHER. A LEAF NODE WOULD CONTINUOSLY SPLIT OR JOIN EVERY OPERATION.
						
						THIS IS THE REASON I DO NOT ALLOW AUTOMATIC SHRINKING OF CONTAINERS. TO SOLVE
						THIS ISSUE FOR THE BTREE, ONE COULD EMPLOY THE SAME RULE AND FORBID NODE MERGER,
						BUT A BTREE WITH EMPTY NODES IS A CONTRADICTION BECAUSE YOU WOULD NO LONGER FIND
						YOUR WAY DOWN PAST SUCH NODES BECAUSE THERE ARE NO VALUES TO COMPARE TO TO FIND
						YOUR DIRECTION.
			- BIT FIELD USAGE:
				- ORIGINALLY I ALLOWED MYSELF TO USE BIT FIELDS FOR THE TREE. HOWEVER, NOW THAT THE
						CODE IS TO WORK UNDER COMPATIBILITY LEVEL 4, AS COMPATIBILITY LEVELS ARE
						DEFINED IN MY STANDARD, THE USAGE OF BIT FIELDS IS NO LONGER ALLOWED. TO
						KEEP THINGS EASY FOR THE TIME BEING, I AVOIDED MANUAL BIT MANIPULATION
						AND INSTEAD USED FULL TYPES FOR EACH OF THE ORIGINAL FIELDS IN THE BIT
						FIELDS.
	- Tree
		- Tree::construct()
			- THERE ARE FOUR OVERLOADS:
				1- THE USER IS EXPECTED TO PASS 'N'. THIS IS MEANT FOR EXACT SETUP OF THE NODE.
						HOWEVER, THE INSTANTIATED TREE MIGHT STILL END UP WITH A DIFFERENT 'N'.
						THIS HAPPENS IF 'N' IS SMALLER THAN 2, OR IF DELEGATION IS USED, IF
						'N' IS SMALLER THAN 3, OR RINGS ARE USED IN THE NODES, AND 'N' IS NOT A 
						POWER OF 2, MEANING A NUMBER SUCH AS IT IS EQUAL TO 2^X, WHERE X IS A 
						POSITIVE NATURAL NUMBER. IN THIS CASE, THE RESULT 'N' WILL BE LARGER THAN 
						WHAT THE USER PASSED.
				2- THE USER IS EXPECTED TO PASS THE DESIRED CAPACITY OF THE NODE. THIS IS MEANT
						FOR AN EXPLICIT CONTROL OVER THE CAPACITY OF A NODE. THE RESULTING NODES
						ARE GUARANTEED TO HAVE THAT CAPACITY OR LARGER UNLESS THE USER PASSES
						A VALUE LARGER THAN THE ALLOWED MAXIMUM CAPACITY, WHICH IS
						UINT32_MAX / 2.
				3- THE USER IS EXPECTED TO PASS THE DESIRED BYTE SIZE OF THE NODE. THIS IS MEANT
						TO ALLOW THE USER TO FIT THE NODE WITHIN SPECIFIC MAXIMUM SIZE AS TO PLAY
						WELL THE CPU CACHE SYSTEM. THIS OVERLOAD WILL TRY TO GIVE THE DESIRED
						BYTE SIZE OR LESS FOR THE NODES. HOWEVER, IN SOME CASES, IT MIGHT GIVE
						MORE THAN WHAT WAS DESIRED. THIS HAPPENS WHEN THE RESULTING 'N' IS SUCH
						AS THE FIRST OVERLOAD ABOVE WILL LEAD TO A TREE WITH A HIGHER 'N'. 
						THE USER IS ALSO ABLE TO SET THE BYTE SIZE OF THE LEAF NODE INSTEAD OF THE
						INTERNAL NODE.
				4- THE USER IS EXPECTED TO PASS THE DESIRED BYTE SIZE OF THE HOT REGION OF THE
						NODE. THIS REGION SPANS FROM THE BEGINNING OF THE NODE TO A POINT SOMEWHERE
						IN IT. THIS REGION IS WHERE MOST OF THE WORK HAPPENS. THIS OVERLOAD WILL 
						TRY TO GIVE THE DESIRED	BYTE SIZE OR LESS FOR THE HOT REGION. HOWEVER, IN 
						SOME CASES, IT MIGHT GIVE MORE THAN WHAT WAS DESIRED. THIS HAPPENS WHEN THE 
						RESULTING 'N' IS SUCH AS THE FIRST OVERLOAD ABOVE WILL LEAD TO A TREE WITH 
						A HIGHER 'N'.
						IF THE LEAVES HAVE A HOT REGION LARGER THAN THAT OF THE HOT REGION OF
						THE INTERNAL NODES, THE LEAVES ARE USED INSTEAD FOR THE CALCULATION.
		- Tree::copyConstruct()
			- REMEMBER THAT DATA CONTAINERS MAY NOT AUTOMATICALLY SHRINK BECAUSE OF THE PING PONG
					EFFECT. WHILE FORMALLY, THERE EXISTS A FUNCTION TO SHRINK A CONTAINER SUCH
					AS IT USES THE LOWEST AMOUNT OF MEMORY GIVEN ITS CONTENT, I DO NOT IMPLEMENT
					THIS FUNCTION. THIS FUNCTION IS FOR THEORATICAL PURPOSES PRIMARILY. 
					ALTERNATIVELY, I MAKE THE COPY CONSTRUCT FUNCTIONS DO THE JOB OF THAT FUNCTION, 
					ROUGHLY IF NOT EXACTLY. REMEMBER THAT DESIGNS OF DATA CONTAINERS ARE TO BE BASED 
					ON ARRAYS. WITH THIS IN MIND, GIVEN THAT ARRAYS AFTER THE 'SHRINKING' EFFECT OF 
					A COPY CONSTRUCT WOULD STILL WASTE 0%-50% OF THE HELD MEMORY, I HAVE FINALLY 
					DECIDED NOT TO IMPLEMENT THE TREE'S COPY CONSTRUCT SUCH AS TO 'SHRINK' THE 
					CONTAINER.
			- THE FOLLOWING ARE ALGORITHMS, OR PART OF ALGORITHMS, THAT I DESIGNED AND CONSIDERED 
					FOR THE COPY CONSTRUCT WHICH WOULD FREE AS MUCH SPACE OCCUPIED BY THE TREE AS 
					POSSIBLE. THE DESIGNS WERE DONE IN MY HEAD, SO MATHEMATICAL VERIFICATION
					WOULD BE REQUIRED.
				- THE TREES ARE MODELED AS A SET OF 'x' BALANCED BTREES, ALL WITH THE SAME HEIGHT,
						'h'. BALANCED MEANS THAT ALL NODES IN THE TREE HOLD THE MINIMUM REQUIRED
						AMOUNT OF CONTENT OR MORE, AND ALL LEAVES ARE AT THE SAME LEVEL.
						
						WE COULD DERIVE AN EQUATION, G(x,h) THAT COULD GIVE THE NUMBER OF NODES
						THE TREE HAS. ONE CAN ALSO DERIVE AN EQUATION, E[x,h] THAT GIVES THE NUMBER
						OF ELEMENTS THE TREE IS HOLDING WHEN EACH NODE IS HOLDING THE MINIMUM 
						AMOUNT REQUIRED. NOTE THAT UNDER BOTH EQUATIONS, THE TREES ARE ASSUMED 
						FULLY BALANCED. GIVEN A TREE THAT IS TO BE COPIED, WE KNOW EXACTLY
						HOW MANY ELEMENTS IT IS HOLDING, S, FROM THIS WE CAN TREAT E[x,h] AS 
						CONTINUOUS AND SET, E(x, h) = S, TO GET AN EQUATION x = F(h), AND FINALLY 
						SUBSITUE THAT INTO G(x,h) AND OPTIMIZE G(F(h), h) SUCH AS IT IS AS SMALL AS 
						POSSIBLE. WITH THIS WE CAN DERIVE THE BEST h AND x FOR OUR NEW TREE THAT 
						SAVES THE MOST MEMORY.
						
						NOW THAT WE HAVE THE OVERALL SHAPE OF OUR TREE, WE WOULD ALSO KNOW HOW MANY
						ELEMENTS EACH NODES HAS, AND THAT WOULD BE LARGER THAN THE MINIMUM REQUIRED,
						AND SOME OF THESE NODES WILL HAVE MORE ELEMENTS THAN OTHER NODES BY 1.
						
						WE WOULD THEN PROCEED WITH AN ALGORITHM TO FILL THE TREE.
				- THE SECOND APPROACH, IS LIKE THE FIRST, BUT INSTEAD STARTS WITH THE h OF THE
						TREE TO BE COPIED, AND ONLY TRIES TO FIGURE OUT x. IT CAN BE SHOWN THAT ANY
						x SMALLER THAN THE x OF THE TREE TO BE COPIED WOULD LEAD TO A BALANCED
						TREE.
				- THE THIRD APPROACH CONSISTS OF TWO ALGORITHMS. IN THIS APPROACH THE TREE IS BUILT
						FROM EMPTY, STARTING WITH A SINGLE NODE AS ROOT, AND THE NODE BEING A LEAF.
						
						THE FIRST ALGORITHM WOULD FILL THE LEAF NODE FULLY, THEN REALIZE THAT THERE
						IS NO MORE SPACE, AND CALL ON THE SECOND ALGORITHM TO PREPARE OTHER NODES.
						
						IF THE SECOND ALGORITHM FINDS A NEED TO SPLIT NODES, THE SECOND ALGORITHM 
						GOES THE HIGHEST NODE IN THE TREE, MEANING THE ONE CLOSEST TO READ, THAT 
						WOULD NEED SPLITTING, THEN DOES A LOOK AHEAD, A MATHMATICAL CALCULATION 
						BASED ON THE NUMBER OF ELEMENTS LEFT TO COPY AND THE HEIGHT OF SAID NODE
						TO DECIDE WHETHER AFTER THE SPLIT IT NEEDS TO COPY HALF OF THE PREVIOUS NODE 
						OVER TO THE NEW NODE OR NOT. IF THERE ARE ENOUGH ELEMENTS LEFT TO COPY, NO
						COPY OVER IS REQUIRED, AND THE FIRST ALGORITHM WILL NATUARLY FILL THE NEW
						EMPTY NODE ALL THE WAY DOWN TO THE LEAVES SUCH AS THE NEW BRANCH IS 
						BALANCED.
						
						THE SECOND ALGORITHM THEN SETS THE POSITION OF THE LAST NODE FOR THE FIRST 
						ALGORITHM. IF THE SECOND ALGORITHM DOES NOT DO A COPY OVER WHEN SPLITTING A 
						NODE, THEN THE CURRENT POSITION OF THE FIRST ALGORITHM IS ALREADY THE END OF 
						THE TREE, EVEN IF AFTER THAT THERE IS NOW AN EMPTY NODE. IF THE SECOND 
						ALGORITHM DOES DO A COPY OVER WHEN SPLITTING A NODE, THEN THE END OF THE 
						TREE HAS TO BE FOUND BY TRAVERSING THE NEW BRANCH. NOTICE HOW IN THIS
						CASE, THE FIRST ALGORITHM WILL FIND ITSELF WITH A LEAF NODE THAT IS NOW
						NOT EMPTY, AND THIS IS WHY THE FIRST ALGORITHM NEEDS TO CHECK AGAIN
						THE AMOUNT OF CONTENT OF THE NODE IT IS IN AFTER THE SECOND ALGORITHM
						RETURNS.
						
						IT IS VERY IMPORTANT TO REMEMBER THAT THE SECOND ALGORITHM ONLY SPLITS
						THE TOP MOST NODE THAT NEEDS SPLITTING.
						
						IN OUR EXAMPLE, AT SOME POINT THE FIRST ALGORITHM FILLS ALL THE LEAVES OF A 
						SINGLE INTERNAL NODE, AND AFTER CALLING THE SECOND ALGORITHM THAT INTERNAL 
						NODE GETS SPLIT. LIKE BEFORE THE NEW INTERNAL NODE WILL EITHER ALREADY BE 
						FILLED WITH THE MINIMAL REQUIRED NODES, LEAVES IN OUR CASE, AND ELEMENT
						ENTRIES, OR BE FULLY EMPTY. IN THE FIRST CASE, THE FIRST ALGORITHM PROCEEDS 
						TO FILL THE NEXT POSITION WHICH HAPPENS TO BE THE NEW INTERNAL NODE, CREATES 
						A NEW LEAF NODE, THEN GOES DOWN TO THAT AND FILLS IT COMPLETELY. AFTER THAT 
						REALIZES THAT IT DOES NOT NEED TO CALL THE SECOND ALGORITHM, GOES BACK UP, 
						FILLS A POSITION IN THE INTERNAL NODE, CREATE A NEW LEAF NODE, AND GOES DOWN,
						AND THE PROCESS CONTINUES. IN THE SECOND CASE, THE FIRST ALGORITHM WILL
						FIND ITSELF IN A LEAF NODE THAT IS STILL NOT FULL. IT WILL PROCEED TO FILL
						IT, THEN GOES BACK UP AND FIND ITSELF IN THE NEW CREATED INTERNAL NODE, 
						FILLS A SINGLE POSITION IN THE INTERNAL NODE, THEN CREATES A NEW LEAF NODE, 
						AND GOES DOWN TO THE LEAF AND THE PROCESS CONTINUES.
						
		- Tree::destruct()
			- HISTORY
				- OLD NOTE IN FUNCTION:
						BASED ON MY CALCULATIONS, THE ORIGINAL APPROACH FROM THE REFERENCE CODE IF
						IMPLEMENTED USING THE STACK INSTEAD OF THE HEAP, WOULD REQUIRE LESS "STACK" 
						THAN THIS APPROACH UP TO B-TREE ORDER 48 ON 64BIT SYSTEMS. WHILE ON 32BIT 
						SYSTEMS IT WOULD BE B-TREE ORDER 24. THE CALCULATION ASSUMED ALL THE MEMORY 
						IS EXHASUTED BY THE TREE, AND THAT THIS APPROACH WOULD USE 48BYTES PER 
						RECURSION ON THE STACK ON 64BIT SYSTEMS, AND 24BYTES ON 32BIT SYSTEMS, AND 
						THAT THE SIZE OF THE TYPE STORED IS 1 BYTE. 
						EQUATION USED FOR NON RECURSIVE APPROACH:
									logN("Total number of nodes that can fit in 2^64 bytes") * N
									(logN(2^(64)) - logN(4+N+N*8)) * N
						EQUATION USED FOR RECURSIVE APPROACH:
									((logN(2^(64)) - logN(4+N+N*8)) * 48)		(64BIT SYSTEM)
									((logN(2^(64)) - logN(4+N+N*4)) * 24)		(32BIT SYSTEM)
						
						NOTE THAT IT WAS ASSUMED THAT A FUNCTION THAT HAS NO PARAMETERS USES 32BYTES 
						PER RECURSION ON 64BIT SYSTEMS, AND 16BYTES PER RECURSSION ON 32BIT SYSTEMS.
						
						HOWEVER DESPITE THE ABOVE, THIS APPROACH IS LIKELY TO USE LESS MEMORY EVEN 
						AT LOWER 'N' BECAUSE THE ORIGINAL REFERENCE APPROACH IMPLEMENTED TO USE THE 
						STACK ONLY HAS TO ALLOCATE ALL THE MEMORY ON THE STACK AT THE BEGGINING 
						REGARDLESS OF HOW MUCH IT ACTUALLY NEEDS. FURTHERMORE, WE WOULD HAVE TO PICK 
						A NUMBER FOR OUR WORST CASE 'N' ALLOWED BECAUSE THE STACK ALLOCATION AT THE 
						BEGGINING HAS TO BE HARDCODED AND CAN NOT BE TOO LARGE. WITH THIS APPROACH, 
						'N' CAN GROW AS LARGE AS NEEDED.
						
						NOTE THAT WITH THE STACK BASED APPROACH, IF WE WANT TO KEEP STACK SIZE LESS 
						THAN 1KB, N CAN NOT BE LARGER THAN 18. AT 'N' EQUALS 48, YOU NEED 
						~2KB(1900B), AND AT 24 YOU NEED 1192B.
						
						TO MAKE THE STACK APPROACH MORE EFFICIENT, INSTEAD OF A DATA STACK ON THE 
						STACK, ONE MUST USE A DATA QUEUE ON THE STACK, BUT FOR THAT YOU WOULD NEED A 
						RING. WITH THIS, IT IS GUARANTEED THAT BEFORE THE QUEUE FILLS WITH ELEMENTS 
						FROM HEIGHT 'H', ALL NODES FROM HEIGHTS SMALLER THAN 'H' HAVE BEEN REMOVED. 
						THE WORST CASE SCENARIO BECOMES ONE THAT FILLS THE LOWEST LEVEL IN THE TREE 
						FULLY, WHILE MAKING THIS LEVEL AS LOW AS POSSIBLE, WHICH MAKES IT AS WIDE AS 
						POSSIBLE. FOR BASIC B TREE, THE WORST CASE HEIGHTISIS BOUNDED BY
								logS(("Total number of nodes that can fit in 2^64 bytes" + 1) / 2);  S:= N / 2
										{SRC: Comer (1979) and Cormen et al. (2001), and number of 
										nodes assumed worst case}
						ASSUMING AT THIS HEIGHT, THE BOTTOM PART CAN SOMEHOW BE FULLY FILLED, THEN 
						THE WORST CASE FOR THE SIZE OF THE QUEUE IS
								(N ^ (logS(("Total number of nodes that can fit in 2^64 bytes" + 1) / 2)))
				- THE REFERENCE ALGORITHM WOULD VISIT A NODE, QUEUE IT CHILD NODES ON A STACK, 
						DELETE THE NODE, THEN REPEAT AGAIN WITH THE CURRENT TOP NODE ON THE STACK.
						THE ALGORITHM WAS ALLOCATING THE STACK SPACE ON THE HEAP. 
						I TRIED TO LIMIT THE ALGORITHM BY ALLOCATING THE STACK SPACE ON THE STACK,
						BUT IN THE END, IF I REMEMBER CORRECTLY, I SAW THAT IT WAS NO GOING TO BE
						EFFICIENT. THERE WAS NO REASONABLE BOUND ON THE STACK SPACE, I THINK IT
						WAS. 
						ALSO NOTE THAT, IF I REMEMBER CORRECTLY, MY NOTE ABOVE HAD AN ERROR IN THE 
						LOGIC, AND I FORGET WHETHER IN THE END I CORRECTED THE ERROR IN THE NOTE OR
						NOT.
		- Tree::getSuitableImagineryIndexFor()
			- THIS FUNCTION TREATS THE INPUT NODE, pNode, AS IF IT HAS AN EXTRA ENTRY AT THE 
					BEGGINING WITH THE VALUE -INFINITY. 
			- THE FUNCTION RETURNS AN INDEX SUCH AS pElement(OR pIndex__guide) IS EQUAL TO THE 
					ELEMENT(OR INDEX TYPE 2), OR IF NOT FOUND, RETURNS THE LARGEST INDEX SUCH AS 
					pElement(OR pIndex__guide) IS EQUAL TO OR LARGER THAN THE 
					ELEMENT(OR INDEX TYPE 2) AT THAT INDEX. THIS INDEX IS REFERED TO AS AN IMAGINARY 
					INDEX BECAUSE IT IS RELATIVE TO THE NODE WITH EXTRA ENTRY AS MENTIONED ABOVE.
					THE RETURN IS ALWAYS SUCH AS THE FOLLOWING IS TRUE,
							0 <= RETURN <= pNode->gPrivate_numberOfEntries
					AN ARRAY ELEMENT IS APPENDED, AND HENCE EXISTS AT INDEX '0' AND IS ASSUMED TO 
					EXIST WITH VALUE -INFINITY.
					NOTE THAT IF pNode IS EMPTY, THE APPENDED ARRAY ELEMENT AT '0' IS STILL ASSUMED 
					TO EXIST, AND HENCE THE RETURN IS ALSO 0.
			- pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode IS ZERO IF THE 
					ELEMENT(OR INDEX TYPE 2), pElement(OR pIndex__guide) IS FOUND, OR IF NOT FOUND, 
					IT IS THE VALUE OF COMPARISON WITH THE LARGEST ELEMENT(OR INDEX TYPE 2) IN THE 
					NODE. THE ASSUMPTIONS IS THAT ARRAY ELEMENTS ARE ORDERED IN THE 
					NODE ASCENDING. IF THE NODE IS EMPTY, 
					pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode IS STILL POSITIVE, MEANING 
					pElement(OR pIndex__guide) IS LARGER THAN THE LARGEST ARRAY ELEMENT IN THE 
					NODE WHICH IS THE APPENDED ARRAY ELEMENT, -INFINITY.
			- HISTORY:
				- THE CORRESPONDING FUNCTION IN THE REFERENCE CODE IS ILL DEFINED. THE FOLLOWING
						NOTES WHERE AFTER INITIAL CLEAN UP OF THE FUNCTION, BEFORE FINALLY FIXING
						THE REMAINING ISSUES.
				- search within node:
						- if there is atleast one element:
							- if pResult > 0 : pKey larger than all elements. 
									return is pNode->gPrivate_numberOfEntries - 1.
							- if pResult < 0 : pKey never found, but not larger than all elements.
									If return is negative, pKey smaller than all elements, else pKey 
									is larger than the element marked by return.
							- if pResult == 0: pKey found. return is the index of found element.
							- (pResult > 0) && ((return < 0) || (return == 0)) is impossible.
							- (pResult == 0) && ((return < 0) || 
									(return > pNode->gPrivate_numberOfEntries)) is impossible.
							- (return > pNode->gPrivate_numberOfEntries - 1) is impossible.
						- if there are no elements:
							- if return < 0: pResult can be anything.
									WARNING: EXACTLY, return == -1 == pNode->gPrivate_numberOfEntries - 1
							- (return == 0) || (return > 0) is impossible.
						- -1 <= return <= pNode->gDatum_bNumberOfKeys - 1
				- NOTE THAT, pResult WAS WHAT IS NOW 
						pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode. pKey WAS WHAT IS NOW
						pElement OR pIndex__guide DEPENDING ON THE OVERRIDE. pKey SIMPLY REFERED TO
						BOTH.
		- Tree::transferPushFromNodeToNode()
			- CONTRACT
				COPYING IS [element, node] IF pIsToIncludeBegginingChildNode IS FALSE. THIS 
						MEANS, THAT MOVING OF ELEMENTS AND INDICES BEGINS AT pStartingIndex 
						WHILE MOVING OF CHILD NODE POINTERS BEGINS AT pStartingIndex + 1. 
						(MODE 2)
						IF pIsToIncludeBegginingChildNode IS TRUE, MOVING OF CHILD NODE 
						POINTERS BEGINS AT pStartingIndex, BUT STILL EXTENDS TO ONE STEP 
						FURTHER AT THE END COMPARED TO ELEMENTS AND INDICES. (MODE 1)
						
				MODE 1: MOVING OF ELEMENTS AND INDICES BEGINS AT pStartingIndex AND INSERTION 
						IS AT THE INDEX 'LENGTH'. N ENTRIES ARE MOVED. MOVING OF CHILD NODE 
						POINTERS BEGINS AT pStartingIndex AND INSERTION IS AT THE INDEX 
						'LENGTH'. N + 1 POINTERS ARE MOVED. 
						N IS THE NUMBER OF ELEMENTS AND INDICES STARTING FROM pStartingIndex UNTIL
						THE END. HENCE N + 1 IS THE NUMBER OF POINTERS FROM pStartingIndex UNTIL THE
						END.
						(pIsToIncludeBegginingChildNode == TRUE)
				MODE 2: COPYING OF ELEMENTS AND INDICES BEGINS AT pStartingIndex AND INSERTION 
						IS AT THE INDEX 'LENGTH'. N ENTRIES ARE MOVED. MOVING OF CHILD NODE 
						POINTERS BEGINS AT pStartingIndex + 1 AND INSERTION IS AT THE INDEX 
						'LENGTH' + 1. N POINTERS ARE MOVED. 
						N IS THE NUMBER OF ELEMENTS AND INDICES STARTING FROM pStartingIndex UNTIL
						THE END. HENCE N IS THE NUMBER OF POINTERS FROM pStartingIndex + 1 UNTIL THE
						END.
						(pIsToIncludeBegginingChildNode == FALSE)
			- WARNING: THE FUNCTION DOES NOT UPDATE THE LENGTH OF THE NODES.
			- NOTE: THIS FUNCTION TOLERATES AN INCOMPLETELY CONSTRUCTED NODE, BUT SUCH USAGE IS A 
					FORMAL VIOLATION.
			- BOTH NODES MUST BELONG TO THE SAME TREE.
		- Tree::transferAllIntoNode()
			- THIS FUNCTION IS CALLED 'TRANSFER', WHICH IS A MOVE DEFINED FOR THIS PROJECT AND NOT 
					PART OF MY STANDARD, IS ILL DEFINED, TO INDICATE THAT THE FUNCTION WILL BOTH 
					CALL MOVE CONSTRUCT, AND CALL THE MOVE DESTRUCT ON A PARAMETER. THIS IS A FORMAL
					VIOLATION. DO NOT MAKE THIS FUNCTION PUBLIC. AND REMEMBER, BECAUSE OF THE FORMAL
					VIOLATION, IF NOT USED PROPERLY THE FUNCTION CAN CAUSE DESTRUCTORS TO BE CALLED 
					TWICE ON A C++ TYPE. THIS IS AN ISSUE WHEN THE TREE IS NOT PERSISTANT.
			- REMEMBER, WHEN THE TREE IS PERSISTANT, THIS FUNCTION IS TRANSFERING THE ELEMENT 
					POINTER, NOT THE ELEMENT ITSELF. BE CAREFUL.
			- MOVING INDEX, ELEMENT, AND CHILD NODE POINTER INTO NODE AT A SPACE THAT THE FUNCTION
					CREATES.
					INDEX AND ELEMENT ARE INSERTED AT INDEX pIndex AFTER THE CURRENT INDICES AND
					ELEMENTS ARE SHIFTED BY ONE STARTING FROM pIndex.
					CHILD NODE POINTER IS INSERTED AT INDEX pIndex + 1, INSTEAD OF pIndex IF
					pIsToIncludeBegginingChildNode IS FALSE.
			- THE CHILD NODE POINTER, AND THE NODE MUST BELONG TO THE SAME TREE.
		- Tree::removeFirstNEntriesFrom()
			- REMOVES THE FIRST N ELEMENTS(IF THEY EXIST), AND INDICES(IF THEY EXIST), AND CHILD 
					NODES(IF THEY EXIST). REMEMBER THE EXISTANCE OF THESE DEPEND ON THE TYPE OF
					TREE. 
			- THE FUNCTION ASSUMES THAT THE FIRST N ENTRIES ARE ALREADY DESTRUCTED.
			- CURRENTLY, THE FUNCTION'S EXISTANCE IS ILL DEFINED, A FORMAL LIE. TODO: THIS FUNCTION 
					MUST BE REMOVED IN THE FUTURE, UNLESS ITS EXISTANCE BECOMES WELL DEFINED.
		- Tree::resolveFullNode()
			- SPLITS A FULL NODE WITH A PARENT INTO TWO.
			- IN THE NON PRE EMPTIVE CASE, pIndicesOfNodesInParents IS EXPECTED TO BE AN ARRAY THAT 
					HOLDS THE INDICES OF NODES IN THEIR PARENTS ALL THE WAY UP TO THE ROOT.
					THE FIRST ENTRY IN THE ARRAY, MEANING THE INDEX OF THE ROOT NODE IN ITS PARENT
					MUST ALWAYS BE 0.
			- IN THE PRE EMPTIVE CASE, IF THE NODE IS THE ROOT NODE, pIndexOfNodeInParent MUST BE 0
			- WHEN ENTRIES ARE IN THE LEAVES ONLY, THE SPLITTING OF A LEAF IS SUCH AS THE LEFT
					NODE HAS ONE MORE ENTRY COMPARED TO THE RIGHT NODE, THE NEW NDOE.
			- WARNING: THIS FUNCTION EXPECTS A NODE TO EXIST AT pIndexOfNodeInParent + 1 IF 
	3				pIndexOfNodeInParent IS SMALLER THAN THE MAXIMUM NUMBER OF CHILDREN. SAME 
					APPLIES TO *pIndicesOfNodesInParents. THIS ASSUMPTION IS BROKEN WHEN THE TREE IS 
					WITH A SINGLE LEAF NODE UNDER A SINGLE INNER NODE, AND LEAF NODE IS PASSED FOR 
					SPLITTING. WHEN THE ASSUMPTION IS BROKEN, MAKE SURE THAT THE NODE POINTER AT 
					pIndexOfNodeInParent + 1, OR pIndicesOfNodesInParents + 1, IS NULL.
					UPDATE: NOTE THAT THIS NO LONGER HAPPENS IN THE CODE. THE FUNCTION NO LONGER
					GETS CALLED WITH THIS SITUATION. INSTEAD, THE FUNCTION NOW HANDLES THE SPLITTING 
					OF THE ROOT NODE IN THE PRE EMPTIVE CASE (AND NON PREMPETIVE), UNLIKE WHAT I 
					ESTABLISHED FROM THE REFERENCE CODE. HOWEVER, WITHIN THE FUNCTION, THE ABOVE
					REMAINS RELEVANT.
		- Tree::transferAndInsertElementEntry()
			- THIS FUNCTION IS CALLED 'TRANSFER', WHICH IS A MOVE DEFINED FOR THIS PROJECT AND NOT 
					PART OF MY STANDARD, IS ILL DEFINED, TO INDICATE THAT THE FUNCTION WILL BOTH 
					CALL MOVE CONSTRUCT, AND CALL THE MOVE DESTRUCT ON A PARAMETER. THIS IS A FORMAL
					VIOLATION. DO NOT MAKE THIS FUNCTION PUBLIC. AND REMEMBER, BECAUSE OF THE FORMAL
					VIOLATION, IF NOT USED PROPERLY THE FUNCTION CAN CAUSE DESTRUCTORS TO BE CALLED 
					TWICE ON A C++ TYPE. THIS ISSUE IS ONLY ONE WHEN THE ELEMENT ENTRY IS THE 
					ELEMENT	ITSELF, MEANING THE TREE IS NOT PERSISTANCE
			- WARNING, IF THE TREE IS PERSISTANT, THE ELEMENT ENTRY WOULD BE AN ELEMENT POINTER,
					WHICH MEANS THAT THE FUNCTION IS TRANSFERRING A POINTER, NOT THE ELEMENT
					ITSELF. THE CALLER MUST MAKE SURE TO MAKE A COPY OF THE ELEMENT ON THE HEAP 
					BEFORE CALLING THIS FUNCTION. IN OTHER WORDS THE FUNCTION WOULD BE TAKING
					OWNERSHIP, A FORMAL VIOLATION. THE FUNCTION WOULD HAVE TO BE CALLED
					takeAndInsertElement() INSTEAD TO BE CORRECT. REMEMBER, THE VERY CONCEPT
					OF ELEMENT ENTRY IS A FORMAL VIOLATION.
		- Tree::removeElement()
			- IF THIS FUNCTION FAILS, THIS FUNCTION FAILS BEFORE THE ELEMENT TO BE REMOVED WAS
					NOT FOUND, AND NOTHING ELSE. THIS IS WHY Tree::Iterator::construct3() EXISTS,
					WHICH ALLOWS THE CALLER TO CREATE THE NECESSARY BUFFER FOR THE ITERATOR ON HIS
					STACK, AVOIDING HEAP ALLOCATION WHICH WOULD BE A POSSIBLE SOURCE OF FAILURE.
			- EXPLANATION:
				- IF PRIMARY ENTRIES ARE NOT IN LEAVES ONLY, AND THE TREE HAS AN INDEX, THEN WE
						WOULD NEED TO DO FURTHER SEARCH ONCE THE INDEX FOR THE ELEMENT IS FOUND TO 
						FIND THE RIGHT ELEMENT. REMEMBER, THERE COULD BE MULTIPLE ELEMENTS WITH THE 
						SAME INDEX. THIS IS WHY IN THIS CASE, AN ITERATOR IS NEEDED. IF THE TREE 
						DOES NOT USE AN INDEX, WE DO NOT NEED TO DO THIS, AND WE SIMPLY DELETE THE
						FIRST ELEMENT FOUND.
						IF THE PRIMARY ENTRIES ARE IN THE LEAVES ONLY, WE ALSO DO NOT NEED TO DO
						THIS, AND SIMPLY STICK TO THE FIRST INDEX FOUND. REMEMBER IN THIS CASE,
						AN INTERNAL NODE IS NOT HOLDING ANY ELEMENTS. HOWEVER, IN THIS CASE, WHEN WE 
						REACH A LEAF AND FIND WHAT WE ACTUALLY WANT, WE PRETEND THAT WHAT WE FOUND 
						WAS WHAT IS DELEGATED FOR BY THE INDEX FOUND EARLIER IN THE INTERNAL NODES, 
						EVEN IF NOT TRUE, AND HENCE, A COPY HOIST IS ALWAYS DONE.
				- WHEN THE ENTRY TO BE REMOVED IS FOUND, IF IT HAPPENS TO BE IN AN INTERNAL NODE,
						WE PROCEED TO FIND THE NEXT ENTRY IN LINE, WHICH WILL ALWAYS BE IN A LEAF,
						NO MATTER HOW MUCH LOWER THE LEAVES ARE, AND THAT ENTRY IS HOISTED UP TO 
						FILL THE EMPTIED ENTRY CELL. THIS IS TO AVOID HAVING TO REORDER THE 
						STRUCTURE OF THE TREE. IT IS EASIER TO SIMPLY DELETE AN ITEM FROM THE 
						LEAVES.
				- IF PRIMARY ENTRIES ARE IN THE LEAVES ONLY, THEN WE NEED TO ANTICIPATE FINDING
						AN ENTRY IN THE INTERNAL NODES THAT CORRESPONDS TO THE ACTUAL ENTRY THAT
						SHALL BE REMOVED FROM THE LEAVES. A CORRESPONDANCE OF THAT ENTRY SHALL THEN
						BE HOISTED UP. THIS IS SIMILAR TO THE POINT ABOVE, BUT IN THIS CASE WE ARE
						EFFECTIVELY DELETING TWO ENTRIES WHEN AN ENTRY IS FOUND IN THE INTERNAL 
						NODES. ONE PRIMARY, AND ONE SECONDARY, THE CORRESPONDING ENTRY.
				- WHEN PRIMARY ENTRIES ARE NOT IN THE LEAVES ONLY, pIndex__guide, IF THE TREE HAS AN
						INDEX, AND pElement, ARE USED FOR THE VALUE SEARCHED FOR UNDER MODE 0, WHILE
						THEY ARE USED AS POINTER TO SPACES IN TREE TO MOVE AN ELEMENT AND VALUE
						FROM SOMEWHERE ELSE IN TREE. I CALL THIS HOISTING.
						
						WHEN PRIMARY ENTRIES ARE ONLY IN THE LEAVES, pIndex__out AND pElement__out
						ARE WHAT IS USED TO HOIST AN INDEX OR ELEMENT BACK UP. REMEMBER IN THIS
						CASE, IF WE FIND THE VALUE IN AN INTERNAL NODE, WE DID NOT REALY FIND IT, 
						BUT FOUND A DELEGATE FOR IT. THIS IS WHY WHEN WE SWITCH TO MODE 1 OR 2,
						WE CAN NOT REPURPOSE pIndex__guide AND pElement BECAUSE WE STILL HAVE NOT
						FOUND THE ACTUAL VALUE THAT WE ARE LOOKING FOR, AND HENCE THESE TWO MUST
						CONTINUE CONTAINING WHAT WE ARE SEARCHING FOR.
						
						REMEMBER, REPURPOSING THE PARAMETERS IS A FORMAL VIOLATION, BUT WE CAN GET
						AWAY WITH IT IN THIS CASE FROM THE PERSPECTIVE OF USER CODE.
				- WHEN THE ALGORITHM IS PRE EMPTIVE, WHEN WE NEED TO SEARCH FURTHER DOWN AFTER
						FINDING THE VALUE IN AN INTERNAL NODE, MEANING WHEN MODE SHALL SWITCH FROM
						0, THEN WHEN THE PRIMARY ENTRIES ARE NOT IN THE LEAVES ONLY, WE CAN CHOOSE
						TO TAKE THE LEFT OR RIGHT BRANCH. BUT WHEN THE PRIMARY ENTRIES ARE IN THE
						LEAVES ONLY, WE MUST TAKE THE RIGHT BRANCH BECAUSE THAT WHERE THE ACTUAL
						VALUE THAT IS DELEGATED FOR WILL BE FOUND.
				- BECAUSE OF FORMAL VIOLATION ON THE FUNCTION SIGNATURE, AND IN PARTICULAR THE USE
						OF pElement FOR DIFFERENT PURPOSES ON THE SAME OVERLOAD, IN SOME CASES
						I HAD TO REMOVE THE const QUALIFIER. HOWEVER, IT REMAINS APPLICABLE, AND
						THE FUNCTION CODE MUST NOT MODIFY pElement WHEN IT IS REPRESENTING THE
						VALUE TO BE SEARCHED FOR, INSTEAD OF BEING THE ELEMENT HOISTED UP.
			- NOTE FROM Tree::removeElement__do()
					WARNING: This function has a number of formal violations. Its signature is not
							reduced for example. And under some overrides, it expects an undefined 
							variable, meaning a variable type 2 declared but not defined.

					There are three high level overrides marked by pMode
					
					void removeElement__do(pTREE_TYPE_NAME * pThis, 0, ...)
							pMode == 0: Delete pElement's occurance in pNode if it is there, other 
									wise continue search in child nodes.
					void removeElement__do(pTREE_TYPE_NAME * pThis, 1, ...)
							pMode == 1 : 
								IS_ELEMENT_DATA_IN_LEAVES_ONLY == CRXM__FALSE:
										Remove last element from pNode tree branch and return it 
										using 
												pIndex__guide, if tree has an index, and pElement. 
												pElement, if tree has no index, 
										pIndex__guide and pElement must point to "garbage".
								IS_ELEMENT_DATA_IN_LEAVES_ONLY == CRXM__TRUE:
										If pElement in pNode tree branch, delete it, and return a 
										copy of the last element, or its index if the tree has an 
										index, in the branch using pElement__out, or pIndex__out 
										when tree has an index.
										pElement__out, or pIndex__out when tree has an index, must 
										point to "garbage".
										
										Note that by design, this should never happen, however 
										implemented some of the algorithm aiming for symmetry.
					void removeElement__do(pTREE_TYPE_NAME * pThis, 2, ...)
							pMode == 2: 
								IS_ELEMENT_DATA_IN_LEAVES_ONLY == CRXM__FALSE:
										Remove first element from pNode tree branch and return it 
										using 
												pIndex__guide, if tree has an index, and pElement. 
												pElement, if tree has no index
										pElement must point to "garbage".
								IS_ELEMENT_DATA_IN_LEAVES_ONLY == CRXM__TRUE:
										If pElement in pNode tree branch, delete it, and return a 
										copy of the first element, or its index if the tree has an 
										index, in the branch using pElement__out, or pIndex__out 
										when tree has an index.
										pElement__out, or pIndex__out when tree has an index, must 
										point to "garbage".
			- NOTE FROM Tree::removeElement__do__findExactEntry()
					- IF 0 RETURNED, ENTRY NOT FOUND.
					- IF 1 RETURNED, ENTRY POINTED TO BY pIterator IS CORRECT.
					- IF 2 RETURNED, ENTRY POINTED TO BY pIterator IS INCORRECT, BUT AN ENTRY IS 
							FOUND IN ITS VICINITY, AND pIterator__return IS SET TO IT.
		- Tree::getTraceOfLeafNode()
			- CURRENTLY, THIS FUNCTION'S EXISTANCE IS A FORMAL LIE.
			- NOTES FROM FUNCTION
					THIS FUNCTION WILL SET pNodes AND pIndices TO A TRACE TO THE LEAF NODE, pNode. 
					THE TRACE RESEMBLES THE PRIVATE Tree::Iterator::gPrivate_positions DATA MEMBER, 
					EXCEPT THAT THE TRACE DOES NOT CONTAIN A LEAF ENTRY;

					ALL NODES IN pNodes ARE INTERNAL NODES. HOWEVER THE LAST VALUE IN pIndices WOULD 
					BE THE INDEX OF A LEAF CHILD NODE. AND LIKE THE WAY gPrivate_positions WORKS, 
					pNodes[0] WOULD BE NULL, AND pIndices[0] WOULD BE 0.

					BOTH pNodes AND pIndices MUST HAVE A SPACE OF ATLEAST 64.

					THE RETURNED VALUE IS THE LENGTH OF THE TRACE. IF THE RETURNED VALUE IS 0, THE 
					NODE WAS NOT FOUND AT ALL. THIS SHOULD NOT HAPPEN. 
	- Tree::Node
		- AT ALL TIMES, THE FOLLOWING MUST HOLD TRUE:
			- CURRENT NUMBER OF ELEMENTS HELD BY NODE = Crx_C_Tree_Private_Node::gPrivate_numberOfEntries
			- CURRENT NUMBER OF CHILD NODES A NODE HAS = Crx_C_Tree_Private_Node::gPrivate_numberOfEntries + 1
		- IF NODE IS A LEAF NODE IT DOES NOT CONTAIN POINTERS TO CHILD NODES, ONLY ELEMENTS
	- PER THE DESIGN OF THE HASHTABLE, REMOVING A NON EXISTANT ELEMENT IS NOT AN ERROR AND
			MUST SHORT CIRCUIT. THIS APPLIES TO THE RELVANT FUNCTIONS IN Tree AND Tree::Iterator.
			
	- Tree::Iterator
		- Tree::Iterator::gPrivate_positions 
			- USED WHEN ELEMENT DATA IS STORED IN ALL NODES, MEANING WHEN 
					pARE_INDICES_IN_INTERNAL_NODES_ONLY  IS TRUE.
			- STARTS WITH INDEX 1, NOT 0. INDEX 0 IS USED TO SET AN INVALID 
					ITERATOR
			- AT INDEX 0, Tree::Iterator::Position::gNode IS SET TO NULL, AND 
					Tree::Iterator::Position::gIndex TO 0 TO INDICATE 'BEGGINING' EMPTY
					SPACE, OR SET TO 1 TO INDICATE 'END' EMPTY SPACE. THIS IS TO ALLOW DELETION
					WHILE ITERATION WORK THE SAME AS ARRAYS. WHEN SET TO 1, IT IS AS IF THE INDEX
					IN THE ARRAY IS 1 PAST THE LAST ELEMENT. AND WHEN SET TO 0, IT IS AS IF THE
					INDEX IN THE ARRAY IS '-1', MEANING ONE BEFORE THE FIRST ELEMENT.
			- Tree::Iterator::Position::gNode IS THE CURRENT NODE.
			- Tree::Iterator::Position::gIndex IS THE INDEX OF THE NEXT NODE, AND NOT THE INDEX OF 
					THE CURRENT NODE, MEANING NOT THE INDEX OF Tree::Iterator::Position::gNode
			- IF Tree::Iterator::Position::gNode IS A LEAF, Tree::Iterator::Position::gIndex IS THE 
					INDEX OF THE ELEMENT IN THE LEAF, INSTEAD OF BEING THE INDEX OF THE NEXT NODE. 
					THIS IS A FORMAL VIOLATION. ALSO KEEP IN MIND THAT THE INDEX OF NODES GOES UP 
					TO 2N, WHILE THE INDEX OF ELEMENTS GOES UP TO 2N - 1.
			- WHILE TRAVERSING Tree::Iterator::gPrivate_positions BACKWARD ONE CAN CHECK FOR NULL 
					ON Tree::Iterator::gPrivate_positions::gNode, ONE CAN NOT DO THE SAME TRAVERSING 
					FARWARD. THIS IS ILL DEFINED, BUT IS KEPT FOR PERFORMANCE CURRENTLY. 
					HOWEVER, NOTE THAT THE CODE DOES NOT RELY ON Tree::Iterator::Position::gNode 
					BEING NULL FOR THIS PURPOSE. INSTEAD, THE CODE RELIES ON
							pThis->gPrivate_position__current == pThis->gPrivate_positions
					BECOMING TRUE WHEN ITERATION IS DONE. NOTE HOWEVER, IN THAT CASE
							pThis->gPrivate_positions->gIndex COULD BE 0 TO INDICATE THE BEGGINING
							'EMPTY' SPACE, OR '1' TO INDICATE THE END EMPTY SPACE. THIS IS ANOTHER
							FORMAL VIOLATION, BUT IS KEPT FOR PERFORMANCE REASON, KEPT TO AVOID
							DECLARING MORE DATA MEMBERS INSTEAD FOR THE PURPOSE.
		- Tree::Iterator::gPrivate_node
			- WHEN ELEMENT DATA IS STORED IN LEAVES ONLY
				- IF NULL, THE ITERATOR IS NO LONGER VALID. IN THAT CASE 
						Tree::Iterator::gPrivate_elementIndex CAN BE 0 TO INDICATE THE BEGGINING
						'EMPTY' SPACE, OR '1', TO INDICATE THE END EMPTY SPACE. SEE NOTES ABOVE.
						AS BEFORE, THIS IS A FORMAL VIOLATION, BUT KEPT FOR PERFORMANCE REASON,
						KEPT TO SAVE MEMORY.
			- WHEN ELEMENT DATA IS STORED IN ALL NODES AND THE TREE IS NOT PREEMPTIVE
				- USED TO STORE THE CURRENT NODE, BECAUSE Tree::Iterator::gPrivate_positions
						WOULD NO LONGER HAVE A DATA MEMBER STORING THE CURRENT NODE. REMEMBER THAT
						IN THIS CASE, NODES HAVE POINTERS TO THEIR PARENTS, AND THEREFORE THERE
						IS NO NEED TO STORE THE CURRENT NODE FOR EVERY STEP IN THE TRACE.
		- DELETION: 
			- API WISE, DELETION MUST
				- BE FASTER THAN DELETION WITHOUT AN ITERATOR. THIS IS BECAUSE WE ARE STARTING WITH 
						THE POSITION TO DELETE.					
				- WORK THE SAME WAY THAT DELETION OF A SPECIFIC CELL IS DONE 
						ON AN ARRAY. IN OTHER WORDS, THE ITERATOR MUST BEHAVE AS IF IT WAS MOVED 
						FARWARD.
			- LOGIC WISE, DELETION MUST
				- DELETE THE EXACT VALUE.
				- DELETE THE EXACT INSTANCE OF THE VALUE.
				- FREE THE EXACT SPACE OCCUPIED BY THE VALUE. OTHERWISE, THE POSITION OF THE 
						ITERATOR CAN NOT BE CORRECTED.
			- DELETION FOR WHEN THE NODES DO NOT HAVE POINTERS TO THEIR PARENTS BECOMES COMPLICATED,
					AND, OR, THE ITERATOR HAS NOT INDEX OF THE NODES IN THEIR PARENTS.
					REMEMBER THAT DELETION BY ITERATOR STARTS FROM THE POSITION, BUT THE ALGORITHM 
					MIGHT REQUIRE TRAVERSING UP THE TREE IF NODES ARE TO BE MERGED. THIS IS THE 
					REASON BEHIND THE FUNCTIONS, Tree::private_getTraceOfLeafNode() AND 
					Tree::private_findChildNodeIndexInParent().
					THE MOST EXPENSE COMES FROM WHEN THE ELEMENT DATA IS ONLY STORED AT THE BOTTOM
					OF THE TREES, AND THE NODES DO NOT HAVE POINTERS TO THEIR PARENTS. IN THIS
					CASE, THE ALGORITHM WILL HAVE TO SEARCH FOR THE NODE STARTING FROM THE TOP
					TO BE ABLE TO GENERATE A FULL TRACE FOR IT.
		- Tree::Iterator::next()
			- WHEN THE PRIMARY ENTRIES ARE STORED IN THE ALL THE NODES, THIS FUNCTION MUST NOT
					MODIFY Tree::Iterator::gPrivate_positions IF THE NEXT ITERATION IS VOID,
					MEANING THE CURRENT ITERATION BEFORE MOVING TO NEXT IS THE LAST ELEMENT IN
					THE TREE. HOWEVER, IN THIS SCENARIO THE FUNCTION MAY STILL MODIFY THE FIRST
					CELL IN Tree::Iterator::gPrivate_positions, IN PARTICULAR THE INDEX. 
					
					THE ABOVE IS REQUIRED FOR ALGORITHMS ELSEWHERE TO WORK CORRECTLY.
		- Tree::Iterator::prev()
			- WHEN THE PRIMARY ENTRIES ARE STORED IN THE ALL THE NODES, THIS FUNCTION MUST NOT
					MODIFY Tree::Iterator::gPrivate_positions IF THE NEXT ITERATION IS VOID,
					MEANING THE CURRENT ITERATION BEFORE MOVING TO PREVIOUS IS THE FIRST ELEMENT IN
					THE TREE. HOWEVER, IN THIS SCENARIO THE FUNCTION MAY STILL MODIFY THE FIRST
					CELL IN Tree::Iterator::gPrivate_positions, IN PARTICULAR THE INDEX. 
					
					THE ABOVE IS REQUIRED FOR ALGORITHMS ELSEWHERE TO WORK CORRECTLY.
		- Tree::Iterator::setToPositionOf()
			- THIS FUNCTION WILL RETURN false IF THE GUIDE, MEANING ELEMENT OR INDEX, IS NOT FOUND.
			- IF NOT FOUND, THE ITERATOR RETURNED WILL BE SUCH AS THAT POSITION IS THE FURTHEST
					POSITION WHERE THE ELEMENTS ARE SMALLER THAN THE PASSED GUIDE. 
			- IF NOT FOUND, AND THE GUIDE HAPPENS TO BE SMALLER THAN ALL THE GUIDES IN THE
					TREE, THE ITERATOR RETURNED WOULD BE THE 'NULL'/'END' ITERATOR, INFORMALLY 
					SPEAKING.
			- THE FUNCTION SUPPORTS AN 'EDGE' FEATURE. THIS IS TO ADD A DETERMINISTIC ELEMENT TO
					THE BEHAVIOR OF SEARCHING, WHICH EXPERIENCE BROUGHT TO ATTENTION WHEN IT COMES
					TO ITS USEFULNESS IN MY DESIGN OF THE SEARCH ALGORITHM FOR MY UI POLLING 
					TECHNIQUE IN MY IMPLEMENTATION OF THE SOLUTION OF THE UI PROBLEM UNDER 
					JAVASCRIPT.
			- WHEN THE PRIMARY ENTRIES ARE STORED IN ALL THE NODES, THIS FUNCTION RELIES ON 
					Tree::Iterator::next() AND Tree::Iterator::prev() NOT MODIFYING 
					Tree::Iterator::gPrivate_positions WHEN THE NEXT OR PREVIOUS ITERATION IS
					VOID.
		- Tree::Iterator::remove__do()
			- THIS FUNCTION CLOSLY FOLLOWS Tree::removeElement__do(). THEREFORE, REFER TO THE NOTES
					ABOUT Tree::removeElement().
				- SOME DIFFERENCE BETWEEN Tree::remove__do() AND Tree::removeElement__do()
					- IN Tree::remove__do() WHAT IS TO BE REMOVED IS GUARANTEED TO EXIST, UNLIKE
							THE SITUATION IN Tree::removeElement__do()
					- IN Tree::remove__do() WE HAVE A TRACE IN OUR HAND ALREADY TO THE NODE TO BE
							REMOVED, UNLIKE THE SITUATION IN Tree::removeElement__do() WHERE WE
							ARE CALCULATING THE TRACE AS WE TRAVERSE DOWN THE TREE.

							BECAUSE WE DO NOT HAVE THE TRACE IN Tree::removeElement__do(), WE
							HAVE TO DO EXTRA WORK TO STAY ON TRACK AS NOT TO INVALIDATE THE TRACE
							WE ALREADY FOUND AS WE WERE COMING DOWN. THIS IS THE CODE THAT DOES SOME
							SWAPPING WHEN THE TREE USES AN INDEX AND WE FIND AN ENTRY WITH EQUAL
							INDEX, BUT NOT EQUAL ELEMENT VALUE.
			- WHEN PRIMARY ENTRIES ARE NOT IN THE LEAVES ONLY, THE ITERATOR CAN BE EXPECTED TO HOLD
					A TRACE FROM THE ROOT OF THREE TO THE CURRENT NODE. THE TRACE MIGHT INCLUDE OR
					NOT INCLUDE PARENT NODES, AND NOT JUST CHILD NODE INDICES, DEPENDNG ON WHETHER
					THE TREE ALGORITHM IS PRE EMPTIVE OR NOT. pPosition__current IS A POINTER TO
					THE INTERNAL TRACE THE INDEX HAS. HENCE, ONCE WE ARRIVE IN Tree::remove__do() 
					TO THE NODE THAT HOLD THE VALUE TO BE REMOVED, WE ALSO ARRIVED TO THE END OF THE 
					TRACE, AND THEREFORE ANY TRAVERSAL AFTER THAT DOES NOT USE THE TRACE ANYMORE, 
					MEANING pPosition__current WOULD BE NULL.
			- WHEN PRIMARY ENTRIES ARE IN THE LEAVES ONLY, THE ITERATOR DOES NOT HOLD A TRACE TO
					THE CURRENT NODE. IN THIS CASE WE BUILD THE TRACE OURSELVES, BUT WE ONLY NEED
					THE INDICES OF CHILD NODES, AND NOT THE POINTERS TO PARENT NODES. THIS IS
					THE TWO PARAMETERS pIndices, AND pIndexInIndices. IRONICALLY, I KEPT THE CODE
					FORMALLY CORRECT IN THIS CASE, BUT I MIGHT END UP BREAKING THIS IN THE FUTURE,
					AND TURN THE TWO PARAMETERS INTO ONE, A POINTER TO THE CURRENT INDEX.
		- Tree::Iterator::getIndex()
			- NOTE FROM FUNCTION
							THIS FUNCTION IS ONLY REQUIRED WHEN IS_ELEMENT_DATA_IN_LEAVES_ONLY 
							IS FALSE, BUTTO KEEP THINGS GENERAL IT IS IMPLEMENTED FOR ALL VALID 
							POSSIBILITY WHEN THE INDEX EXISTS. REMEMBER THAT THIS FUNCTION IS MEANT 
							TO BE USED BY THE TREE CLASS 
			
							THIS FUNCTION NEVER CREATES A NEW INDEX. IT ONLY RETURNS WHAT IS FOUND
		- Tree::Iterator::getEntry()
			- NOTE FROM FUNCTION
							THIS FUNCTION IS ONLY REQUIRED WHEN IS_ELEMENT_DATA_IN_LEAVES_ONLY IS 
							FALSE, BUT TO KEEP THINGS GENERAL IT IS IMPLEMENTED FOR ALL VALID 
							POSSIBILITY WHEN THE INDEX EXISTS. REMEMBER THAT THIS FUNCTION IS MEANT 
							TO BE USED BY THE TREE CLASS
		- THE ITERATION PATTERN IS AS FOLLOWS:
			- ITERATING FARWARD:
							iterator_reset(gIterator);
							
							while(iterator_isValid(gIterator))
							{
								.
								.
								.
								//MEANING, IF NOT iterator_remove() WAS CALLED, OR WAS BUT IT 
								//		FAILED. THE CHECK IS NOT REQUIRED IF REMOVING DOES NOT
								//		HAPPEN.
								if(!tValueRemoved)
									{iterator_next(gIterator);}
							}
			- ITERATING BACKWARD:
							iterator_resetToBack(gIterator);
							
							while(iterator_isValid(gIterator))
							{
								.
								.
								.
								iterator_prev(gIterator);
							}
		- DESIGN CONSIDERATRION / HISTORY
			- ITERATORS CAN BE IMPLEMENTED IN THREE WAYS(WITHOUT RECURSION):
				1- A POINTER TO THE NODE, AND A STRUCTURE THAT KEEPS TRACK OF THE CURRENT NODE
						INDEX IN ITS PARENT, AND THE SAME FOR ALL ITS ANCESTORS. IN THIS CASE,
						EACH NODE WOULD ALSO HAVE TO STORE A POINTER TO ITS PARENT NODE.
				2- A STRUCTURE THAT KEEPS TRACK OF THE CURRENT NODE AND ITS INDEX IN ITS PARENT, 
						AND THE SAME FOR ALL ITS ANCESTORS.
				3- A POINTER TO THE NODE. GOING UP REQUIRES SEARCHING FOR THE NODE IN ITS PARENT
						TO KNOW ITS POSITION.
			- PERSISTANCE: 
				- IN A BINARY TREE, APPROACH '3' GUARANTEES THAT ITERATORS ARE NOT 
						INVALIDATED, IN THE C++ STANDARD'S WORDS, IF ELEMENTS ARE ADDED OR REMOVED
						FROM THE TREE, UNLESS THE ELEMENTS ITSELF THAT THE ITERATOR IS POINTING TO 
						GETS REMOVED.
				- IT IS DESIRABLE TO HAVE PERSISTANCE EQUAL TO THAT OF A BINARY TREE, AND IN 
						PARTICULAR, THE AVL TREE. HOWEVER, BECAUSE OF NODE MERGING DURING DELETION,
						NO MATTER THE APPROACH, ITERATORS THEMSELVES ARE INVALID ONCE AN ELEMENT IS 
						REMOVED. THIS IS TRUE FOR BOTH THE PREMPTIVE APPROACH TO NODE SPLITTING AND 
						MERGING, AND THE NON PREMTIVE APPROACH, AND IS TRUE TO ALL THE VARIATIONS OF 
						THE TREE THAT WOULD BE GENERATED FROM THE GIVEN OPTIONS MENTIONED ELSEWHERE. 
						
						THIS IS NOT TO BE CONFUSED FOR WHEN DELETION IS DONE USING THE ITERATOR.
						SUCH DELETION GUARANTEES THAT THE ITERATOR ITSELF IS CORRECTED, BUT OTHER
						ITERATORS WOULD STILL BECOME INVALID.

						WHEN IT COMES TO ADDITION OF ELEMENTS, ITERATORS CAN BE CORRECTED RELATIVELY 
						QUICKLY BY USER CODE FROM THE CURRENT ITERATOR, BUT AGAIN, UNLESS THE USER
						CODE DOES THE CORRECTION TO AN ITERATOR, THE ITERATOR WOULD BECOME INVALID.
	
*/
/*
	NOTES:
		- GIVEN N IS THE NUMERIC 1 BASED INDEX OF THE MID ELEMENT IN A FULL NODE:
			- THE TOTAL NUMBER OF ELEMENTS A NODE HOLDS IS:	2N - 1
					HENCE THE TOTAL NUMBER OF ELEMENTS A NODE CAN HOLD IS ODD.
			- THE TOTAL NUMBER OF CHILD NODES A NODE HAS IS: 2N
					HENCE THE TOTAL NUMBER OF CHILD NODES A NODE CAN HAVE IS EVEN.
			- WHEN A NODE IS SPLIT, THE NTH ELEMENT IS MOVED TO THE PARENT NODE, LEAVING BOTH
					NODES RESULTING FROM THE SPLIT WITH N - 1 ELEMENTS. A NODE IS ONLY SPLIT
					WHEN FULL.
		- REFERENCE CODE:
			- ELEMENTS STORED IN TREE.
			- NO INDEX.
			- ENTRIES OF ELEMENTS STORED THROUGHOUT TREE.
			- IF MULTIPLE EQUAL ELEMENTS EXIST, CODE DID NOT CARE WHICH ELEMENT IS FOUND.
				- THIS IS EVIDENT IN THE FUNCTION private_getSuitableImagineryIndexFor(), WHICH DID 
						NOT CARE WHICH ELEMENT IT RETURNED IN THAT CASE.
						WHEN IT COMES TO INSERTION, THIS MEANS THAT THERE IS A BIT OF RANDOMNESS
						WHERE AN ELEMENT IS INSERTED WHEN THERE ARE MULTIPLE ELEMENTS ALREADY IN THE
						TREE WITH THE SAME 'VALUE'. IN OTHER WORDS, IT IS NOT GUARANTEED TO BE
						ON THE RIGHT MOST OF ALL THE ELEMENTS EQUAL TO IT.
*/

typedef union Crx_C_Tree_Private_MaximallyAlignedType Crx_C_Tree_Private_MaximallyAlignedType;
typedef union Crx_C_Tree_Private_MaximallyAlignedType
{
	int	_gInt;
	long _gLong;
	long long _glongLong;
	long double _gLongDoube;
	double _gDouble;
	void * _gPointer;
	void (* _gFunc)();
	Crx_C_Tree_Private_MaximallyAlignedType * _gSelf;
} Crx_C_Tree_Private_MaximallyAlignedType;

CRX_ENUM(Crx_C_Tree_Edge,
(
	CRX__C__TREE__EDGE__NULL = 0,
	CRX__C__TREE__EDGE__UNSPECIFIC = 0, /*= CRX__C__TREE__EDGE__NULL*/
	CRX__C__TREE__EDGE__LEFT = 1,
	CRX__C__TREE__EDGE__RIGHT = 2
));

#define CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) (((pTREE_TYPE ## _Private_InternalNode *) \
		pNODE)->gPrivate_buffer.uElements + pINDEX)
#define CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) (((pTREE_TYPE ## _Private_InternalNode *) \
		pNODE)->gPrivate_buffer.uElements + pINDEX)
#define CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) (((pELEMENT_TYPE * *)( \
		((unsigned char *)pNODE) + (pTREE)->gPrivate_internalNode_byteOffsetToElementData)) + pINDEX)
#define CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) (((pELEMENT_TYPE *)( \
		((unsigned char *)(pNODE)) + (pTREE)->gPrivate_internalNode_byteOffsetToElementData)) + pINDEX)

#define CRX__C__TREE__PRIVATE__INNER__RING__NO_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
#define CRX__C__TREE__PRIVATE__INNER__RING__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
#define CRX__C__TREE__PRIVATE__INNER__RING__WITH_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
#define CRX__C__TREE__PRIVATE__INNER__RING__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))

#define CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		(*CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX))
#define CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX)
#define CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		(*CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX))
#define CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX)
		
#define CRX__C__TREE__PRIVATE__INNER__RING__NO_INDEX__PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
#define CRX__C__TREE__PRIVATE__INNER__RING__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
#define CRX__C__TREE__PRIVATE__INNER__RING__WITH_INDEX__PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
#define CRX__C__TREE__PRIVATE__INNER__RING__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
		
#define CRX__C__TREE__PRIVATE__INNER__ARRAY__GET_NODE(pTREE_TYPE, pNODE, pTREE, pINDEX) \
		(((pTREE_TYPE ## _Private_Node * *)(((unsigned char *)pNODE) + \
		(pTREE)->gPrivate_internalNode_byteOffsetToChildNodes)) + pINDEX)

#define CRX__C__TREE__PRIVATE__INNER__RING__GET_NODE(pTREE_TYPE, pNODE, pTREE, pINDEX) \
		(((pTREE_TYPE ## _Private_Node * *)(((unsigned char *)pNODE) + \
		(pTREE)->gPrivate_internalNode_byteOffsetToChildNodes)) + \
		(((pNODE)->gPrivate_startIndex + pINDEX) & \
		(2 * pTREE->gPrviate_countOfMidElementInNode - 1)))

#define CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__GET_INDEX(pTREE_TYPE, \
		pNODE, pTREE, pINDEX) \
		(((pTREE_TYPE ## _Private_InternalNode *)pNODE)->gPrivate_buffer.uIndices + pINDEX)

#define CRX__C__TREE__PRIVATE__INNER__RING__WITH_INDEX__GET_INDEX(pTREE_TYPE, \
		pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__GET_INDEX(pTREE_TYPE, \
		pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))


#define CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		(((pTREE_TYPE ## _Private_LeafNode *)pNODE)->gPrivate_buffer.uElements + pINDEX)
#define CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		(((pTREE_TYPE ## _Private_LeafNode *)pNODE)->gPrivate_buffer.uElements + pINDEX)
#define CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) (((pELEMENT_TYPE * *)(((unsigned char *)pNODE) + \
		(pTREE)->gPrivate_leafNode_byteOffsetToElementData)) + pINDEX)
#define CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) (((pELEMENT_TYPE *)(((unsigned char *)pNODE) + \
		(pTREE)->gPrivate_leafNode_byteOffsetToElementData)) + pINDEX)
		
#define CRX__C__TREE__PRIVATE__LEAF__RING__NO_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
#define CRX__C__TREE__PRIVATE__LEAF__RING__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
#define CRX__C__TREE__PRIVATE__LEAF__RING__WITH_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
#define CRX__C__TREE__PRIVATE__LEAF__RING__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))

#define CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		(*CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX))
#define CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX)
#define CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		(*CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX))
#define CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX)

#define CRX__C__TREE__PRIVATE__LEAF__RING__NO_INDEX__PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
#define CRX__C__TREE__PRIVATE__LEAF__RING__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
#define CRX__C__TREE__PRIVATE__LEAF__RING__WITH_INDEX__PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
#define CRX__C__TREE__PRIVATE__LEAF__RING__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT( \
		pTREE_TYPE, pELEMENT_TYPE, pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))


#define CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__GET_INDEX(pTREE_TYPE, \
		pNODE, pTREE, pINDEX) \
		(((pTREE_TYPE ## _Private_LeafNode *)pNODE)->gPrivate_buffer.uIndices + pINDEX)

#define CRX__C__TREE__PRIVATE__LEAF__RING__WITH_INDEX__GET_INDEX(pTREE_TYPE, \
		pNODE, pTREE, pINDEX) \
		CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__GET_INDEX(pTREE_TYPE, \
		pNODE, pTREE, \
		(((pNODE)->gPrivate_startIndex + pINDEX) & (2 * pTREE->gPrviate_countOfMidElementInNode - 1)))
/* USAGE:
	- OPTIONS:
		- IF pHAS_INDEX IS TRUE. 
			- THE TYPE USES AN INDEX TYPE FOR COMPARISON. THE INDEX FOR AN 
					ELEMENT IS ROUGHLY A KEY EXTRACTED FROM THE ELEMENT. THE ELEMENT DOES NOT NEED 
					TO PRODUCE A UNIQUE INDEX, BUT DOES NEED TO ALWAYS PRODUCE THE SAME INDEX.
			- INDEX TYPE MUST BE TRIVIALLY DESTRUCTABLE, AND RAW COPYABLE.
		- IF pARE_INDICES_IN_INTERNAL_NODES_ONLY IS TRUE, THE TRUE DOES NOT STORE INDICES IN THE
				LEAVES. TRAVERSING THE LEAVES IS STILL DONE WITH INDICES HOWEVER, AND THIS IS
				DONE BY RUNTIME CALCULATION OF THESE INDICES WHEN REQUIRED. THE GENERATED INDICES
				ARE NOT CACHED.
		- IF pIS_PERSISTANT IS TRUE, THE TREE PROVIDES PERSISTANCE AS DEFINED IN MY STANDARD. 
				IN THIS CASE THE ELEMENTS ARE NOT STORED IN THE TREE ITSELF, AND INSTEAD THE TREE 
				STORES POINTERS TO THE ELEMENTS INSTEAD.
		- IF pIS_ELEMENT_DATA_IN_LEAVES_ONLY IS TRUE 
			- THE TREE STORES THE ELEMENTS, OR THEIR POINTERS IF pIS_PERSISTANT IS TRUE, IN THE 
					LEAVES ONLY.
		- IF pIS_CONSERVATIVE_IN_GROWTH IS TRUE, THE ALGORITHM TRIES TO AVOID SPLITTING A NODE BY
				PASSING ENTRIES TO IMMEDIATE SIBLINGS.
		- IF pIS_PREEMPTIVE IS TRUE, NODES DO NOT HAVE POINTERS TO THEIR PARENTS, AND THE ALGORITHM
				WILL PRE EMPTIVELY SPLIT AND MERGE NODES TO AVOID TRAVERSING UP THE TREE. 
				DELETION BY ITERATORS CAN BECOME MORE EXPENSIVE.
		- IF pIS_TO_USE_RINGS IS TRUE, THE NODES WILL STORE DATA IN RINGS INSTEAD OF SEQUENTIAL 
				ARRAYS, AS DEFINED IN MY STANDARD.
	- ITERATOR:
		- WHEN THE ITERATOR IS CONSTRUCTED, IT IS NOT READY. IT MUST BE RESET TO THE BEGGINING OR
				END BEFORE USING IT.
		- ITERATORS ARE INVALIDATED IF TREE IS MODIFIED, UNLESS IT IS AN OPERATION DONE BY THE 
				ITERATOR, IN WHICH CASE, THAT VERY ITERATOR REMAINS VALID.
		- ITERATORS ARE INVALIDATED IF THE TREE IS MOVED.
	- TEMPLATE:
		- OVERRIDES:
			1- CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX,
					pSIZE_T, pSIZE_T_MAX,
					pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS,
					pCOMPARE_ELEMENTS,
					pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR,
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)
			2- CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX,
					pSIZE_T, pSIZE_T_MAX,
					pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS,
					pCOMPARE_ELEMENTS,
					pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR,
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)
			3- CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX,
					pSIZE_T, pSIZE_T_MAX,
					pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS,
					pCOMPARE_ELEMENTS,
					pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR,
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)
			4- CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX,
					pSIZE_T, pSIZE_T_MAX,
					pIS_DELEGATION_MANDATORY,
					pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS,
					pCOMPARE_ELEMENTS,
					pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR,
					pFUNC_ELEMENT_COPY_CONSTRUCTOR,
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR)
			5- CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX,
					pSIZE_T, pSIZE_T_MAX,
					pARE_INDICES_IN_INTERNAL_NODES_ONLY,
					pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_DELEGATION_MANDATORY,
					pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS,
					pCOMPARE_ELEMENTS, pCOMPARE_INDICES,
					pCONSTRUCT_INDEX_FROM,
					pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR,
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR,
					pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR,
					pFUNC_INDEX_COPY_CONSTRUCTOR,
					pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR)
			6- CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX,
					pSIZE_T, pSIZE_T_MAX,
					pARE_INDICES_IN_INTERNAL_NODES_ONLY,
					pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_DELEGATION_MANDATORY,
					pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS,
					pCOMPARE_ELEMENTS, pCOMPARE_INDICES,
					pCONSTRUCT_INDEX_FROM,
					pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR,
					pFUNC_ELEMENT_COPY_CONSTRUCTOR,
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR,
					pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR,
					pFUNC_INDEX_COPY_CONSTRUCTOR,
					pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR)
		- MEANING:
			- OVERRIDES 1 AND 2 DECLARE TREES THAT DO NOT USE AN INDEX, AND THEIR PRIMARY ENTRIES
					ARE EVERYWHERE. USE OVERRIDE '1' IF THE ELEMENT IS NON COPYABLE. USE '2', IF THE
					TYPE OF ELEMENT IS COPYABLE OR RAW COPYABLE.
			- OVERRIDES 3 AND 4 DECLARE TREES THAT DO NOT USE AN INDEX, AND THEIR PRIMARY ENTRIES 
					ARE IN THE LEAVES ONLY. USE OVERRIDE '1' IF THE ELEMENT IS NON COPYABLE. USE 
					'2', IF THE TYPE OF ELEMENT IS COPYABLE OR RAW COPYABLE.
					
					NOTE THAT WHEN THE ELEMENT IS NOT COPYABLE, DELEGATION IS MANDATORY AND 
					THE TREE IS PERSISTANT.
			- OVERRIDES 5 AND 6 DECLARE TREES THAT USE AN INDEX. THE ELEMENTS MAY BE COPYABLE
					AND NON COPYABLE BASED ON THE OVERRIDE CHOSEN.
*/
/* CONTRACT:
	- Tree
		IS FIXED SIZE:			1
		HAS CONSTRUCT:		 	1
		HAS DESTRUCT:		 	1
		IS COPYABLE:			IS_ELEMENT_COPYABLE
		HAS COPY CONSTRUCT:		IS_ELEMENT_COPYABLE
		HAS MOVE CONSTRUCT:		0
		HAS MOVE DESTRUCT:		0

	- Tree::Iterator
		IS FIXED SIZE:			1
		HAS CONSTRUCT:		 	1
		HAS DESTRUCT:		 	CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)
		IS COPYABLE:			1
		HAS COPY CONSTRUCT:		CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)
		HAS MOVE CONSTRUCT:		0
		HAS MOVE DESTRUCT:		0
*/


#if(!CRX_ARE_VARIADIC_MACROS_EMULATED)
	#define CRX__C__Tree__DECLARE(...) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__Tree__DECLARE, __VA_ARGS__)
#else
	#define CRX__C__Tree__DECLARE(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31,p32) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__Tree__DECLARE, p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31,p32)
#endif

/*WITHOUT INDEX, PRIMARY ENTRIES EVERYWHERE*/
#define CRX__C__Tree__DECLARE__13(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, CRXM__FALSE, \
		/*pIS_TO_ENABLE_ELEMENTS_PER_NODE_FIELD,*/ \
		CRXM__FALSE, CRXM__FALSE, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, CRXM__FALSE, \
		CRXM__FALSE, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		\
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
				CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
#define CRX__C__Tree__DECLARE__14(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, CRXM__FALSE, \
		CRXM__FALSE, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		\
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
				CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())

/*WITHOUT INDEX, PRIMARY ENTRIES IN LEAVES ONLY*/
		/*NOTE: WHEN ELEMENT NOT COPYABLE, DELEGATION IS MANDATORY AND TREE IS PERSISTANT*/
#define CRX__C__Tree__DECLARE__12(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, CRXM__FALSE, \
		/*pIS_TO_ENABLE_ELEMENTS_PER_NODE_FIELD,*/ \
		CRXM__TRUE, CRXM__TRUE, \
		CRXM__TRUE, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, CRXM__FALSE, \
		CRXM__FALSE, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		\
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
				CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
#define CRX__C__Tree__DECLARE__15(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pIS_DELEGATION_MANDATORY, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__TRUE, pIS_DELEGATION_MANDATORY, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, CRXM__FALSE, \
		CRXM__FALSE, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		\
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
				CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
		
		
/*WITH INDEX*/
#define CRX__C__Tree__DECLARE__23(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_DELEGATION_MANDATORY, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, pCOMPARE_INDICES, \
		pCONSTRUCT_INDEX_FROM, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR, \
		pFUNC_INDEX_COPY_CONSTRUCTOR, \
		pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR) \
_CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__TRUE, pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_DELEGATION_MANDATORY, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, pCOMPARE_INDICES, \
		pCONSTRUCT_INDEX_FROM, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_INDEX_COPY_CONSTRUCTOR, \
		pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR, \
		\
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
				CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
#define CRX__C__Tree__DECLARE__24(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_DELEGATION_MANDATORY, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, pCOMPARE_INDICES, \
		pCONSTRUCT_INDEX_FROM, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR, \
		pFUNC_INDEX_COPY_CONSTRUCTOR, \
		pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR) \
_CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__TRUE, pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_DELEGATION_MANDATORY, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, pCOMPARE_INDICES, \
		pCONSTRUCT_INDEX_FROM, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_INDEX_COPY_CONSTRUCTOR, \
		pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR, \
		\
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
				CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())


//-----------------------
		

#define _CRX__C__Tree__DECLARE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pHAS_INDEX, pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		/*pIS_TO_ENABLE_ELEMENTS_PER_NODE_FIELD,*/ \
		pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_TO_USE_DELEGATION, \
		pIS_PERSISTANT, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, pCOMPARE_INDICES, \
		pCONSTRUCT_INDEX_FROM, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pIS_ELEMENT_COPYABLE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR, \
		pIS_INDEX_COPYABLE, pFUNC_INDEX_COPY_CONSTRUCTOR, \
		pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR, \
		\
		pINTERNAL__GET_ELEMENT_ENTRY, pINTERNAL__GET_ELEMENT, pINTERNAL__GET_NODE, \
				pINTERNAL__GET_INDEX, \
		pLEAF__GET_ELEMENT_ENTRY, pLEAF__GET_ELEMENT, pLEAF__GET_INDEX, \
		PUBLIC, PRIVATE) \
	\
	/*typedef char pTREE_TYPE_NAME ##__ERROR__INDEX_MUST_BE_USED_IF_ELEMENT_DATA_IN_LEAVES_ONLY[2 * \
			CRXM__IFELSE2(CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, CRXM__NOT(pHAS_INDEX)), \
			0, 1) - 1];*/ \
	typedef char pTREE_TYPE_NAME ## __ERROR__INDEX_MUST_BE_TRIVIALLY_DESTRUCTABLE_AND_RAW_COPYABLE[ \
			2 * CRXM__IFELSE2(CRXM__OR(CRXM__NOT(pHAS_INDEX), \
			CRXM__AND(pIS_INDEX_COPYABLE, CRXM__NOT(CRXM__OR( \
			pFUNC_INDEX_DESTRUCTOR, pFUNC_INDEX_COPY_CONSTRUCTOR)))), 1, 0) - 1]; \
	typedef char pTREE_TYPE_NAME ## __ERROR__ELEMENT_MUST_BE_COPYABLE_IF_ELEMENT_DATA_IN_LEAVES_ONLY_AND_NO_INDEX_USED_AND_TREE_NOT_PERSISTANT[ \
			2 * CRXM__IFELSE2(CRXM__NOT(CRXM__AND(CRXM__AND(CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, \
			CRXM__NOT(pHAS_INDEX)), CRXM__NOT(pIS_PERSISTANT)), CRXM__NOT(pIS_ELEMENT_COPYABLE))), \
			1, 0) - 1]; \
	typedef char pTREE_TYPE_NAME ## __ERROR__ELEMENT_MUST_BE_COPYABLE_IF_ELEMENT_DATA_IN_LEAVES_ONLY_AND_NO_INDEX_USED_AND_TREE_PERSISTANT_AND_WITHOUT_DELEGATION[ \
			2 * CRXM__IFELSE2(CRXM__NOT(CRXM__AND(CRXM__AND(CRXM__AND(CRXM__AND( \
			pIS_ELEMENT_DATA_IN_LEAVES_ONLY, CRXM__NOT(pHAS_INDEX)), pIS_PERSISTANT), \
			CRXM__NOT(pIS_TO_USE_DELEGATION)), CRXM__NOT(pIS_ELEMENT_COPYABLE))), 1, 0) - 1]; \
	\
	typedef struct pTREE_TYPE_NAME ## _Private_Node pTREE_TYPE_NAME ## _Private_Node; \
	typedef struct pTREE_TYPE_NAME ## _Iterator pTREE_TYPE_NAME ## _Iterator; \
	typedef struct pTREE_TYPE_NAME \
	{ \
		CRX_FRIEND_CLASS(pTREE_TYPE_NAME ## _Private_Node) \
	\
		pTREE_TYPE_NAME ## _Private_Node * gPrivate_node__root; \
		size_t gPrivate_internalNode_byteOffsetToChildNodes; /*off_ptr*/ \
		CRXM__IFELSE2(CRXM__AND(pHAS_INDEX, CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)), \
		size_t gPrivate_internalNode_byteOffsetToElementData;, ) \
		CRXM__IFELSE2(CRXM__AND(pHAS_INDEX, CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)), \
		size_t gPrivate_leafNode_byteOffsetToElementData;, ) \
		size_t gPrivate_internalNode_byteLength; /*ilen*/ \
		size_t gPrivate_leafNode_byteLength; /*elen*/ \
		/*size_t gLastIndex;	/*n*/ \
		size_t gPrviate_countOfMidElementInNode; /*t*/ \
		size_t gPrivate_numberOfElements; /*n_keys*/ \
		size_t gPrivate_numberOfNodes; \
	} pTREE_TYPE_NAME; \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## construct(pTREE_TYPE_NAME * pThis, \
			size_t pCountOfMidElementInNode); \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## construct2(pTREE_TYPE_NAME * pThis, \
			size_t pDesiredNumberOfElementsPerNode); \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## construct3(pTREE_TYPE_NAME * pThis, \
			size_t pDesiredByteSizeOfNode, bool pIsToBaseOnLeafNode); \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## construct4(pTREE_TYPE_NAME * pThis, \
			size_t pDesiredByteSizeOfHotRegionInNode); \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## copyConstruct(pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME const * CRX_NOT_NULL pTree); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	CRXM__IFELSE2(CRXM__AND(pIS_PERSISTANT, CRXM__AND(CRXM__NOT(pHAS_INDEX), \
			CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_TO_USE_DELEGATION))), \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_copyConstruct__finishBuildingNode( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME const * CRX_NOT_NULL pTree, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__target, \
			pTREE_TYPE_NAME ## _Private_Node const * CRX_NOT_NULL pNode__source, \
			pELEMENT_TYPE * * pElement__lastSeenNonFirstChildInTarget), \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_copyConstruct__finishBuildingNode( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME const * CRX_NOT_NULL pTree, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__target, \
			pTREE_TYPE_NAME ## _Private_Node const * CRX_NOT_NULL pNode__source));, ) \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## destruct(pTREE_TYPE_NAME * pThis); \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## free(pTREE_TYPE_NAME * pThis); \
	\
	CRX__C__TYPE_BLUE_PRINT__DECLARE_GET_BLUE_PRINT( \
			pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
			CRXM__TRUE, CRXM__TRUE, \
			pIS_COPYABLE, CRXM__TRUE, \
			CRXM__FALSE, CRXM__FALSE); \
	\
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_deleteNode(pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode); \
	\
	CRXM__IFELSE2(pHAS_INDEX, \
	PRIVATE size_t pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node const * CRX_NOT_NULL pNode, \
			pINDEX_TYPE const * CRX_NOT_NULL pIndex__guide /*pKey*/, \
			int32_t * pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode), \
	PRIVATE size_t pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node const * CRX_NOT_NULL pNode, \
			pELEMENT_TYPE const * CRX_NOT_NULL pElement /*pKey*/, \
			int32_t * pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode)); \
	\
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_transferPushFromNodeToNode( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__target, \
			bool pIsToIncludeBegginingChildNode, size_t pStartingIndex); \
	\
	CRXM__IFELSE2(pHAS_INDEX, \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
			pTREE_TYPE_NAME * pThis, pINDEX_TYPE * CRX_NOT_NULL pIndex__guide, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__child, \
			pELEMENT_TYPE * pElement, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t pIndex, bool pIsToIncludeBegginingChildNode), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
			pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__child, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t pIndex, bool pIsToIncludeBegginingChildNode)); \
	\
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_removeFirstNEntriesFrom( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t pWidth); \
	\
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_rotateRight(pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, size_t pIndexOfNodeInParent, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__parent, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__rightSibling); \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_rotateLeft(pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, size_t pIndexOfNodeInParent, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__parent, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__leftSibling); \
	\
	CRXM__IFELSE2(pIS_PREEMPTIVE, \
	PRIVATE uint32_t pMEMBER_FUNCTIONS_PREFIX ## private_resolveFullNode(pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__parent, \
			size_t pIndexOfNodeInParent), \
	PRIVATE uint32_t pMEMBER_FUNCTIONS_PREFIX ## private_resolveFullNode(pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t * CRX_NOT_NULL pIndicesOfNodesInParents)); \
	\
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry( \
			pTREE_TYPE_NAME * pThis, pELEMENT_TYPE * CRX_NOT_NULL pElement); \
	CRXM__IFELSE2(pHAS_INDEX, \
	CRXM__IFELSE2(pIS_PREEMPTIVE, \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			pINDEX_TYPE * CRX_NOT_NULL pIndex, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement), \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t * CRX_NOT_NULL pIndexOfNodeInParent, \
			pINDEX_TYPE * CRX_NOT_NULL pIndex, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement)), \
	CRXM__IFELSE2(pIS_PREEMPTIVE, \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement), \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t * CRX_NOT_NULL pIndexOfNodeInParent, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement))); \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## tryMoveAndInsertElement(pTREE_TYPE_NAME * pThis, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement); \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## insertElement(pTREE_TYPE_NAME * pThis, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement), ); \
	\
	PRIVATE pTREE_TYPE_NAME ## _Private_Node * pMEMBER_FUNCTIONS_PREFIX ## mergeTwoNodesAndGetRemainingNode( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t pIndex); \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## removeElement(pTREE_TYPE_NAME * pThis, \
			pELEMENT_TYPE const * CRX_NOT_NULL pElement); \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	CRXM__IFELSE2(pHAS_INDEX, \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE * pElement, \
			pTREE_TYPE_NAME ## _Iterator * pIterator), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE * * pElement, \
			pTREE_TYPE_NAME ## _Iterator * pIterator)), \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pELEMENT_TYPE * pElement), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pELEMENT_TYPE * * pElement))), \
	CRXM__IFELSE2(pHAS_INDEX, \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE const * pElement, \
			pINDEX_TYPE * pIndex__out), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE const * pElement, \
			pINDEX_TYPE * pIndex__out)), \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pELEMENT_TYPE const * pElement, pELEMENT_TYPE * pElement__out), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pELEMENT_TYPE const * pElement, pELEMENT_TYPE * * pElement__out)))); \
	CRXM__IFELSE2(CRXM__AND(pHAS_INDEX, CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)), \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE uint32_t /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do__findExactEntry( \
			pTREE_TYPE_NAME * pThis, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE const * pElement, \
			pTREE_TYPE_NAME ## _Iterator const * pIterator, \
			pTREE_TYPE_NAME ## _Iterator * pIterator__return), \
	PRIVATE uint32_t /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do__findExactEntry( \
			pTREE_TYPE_NAME * pThis, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE * * pElement, \
			pTREE_TYPE_NAME ## _Iterator const * pIterator, \
			pTREE_TYPE_NAME ## _Iterator * pIterator__return));, ) \
	\
	CRXM__IFELSE2(CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, CRXM__NOT(pIS_PREEMPTIVE)), \
	PRIVATE size_t pMEMBER_FUNCTIONS_PREFIX ## private_findChildNodeIndexInParent( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode);, ) \
	\
	CRXM__IFELSE2(CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_PREEMPTIVE), \
	PRIVATE size_t pMEMBER_FUNCTIONS_PREFIX ## private_getTraceOfLeafNode( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			pTREE_TYPE_NAME ## _Private_Node * * CRX_NOT_NULL pNodes, \
			size_t * CRX_NOT_NULL pIndices);, ) \
	\
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_decrementNumberOfElements( \
			pTREE_TYPE_NAME * pThis); \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_decrementNumberOfNodes( \
			pTREE_TYPE_NAME * pThis); \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_unsafePopRootNode( \
			pTREE_TYPE_NAME * pThis); \
	\
	\
	typedef struct pTREE_TYPE_NAME ## _Private_Node \
	{ \
		CRX_FRIEND_CLASS(pTREE_TYPE_NAME) \
	\
		bool gPrivate_type; /*0: LEAF.  1: INTERNAL*/ \
		size_t gPrivate_numberOfEntries; /*= N*/ \
		CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
		pTREE_TYPE_NAME ## _Private_Node * gPrivate_node__parent;, ) \
		CRXM__IFELSE2(pIS_TO_USE_RINGS, \
		size_t gPrivate_startIndex;, ) \
	} pTREE_TYPE_NAME ## _Private_Node; \
	\
	\
	typedef struct pTREE_TYPE_NAME ## _Private_InternalNode \
	{ \
		CRX_FRIEND_CLASS(pTREE_TYPE_NAME) \
	\
		pTREE_TYPE_NAME ## _Private_Node gPrivate_node; \
		union \
		{ \
			/*Crx_C_Tree_Private_MaximallyAlignedType _ufdgd;*/ \
			/* \
				!pHAS_INDEX: \
							|<-- (X) ELEMENT ENTRIES -->||<-- (X + 1) Node * -->| \
				pHAS_INDEX, !pIS_ELEMENT_DATA_IN_LEAVES_ONLY: \
							|<-- (X) INDICES -->||<-- (X + 1) Node * -->||<-- (X) ELEMENT ENTRIES -->| \
				pHAS_INDEX, pIS_ELEMENT_DATA_IN_LEAVES_ONLY: \
							|<-- (X) INDICES -->||<-- (X + 1) Node * -->| \
			*/ \
			unsigned char uBytes[1]; \
			CRXM__IFELSE2(CRXM__NOT(pHAS_INDEX), \
			pELEMENT_TYPE CRXM__IFELSE2(pIS_PERSISTANT, *, ) uElements[1];, ) \
			CRXM__IFELSE2(pHAS_INDEX, \
			pINDEX_TYPE uIndices[1], ); \
		} gPrivate_buffer; \
	} pTREE_TYPE_NAME ## _Private_InternalNode; \
	\
	\
	CRXM__IFELSE2(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, \
	typedef struct pTREE_TYPE_NAME ## _Private_LeafNode pTREE_TYPE_NAME ## _Private_LeafNode;, ) \
	\
	typedef struct pTREE_TYPE_NAME ## _Private_LeafNode \
	{ \
		CRX_FRIEND_CLASS(pTREE_TYPE_NAME) \
	\
		pTREE_TYPE_NAME ## _Private_Node gPrivate_node; \
		CRXM__IFELSE2(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, \
		pTREE_TYPE_NAME ## _Private_LeafNode * gPrivate_leafNode__next;, ) \
		CRXM__IFELSE2(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, \
		pTREE_TYPE_NAME ## _Private_LeafNode * gPrivate_leafNode__prev;, ) \
		union \
		{ \
			/*Crx_C_Tree_Private_MaximallyAlignedType _ufdgd;*/ \
			/* \
				!pHAS_INDEX || pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
								|<-- (X) ELEMENT ENTRIES -->| \
				pHAS_INDEX, !pARE_INDICES_IN_INTERNAL_NODES_ONLY: \
								|<-- (X) INDICES -->||<-- (X) ELEMENT ENTRIES -->| \
			*/ \
			unsigned char uBytes[1]; \
			CRXM__IFELSE2(CRXM__OR(CRXM__NOT(pHAS_INDEX), pARE_INDICES_IN_INTERNAL_NODES_ONLY), \
			pELEMENT_TYPE CRXM__IFELSE2(pIS_PERSISTANT, *, ) uElements[1];, ) \
			CRXM__IFELSE2(CRXM__AND(pHAS_INDEX, CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)), \
			pINDEX_TYPE uIndices[1], ); \
		} gPrivate_buffer; \
	} pTREE_TYPE_NAME ## _Private_LeafNode; \
	\
	\
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	typedef struct pTREE_TYPE_NAME ## _Iterator_Private_Position \
			pTREE_TYPE_NAME ## _Iterator_Private_Position;, ) \
	typedef struct pTREE_TYPE_NAME ## _Iterator \
	{ \
		CRX_FRIEND_CLASS(pTREE_TYPE_NAME) \
	\
		bool gPrivate_isConstant; \
		CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
		bool gPrivate_isPositionsMine;, ) \
		pTREE_TYPE_NAME * CRX_NOT_MINE gPrivate_tree; \
		CRXM__IFELSE2(CRXM__OR(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, CRXM__NOT(pIS_PREEMPTIVE)), \
		pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_MINE gPrivate_node;, ) \
		CRXM__IFELSE2(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, \
		size_t gPrivate_elementIndex;, ) \
		CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
		pTREE_TYPE_NAME ## _Iterator_Private_Position * gPrivate_positions;, ) \
		CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
		pTREE_TYPE_NAME ## _Iterator_Private_Position * CRX_NOT_MINE gPrivate_position__current;, ) \
	} pTREE_TYPE_NAME ## _Iterator; \
	\
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_construct( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pTREE_TYPE_NAME * pTree); \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_construct2( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pTREE_TYPE_NAME const * pTree); \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_construct3( \
			pTREE_TYPE_NAME ## _Iterator * pThis, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPositions, \
			pTREE_TYPE_NAME const * pTree), ); \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE void _ ## pMEMBER_FUNCTIONS_PREFIX ## iterator_construct( \
			pTREE_TYPE_NAME ## _Iterator * pThis, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPositions, \
			bool pIsConstant, pTREE_TYPE_NAME * pTree), \
	PRIVATE void _ ## pMEMBER_FUNCTIONS_PREFIX ## iterator_construct( \
			pTREE_TYPE_NAME ## _Iterator * pThis, bool pIsConstant, \
			pTREE_TYPE_NAME * pTree)); \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_copyConstruct( \
			pTREE_TYPE_NAME ## _Iterator * pThis, \
			pTREE_TYPE_NAME ## _Iterator const * CRX_NOT_NULL pIterator);, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_copyConstructFrom( \
			pTREE_TYPE_NAME ## _Iterator * pThis, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPositions, \
			pTREE_TYPE_NAME ## _Iterator const * CRX_NOT_NULL pIterator);, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_copyConstructUsing( \
			pTREE_TYPE_NAME ## _Iterator * pThis, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPositions, \
			pTREE_TYPE_NAME ## _Iterator const * CRX_NOT_NULL pIterator);, ) \
	\
	PUBLIC pTREE_TYPE_NAME ## _Iterator * pMEMBER_FUNCTIONS_PREFIX ## iterator_new( \
			pTREE_TYPE_NAME * pTree); \
	PUBLIC pTREE_TYPE_NAME ## _Iterator * pMEMBER_FUNCTIONS_PREFIX ## iterator_new2( \
			pTREE_TYPE_NAME const * pTree); \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE pTREE_TYPE_NAME ## _Iterator * pMEMBER_FUNCTIONS_PREFIX ## iterator_private_new3( \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPositions, \
			pTREE_TYPE_NAME const * pTree);, ) \
	PUBLIC pTREE_TYPE_NAME ## _Iterator * pMEMBER_FUNCTIONS_PREFIX ## iterator_moveNew( \
			pTREE_TYPE_NAME ## _Iterator * CRX_NOT_NULL pIterator); \
	PUBLIC pTREE_TYPE_NAME ## _Iterator * pMEMBER_FUNCTIONS_PREFIX ## iterator_copyNew( \
			pTREE_TYPE_NAME ## _Iterator const * CRX_NOT_NULL pIterator); \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PUBLIC pTREE_TYPE_NAME ## _Iterator * pMEMBER_FUNCTIONS_PREFIX ## iterator_private_copyNewUsing( \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPositions, \
			pTREE_TYPE_NAME ## _Iterator const * CRX_NOT_NULL pIterator);, ) \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_destruct( \
			pTREE_TYPE_NAME ## _Iterator * pThis);, ) \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_free(pTREE_TYPE_NAME ## _Iterator * pThis); \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_copyAssignFrom( \
			pTREE_TYPE_NAME ## _Iterator * pThis, \
			pTREE_TYPE_NAME ## _Iterator const * CRX_NOT_NULL pIterator);, ) \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_associateWith( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pTREE_TYPE_NAME * pTree); \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_constantAssociateWith( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pTREE_TYPE_NAME const * pTree); \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_doAssociateWith( \
			pTREE_TYPE_NAME ## _Iterator * pThis, bool pIsConstant, \
			pTREE_TYPE_NAME const * pTree); \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_reset(pTREE_TYPE_NAME ## _Iterator * pThis); \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_resetToBack( \
			pTREE_TYPE_NAME ## _Iterator * pThis); \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_isEqualTo( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pTREE_TYPE_NAME ## _Iterator const * pIterator); \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_next(pTREE_TYPE_NAME ## _Iterator * pThis); \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_prev(pTREE_TYPE_NAME ## _Iterator * pThis); \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_isValid( \
			pTREE_TYPE_NAME ## _Iterator * pThis); \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_setToPositionOf( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pELEMENT_TYPE const * pElement, \
			Crx_C_Tree_Edge pEdge); \
	CRXM__IFELSE2(pHAS_INDEX, \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## iterator_setToPositionOf__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pINDEX_TYPE const * pIndex__guide, \
			Crx_C_Tree_Edge pEdge), \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## iterator_setToPositionOf__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pELEMENT_TYPE const * pElement, \
			Crx_C_Tree_Edge pEdge)); \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_remove(pTREE_TYPE_NAME ## _Iterator * pThis); \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	CRXM__IFELSE2(pHAS_INDEX, \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPosition__current, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE * pElement, \
			bool * CRX_NOT_NULL pIsToAdvance), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPosition__current, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE * * pElement, \
			bool * CRX_NOT_NULL pIsToAdvance)), \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPosition__current, \
			pELEMENT_TYPE * pElement, bool * CRX_NOT_NULL pIsToAdvance), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPosition__current, \
			pELEMENT_TYPE * * pElement, bool * CRX_NOT_NULL pIsToAdvance))), \
	CRXM__IFELSE2(pHAS_INDEX, \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, size_t * pIndices, size_t pIndexInIndices, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE const * pElement, \
			pINDEX_TYPE *  pIndex__out), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, size_t * pIndices, size_t pIndexInIndices, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE const * pElement, \
			pINDEX_TYPE * pIndex__out)), \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, size_t * pIndices, size_t pIndexInIndices, \
			pELEMENT_TYPE const * pElement, \
			pELEMENT_TYPE * pElement__out), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, size_t * pIndices, size_t pIndexInIndices, \
			pELEMENT_TYPE const * pElement, \
			pELEMENT_TYPE * * pElement__out)))); \
	\
	PUBLIC pELEMENT_TYPE * pMEMBER_FUNCTIONS_PREFIX ## iterator_get( \
			pTREE_TYPE_NAME ## _Iterator const * pThis); \
	PUBLIC pELEMENT_TYPE const * pMEMBER_FUNCTIONS_PREFIX ## iterator_constantGet( \
			pTREE_TYPE_NAME ## _Iterator const * pThis); \
	PRIVATE pELEMENT_TYPE * pMEMBER_FUNCTIONS_PREFIX ## iterator_private_doGet( \
			pTREE_TYPE_NAME ## _Iterator const * pThis); \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPush( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			size_t pIndex);, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPop( \
			pTREE_TYPE_NAME ## _Iterator * pThis);, ) \
	\
	CRXM__IFELSE2(pHAS_INDEX, \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## iterator_private_isInInternalNode( \
			pTREE_TYPE_NAME ## _Iterator * pThis);, ) \
	CRXM__IFELSE2(pHAS_INDEX, \
	PRIVATE pINDEX_TYPE * pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getIndex( \
			pTREE_TYPE_NAME ## _Iterator * pThis);, ) \
	CRXM__IFELSE2(pHAS_INDEX, \
	CRXM__IFELSE2(pIS_PERSISTANT, \
	PRIVATE pELEMENT_TYPE * * pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getEntry( \
			pTREE_TYPE_NAME ## _Iterator * pThis), \
	PRIVATE pELEMENT_TYPE * pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getEntry( \
			pTREE_TYPE_NAME ## _Iterator * pThis)), ); \
	\
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	typedef struct pTREE_TYPE_NAME ## _Iterator_Private_Position \
	{ \
		CRXM__IFELSE2(pIS_PREEMPTIVE, \
		pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_MINE gNode;, ) \
		size_t gIndex; /*THIS IS INDEX OF NEXT CHILD IF gNode IS NOT NULL.*/ \
	} pTREE_TYPE_NAME ## _Iterator_Private_Position;, )
//#END_DEFINE



#if(!CRX_ARE_VARIADIC_MACROS_EMULATED)
	#define CRX__C__Tree__DEFINE(...) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__Tree__DEFINE, __VA_ARGS__)
#else
	#define CRX__C__Tree__DEFINE(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31,p32) CRXM__RESOLVE_OVERLOADED_MACRO_CALL(CRX__C__Tree__DEFINE, p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31,p32)
#endif

/*WITHOUT INDEX, PRIMARY ENTRIES EVERYWHERE*/
#define CRX__C__Tree__DEFINE__13(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__Tree__DEFINE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, CRXM__FALSE, \
		/*pIS_TO_ENABLE_ELEMENTS_PER_NODE_FIELD,*/ \
		CRXM__FALSE, CRXM__FALSE, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, CRXM__FALSE, \
		CRXM__FALSE, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		\
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
				CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
#define CRX__C__Tree__DEFINE__14(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__Tree__DEFINE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, CRXM__FALSE, \
		CRXM__FALSE, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		\
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
				CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())

/*WITHOUT INDEX, PRIMARY ENTRIES IN LEAVES ONLY*/
		/*NOTE: WHEN ELEMENT NOT COPYABLE, DELEGATION IS MANDATORY AND TREE IS PERSISTANT*/
#define CRX__C__Tree__DEFINE__12(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__Tree__DEFINE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, CRXM__FALSE, \
		/*pIS_TO_ENABLE_ELEMENTS_PER_NODE_FIELD,*/ \
		CRXM__TRUE, CRXM__TRUE, \
		CRXM__TRUE, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, CRXM__FALSE, \
		CRXM__FALSE, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		\
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
				CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
#define CRX__C__Tree__DEFINE__15(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pIS_DELEGATION_MANDATORY, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR) \
_CRX__C__Tree__DEFINE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__TRUE, pIS_DELEGATION_MANDATORY, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, CRXM__FALSE, \
		CRXM__FALSE, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, \
		\
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
				CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
		
		
/*WITH INDEX*/
#define CRX__C__Tree__DEFINE__23(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_DELEGATION_MANDATORY, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, pCOMPARE_INDICES, \
		pCONSTRUCT_INDEX_FROM, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR, \
		pFUNC_INDEX_COPY_CONSTRUCTOR, \
		pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR) \
_CRX__C__Tree__DEFINE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__TRUE, pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_DELEGATION_MANDATORY, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, pCOMPARE_INDICES, \
		pCONSTRUCT_INDEX_FROM, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__FALSE, CRXM__FALSE, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_INDEX_COPY_CONSTRUCTOR, \
		pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR, \
		\
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
				CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())
#define CRX__C__Tree__DEFINE__24(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_DELEGATION_MANDATORY, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, pCOMPARE_INDICES, \
		pCONSTRUCT_INDEX_FROM, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR, \
		pFUNC_INDEX_COPY_CONSTRUCTOR, \
		pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR) \
_CRX__C__Tree__DEFINE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		CRXM__TRUE, pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_DELEGATION_MANDATORY, \
		pIS_PERSISTANCE_MANDATORY, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, pCOMPARE_INDICES, \
		pCONSTRUCT_INDEX_FROM, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR, \
		CRXM__TRUE, pFUNC_INDEX_COPY_CONSTRUCTOR, \
		pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR, \
		\
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
				CRXM__FALSE, \
		CRXM__FALSE, CRXM__FALSE, CRXM__FALSE, \
		CRX__LIB__PUBLIC_C_FUNCTION(), CRX__LIB__PRIVATE_C_FUNCTION())


//-----------------------


#define _CRX__C__Tree__DEFINE(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pHAS_INDEX, pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		/*pIS_TO_ENABLE_ELEMENTS_PER_NODE_FIELD,*/ \
		pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_TO_USE_DELEGATION, \
		pIS_PERSISTANT, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, pCOMPARE_INDICES, \
		pCONSTRUCT_INDEX_FROM, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pIS_ELEMENT_COPYABLE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR, \
		pIS_INDEX_COPYABLE, pFUNC_INDEX_COPY_CONSTRUCTOR, \
		pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR, \
		\
		pINTERNAL__GET_ELEMENT_ENTRY, pINTERNAL__GET_ELEMENT, pINTERNAL__GET_NODE, \
				pINTERNAL__GET_INDEX, \
		pLEAF__GET_ELEMENT_ENTRY, pLEAF__GET_ELEMENT, pLEAF__GET_INDEX, \
		PUBLIC, PRIVATE) \
		\
		_CRX__C__Tree__DEFINE__DO(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pHAS_INDEX, pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		/*pIS_TO_ENABLE_ELEMENTS_PER_NODE_FIELD,*/ \
		pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_TO_USE_DELEGATION, \
		pIS_PERSISTANT, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, pCOMPARE_INDICES, \
		pCONSTRUCT_INDEX_FROM, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pIS_ELEMENT_COPYABLE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR, \
		pIS_INDEX_COPYABLE, pFUNC_INDEX_COPY_CONSTRUCTOR, \
		pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR, \
		\
		CRXM__IFELSE2(pIS_TO_USE_RINGS, \
				CRXM__IFELSE2(pHAS_INDEX, \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__INNER__RING__WITH_INDEX__PERSISTANT__GET_ELEMENT_ENTRY, \
								CRX__C__TREE__PRIVATE__INNER__RING__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY), \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__INNER__RING__NO_INDEX__PERSISTANT__GET_ELEMENT_ENTRY, \
								CRX__C__TREE__PRIVATE__INNER__RING__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY)), \
				CRXM__IFELSE2(pHAS_INDEX, \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT_ENTRY, \
								CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY), \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT_ENTRY, \
								CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY))), \
		CRXM__IFELSE2(pIS_TO_USE_RINGS, \
				CRXM__IFELSE2(pHAS_INDEX, \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__INNER__RING__WITH_INDEX__PERSISTANT__GET_ELEMENT, \
								CRX__C__TREE__PRIVATE__INNER__RING__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT), \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__INNER__RING__NO_INDEX__PERSISTANT__GET_ELEMENT, \
								CRX__C__TREE__PRIVATE__INNER__RING__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT)), \
				CRXM__IFELSE2(pHAS_INDEX, \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT, \
								CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT), \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT, \
								CRX__C__TREE__PRIVATE__INNER__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT))), \
		CRXM__IFELSE2(pIS_TO_USE_RINGS, \
				CRX__C__TREE__PRIVATE__INNER__RING__GET_NODE, \
				CRX__C__TREE__PRIVATE__INNER__ARRAY__GET_NODE), \
		CRXM__IFELSE2(pHAS_INDEX, \
				CRXM__IFELSE2(pIS_TO_USE_RINGS, \
						CRX__C__TREE__PRIVATE__INNER__RING__WITH_INDEX__GET_INDEX, \
						CRX__C__TREE__PRIVATE__INNER__ARRAY__WITH_INDEX__GET_INDEX), \
				CRXM__FALSE), \
		CRXM__IFELSE2(pIS_TO_USE_RINGS, \
				CRXM__IFELSE2(CRXM__AND(pHAS_INDEX, CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)), \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__LEAF__RING__WITH_INDEX__PERSISTANT__GET_ELEMENT_ENTRY, \
								CRX__C__TREE__PRIVATE__LEAF__RING__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY), \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__LEAF__RING__NO_INDEX__PERSISTANT__GET_ELEMENT_ENTRY, \
								CRX__C__TREE__PRIVATE__LEAF__RING__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY)), \
				CRXM__IFELSE2(CRXM__AND(pHAS_INDEX, CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)), \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT_ENTRY, \
								CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY), \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT_ENTRY, \
								CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT_ENTRY))), \
		CRXM__IFELSE2(pIS_TO_USE_RINGS, \
				CRXM__IFELSE2(CRXM__AND(pHAS_INDEX, CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)), \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__LEAF__RING__WITH_INDEX__PERSISTANT__GET_ELEMENT, \
								CRX__C__TREE__PRIVATE__LEAF__RING__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT), \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__LEAF__RING__NO_INDEX__PERSISTANT__GET_ELEMENT, \
								CRX__C__TREE__PRIVATE__LEAF__RING__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT)), \
				CRXM__IFELSE2(CRXM__AND(pHAS_INDEX, CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)), \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__PERSISTANT__GET_ELEMENT, \
								CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__NOT_PERSISTANT__GET_ELEMENT), \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__PERSISTANT__GET_ELEMENT, \
								CRX__C__TREE__PRIVATE__LEAF__ARRAY__NO_INDEX__NOT_PERSISTANT__GET_ELEMENT))), \
		CRXM__IFELSE2(pHAS_INDEX, \
				CRXM__IFELSE2(pIS_TO_USE_RINGS, \
						CRX__C__TREE__PRIVATE__LEAF__RING__WITH_INDEX__GET_INDEX, \
						CRX__C__TREE__PRIVATE__LEAF__ARRAY__WITH_INDEX__GET_INDEX), \
				CRXM__FALSE), \
		PUBLIC, PRIVATE)
#define _CRX__C__Tree__DEFINE__DO(pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
		pSIZE_T, pSIZE_T_MAX, \
		pHAS_INDEX, pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		/*pIS_TO_ENABLE_ELEMENTS_PER_NODE_FIELD,*/ \
		pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_TO_USE_DELEGATION, \
		pIS_PERSISTANT, pIS_CONSERVATIVE_IN_GROWTH, pIS_PREEMPTIVE, pIS_TO_USE_RINGS, \
		pCOMPARE_ELEMENTS, pCOMPARE_INDICES, \
		pCONSTRUCT_INDEX_FROM, \
		pELEMENT_TYPE, pFUNC_ELEMENT_DESTRUCTOR, \
		pIS_ELEMENT_COPYABLE, pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
		pFUNC_ELEMENT_MOVE_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
		pINDEX_TYPE, pFUNC_INDEX_DESTRUCTOR, \
		pIS_INDEX_COPYABLE, pFUNC_INDEX_COPY_CONSTRUCTOR, \
		pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR, \
		\
		pINTERNAL__GET_ELEMENT_ENTRY, pINTERNAL__GET_ELEMENT, pINTERNAL__GET_NODE, \
				pINTERNAL__GET_INDEX, \
		pLEAF__GET_ELEMENT_ENTRY, pLEAF__GET_ELEMENT, pLEAF__GET_INDEX, \
		PUBLIC, PRIVATE) \
	\
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## construct(pTREE_TYPE_NAME * pThis, \
			size_t pCountOfMidElementInNode) \
	{ \
		size_t vCountOfMidElementInNode = pCountOfMidElementInNode; \
		size_t vNumberOfElementsPerNode = 0; \
		pTREE_TYPE_NAME ## _Private_InternalNode vInternalNode /*= ?*/; \
		pTREE_TYPE_NAME ## _Private_LeafNode vLeafNode /*= ?*/; \
		pTREE_TYPE_NAME ## _Private_LeafNode * vLeafNode__2 = NULL; \
	\
		/*SEE THE ELEMENT REMOVING FUNCTIONS*/ \
		CRXM__IFELSE(CRXM_OR(CRXM_OR(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), pIS_PREEMPTIVE), \
				CRXM__NOT(pIS_TO_USE_DELEGATION))) \
		( \
			if(vCountOfMidElementInNode < 2) \
				{vCountOfMidElementInNode = 2;} \
		) \
		( \
			if(vCountOfMidElementInNode < 3) \
				{vCountOfMidElementInNode = 3;} \
		) \
	\
		/*NUMBER OF CHILD NODES PER NODE IS vNumberOfElementsPerNode + 1. IF USING RINGS, AN \
				EMPTY SPACE IS ADDED AT THE END FOR THE INDICES AND ELEMENTS, BUT THE EFFECTIVE \
				CAPACITY REMAINS THE SAME, MEANING THE LAST SPACE IS NEVER USED.*/ \
		CRXM__IFELSE(pIS_TO_USE_RINGS) \
		( \
			size_t tCountOfMidKeyInNode = 2; \
	\
			while(tCountOfMidKeyInNode < vCountOfMidElementInNode) \
				{tCountOfMidKeyInNode = (tCountOfMidKeyInNode << 1);} \
	\
			vCountOfMidElementInNode = tCountOfMidKeyInNode; \
	\
			/*THE CAPACITY LIMIT IS 1/3 OF MAXIMUM(UINT32_MAX/2) BECAUSE OF ONE OF THE RING 
					ALGORITHMS EMPLOYED, BUT USING 1/4 TO KEEP THE CALCULATION SIMPLE */ \
			if(vCountOfMidElementInNode > (UINT32_MAX >> 4)) \
				{vCountOfMidElementInNode = (UINT32_MAX >> 4);} \
		) \
		( \
			if(vCountOfMidElementInNode > (UINT32_MAX >> 2)) \
				{vCountOfMidElementInNode = (UINT32_MAX >> 2);} \
		) \
	\
		vNumberOfElementsPerNode = (2 * vCountOfMidElementInNode) - 1; \
	\
		pThis->gPrviate_countOfMidElementInNode = vCountOfMidElementInNode; \
	\
		CRXM__IFELSE(CRXM__NOT(pHAS_INDEX)) \
		( \
			pThis->gPrivate_internalNode_byteOffsetToChildNodes = \
					CRX__TREE__PRIVATE__ROUND_TO_POINTER_ALIGNMENT( \
					(((volatile void const *)&(vInternalNode.gPrivate_buffer)) - \
					((volatile void const *)&vInternalNode)) + \
					((vNumberOfElementsPerNode + CRXM__IFELSE2(pIS_TO_USE_RINGS, 1, 0)) * \
					sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE)))); \
			pThis->gPrivate_internalNode_byteLength = \
					pThis->gPrivate_internalNode_byteOffsetToChildNodes + \
					((vNumberOfElementsPerNode + 1) * \
					sizeof(pTREE_TYPE_NAME ## _Private_Node *)); \
	\
			pThis->gPrivate_leafNode_byteLength = \
					(((volatile void const *)&(vLeafNode.gPrivate_buffer)) - \
					((volatile void const *)&vLeafNode)) + \
					((vNumberOfElementsPerNode + CRXM__IFELSE2(pIS_TO_USE_RINGS, 1, 0)) * \
					sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE))); \
		) \
		( \
			pThis->gPrivate_internalNode_byteOffsetToChildNodes = \
					CRX__TREE__PRIVATE__ROUND_TO_POINTER_ALIGNMENT( \
					(((volatile void const *)&(vInternalNode.gPrivate_buffer)) - \
					((volatile void const *)&vInternalNode)) + \
					((vNumberOfElementsPerNode + CRXM__IFELSE2(pIS_TO_USE_RINGS, 1, 0)) * \
					sizeof(pINDEX_TYPE))); \
	\
			CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
			( \
				pThis->gPrivate_internalNode_byteOffsetToElementData =  \
						pThis->gPrivate_internalNode_byteOffsetToChildNodes + \
						((vNumberOfElementsPerNode + 1) * \
						sizeof(pTREE_TYPE_NAME ## _Private_Node *)); \
	\
				CRXM__IFELSE(pIS_PERSISTANT) \
				( \
					pThis->gPrivate_internalNode_byteOffsetToElementData = \
							CRX__TREE__PRIVATE__ROUND_TO_POINTER_ALIGNMENT( \
							pThis->gPrivate_internalNode_byteOffsetToElementData); \
				) \
				( \
					pThis->gPrivate_internalNode_byteOffsetToElementData = \
							CRX__TREE__PRIVATE__ROUND_TO_GENERAL_ALIGNMENT( \
							pThis->gPrivate_internalNode_byteOffsetToElementData); \
				) \
	\
				pThis->gPrivate_internalNode_byteLength = \
						pThis->gPrivate_internalNode_byteOffsetToElementData + \
						((vNumberOfElementsPerNode + CRXM__IFELSE2(pIS_TO_USE_RINGS, 1, 0)) * \
						sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE))); \
			) \
			( \
				pThis->gPrivate_internalNode_byteLength = \
						pThis->gPrivate_internalNode_byteOffsetToChildNodes + \
						((vNumberOfElementsPerNode + 1) * \
						sizeof(pTREE_TYPE_NAME ## _Private_Node *)); \
			) \
	\
			CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
			( \
				pThis->gPrivate_leafNode_byteOffsetToElementData = \
						(((volatile void const *)&(vLeafNode.gPrivate_buffer)) - \
						((volatile void const *)&vLeafNode)) + \
						((vNumberOfElementsPerNode + CRXM__IFELSE2(pIS_TO_USE_RINGS, 1, 0)) * \
						sizeof(pINDEX_TYPE)); \
	\
				CRXM__IFELSE(pIS_PERSISTANT) \
				( \
					pThis->gPrivate_leafNode_byteOffsetToElementData = \
							CRX__TREE__PRIVATE__ROUND_TO_POINTER_ALIGNMENT( \
							pThis->gPrivate_leafNode_byteOffsetToElementData); \
				) \
				( \
					pThis->gPrivate_leafNode_byteOffsetToElementData = \
							CRX__TREE__PRIVATE__ROUND_TO_GENERAL_ALIGNMENT( \
							pThis->gPrivate_leafNode_byteOffsetToElementData); \
				) \
	\
				pThis->gPrivate_leafNode_byteLength = \
						pThis->gPrivate_leafNode_byteOffsetToElementData + \
						((vNumberOfElementsPerNode + CRXM__IFELSE2(pIS_TO_USE_RINGS, 1, 0)) * \
						sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE))); \
			) \
			( \
				pThis->gPrivate_leafNode_byteLength = \
						(((volatile void const *)&(vLeafNode.gPrivate_buffer)) - \
						((volatile void const *)&vLeafNode)) + \
						((vNumberOfElementsPerNode + CRXM__IFELSE2(pIS_TO_USE_RINGS, 1, 0)) * \
						sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE))); \
			) \
		) \
	\
		vLeafNode__2 = (pTREE_TYPE_NAME ## _Private_LeafNode *)calloc(1, \
				pThis->gPrivate_leafNode_byteLength); \
	\
		if(vLeafNode__2 != NULL) \
		{ \
			pThis->gPrivate_node__root = &(vLeafNode__2->gPrivate_node); \
			pThis->gPrivate_numberOfNodes = 1; \
		} \
		else \
		{ \
			pThis->gPrivate_node__root = NULL; \
			pThis->gPrivate_numberOfNodes = 0; \
		} \
	\
		pThis->gPrivate_numberOfElements = 0; \
	} \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## construct2(pTREE_TYPE_NAME * pThis, \
			size_t pDesiredNumberOfElementsPerNode) \
	{ \
		if(pDesiredNumberOfElementsPerNode >= (UINT32_MAX >> 1)) \
			{pMEMBER_FUNCTIONS_PREFIX ## construct(pThis, (UINT32_MAX >> 2));} \
		else \
		{ \
			pMEMBER_FUNCTIONS_PREFIX ## construct(pThis, \
					((pDesiredNumberOfElementsPerNode + 2) >> 1)); \
		} \
	} \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## construct3(pTREE_TYPE_NAME * pThis, \
			size_t pDesiredByteSizeOfNode, bool pIsToBaseOnLeafNode) \
	{ \
		double vNumberOfElementsPerNode = 0; \
	\
		if(!pIsToBaseOnLeafNode) \
		{ \
			pTREE_TYPE_NAME ## _Private_InternalNode tInternalNode /*= ?*/; \
	\
			CRXM__IFELSE(CRXM__NOT(pHAS_INDEX)) \
			( \
				vNumberOfElementsPerNode = ((pDesiredByteSizeOfNode - \
								(((volatile void const *)&(tInternalNode.gPrivate_buffer)) + 1 - \
										((volatile void const *)&tInternalNode)) - \
								CRXM__IFELSE2(pIS_TO_USE_RINGS, \
										sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
										pELEMENT_TYPE)), 0) - \
								CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_POINTER - \
								sizeof(pTREE_TYPE_NAME ## _Private_Node *)) / \
						(sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE)) + \
								sizeof(pTREE_TYPE_NAME ## _Private_Node *))); \
			) \
			( \
				CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
				( \
					vNumberOfElementsPerNode = (pDesiredByteSizeOfNode - \
									(((volatile void const *)&(tInternalNode.gPrivate_buffer)) + 1 - \
											((volatile void const *)&tInternalNode)) - \
									CRXM__IFELSE2(pIS_TO_USE_RINGS, sizeof(pINDEX_TYPE), 0) - \
									CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_POINTER - \
									sizeof(pTREE_TYPE_NAME ## _Private_Node *) - \
									CRXM__IFELSE2(pIS_PERSISTANT, \
											CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_POINTER, \
											CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_GENERAL_ALIGNMENT) - \
									CRXM__IFELSE2(pIS_TO_USE_RINGS, sizeof(CRXM__IFELSE2( \
											pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE)), \
											0)) / \
							(sizeof(pINDEX_TYPE) + \
									sizeof(pTREE_TYPE_NAME ## _Private_Node *) + \
									sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
											pELEMENT_TYPE))); \
				) \
				( \
					vNumberOfElementsPerNode = ((pDesiredByteSizeOfNode - \
									(((volatile void const *)&(tInternalNode.gPrivate_buffer)) + 1 - \
											((volatile void const *)&tInternalNode)) - \
									CRXM__IFELSE2(pIS_TO_USE_RINGS, sizeof(pINDEX_TYPE), 0) - \
									CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_POINTER - \
									sizeof(pTREE_TYPE_NAME ## _Private_Node *)) / \
							(sizeof(pINDEX_TYPE) + sizeof(pTREE_TYPE_NAME ## _Private_Node *))); \
				) \
			) \
		} \
		else \
		{ \
			pTREE_TYPE_NAME ## _Private_LeafNode tLeafNode /*= ?*/; \
	\
			CRXM__IFELSE(CRXM__OR(CRXM__NOT(pHAS_INDEX), \
					CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY))) \
			( \
				vNumberOfElementsPerNode = ((pDesiredByteSizeOfNode - \
								(((volatile void const *)&(tLeafNode.gPrivate_buffer)) + 1 - \
										((volatile void const *)&tLeafNode)) - \
								CRXM__IFELSE2(pIS_TO_USE_RINGS, \
										sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
										pELEMENT_TYPE)), 0)) / \
						sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE))); \
			) \
			( \
				vNumberOfElementsPerNode = ((pDesiredByteSizeOfNode - \
								(((volatile void const *)&(tLeafNode.gPrivate_buffer)) + 1 - \
										((volatile void const *)&tLeafNode)) - \
								CRXM__IFELSE2(pIS_TO_USE_RINGS, sizeof(pINDEX_TYPE), 0) - \
								CRXM__IFELSE2(pIS_PERSISTANT, \
										CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_POINTER, \
										CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_GENERAL_ALIGNMENT) - \
								CRXM__IFELSE2(pIS_TO_USE_RINGS, sizeof(CRXM__IFELSE2( \
										pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE)), 0)) / \
						(sizeof(pINDEX_TYPE) + \
								sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
										pELEMENT_TYPE)))); \
			) \
		} \
	\
		if(vNumberOfElementsPerNode < 3.0) \
			{pMEMBER_FUNCTIONS_PREFIX ## construct(pThis, 2);} \
		else \
		{ \
			CRXM__IFELSE(pIS_TO_USE_RINGS) \
			( \
				size_t tCountOfMidKeyInNode = 2; \
	\
				while(((tCountOfMidKeyInNode * 2) - 1) <= vNumberOfElementsPerNode) \
					{tCountOfMidKeyInNode = (tCountOfMidKeyInNode << 1);} \
	\
				if((tCountOfMidKeyInNode > 2) && \
						((tCountOfMidKeyInNode * 2 - 1) != vNumberOfElementsPerNode)) \
					{tCountOfMidKeyInNode = tCountOfMidKeyInNode - 1;} \
	\
				pMEMBER_FUNCTIONS_PREFIX ## construct(pThis, tCountOfMidKeyInNode); \
			) \
			( \
				pMEMBER_FUNCTIONS_PREFIX ## construct(pThis, \
						(((uint32_t)vNumberOfElementsPerNode + 1) >> 1)); \
			) \
		} \
	} \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## construct4(pTREE_TYPE_NAME * pThis, \
			size_t pDesiredByteSizeOfHotRegionInNode) \
	{ \
		double vNumberOfElementsPerNode = 0; \
	\
		if(CRXM__IFELSE2(CRXM__OR(CRXM__NOT(pHAS_INDEX), \
				CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)), \
				CRXM__IFELSE2(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, false, true), \
				sizeof(pINDEX_TYPE) >= (sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
						pELEMENT_TYPE)) + CRXM__IFELSE2(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, \
						2 * sizeof(pTREE_TYPE_NAME ## _Private_Node *), 0)))) \
		{ \
			pTREE_TYPE_NAME ## _Private_InternalNode tInternalNode /*= ?*/; \
			pTREE_TYPE_NAME ## _Private_LeafNode tLeafNode /*= ?*/; \
	\
			CRXM__IFELSE(CRXM__NOT(pHAS_INDEX)) \
			( \
				vNumberOfElementsPerNode = ((pDesiredByteSizeOfHotRegionInNode - \
								(((volatile void const *)&(tInternalNode.gPrivate_buffer)) + 1 - \
										((volatile void const *)&tInternalNode)) - \
								CRXM__IFELSE2(pIS_TO_USE_RINGS, \
										sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
										pELEMENT_TYPE)), 0)) / \
						sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE))); \
			) \
			( \
				vNumberOfElementsPerNode = ((pDesiredByteSizeOfHotRegionInNode - \
								(((volatile void const *)&(tInternalNode.gPrivate_buffer)) + 1 - \
										((volatile void const *)&tInternalNode)) - \
								CRXM__IFELSE2(pIS_TO_USE_RINGS, sizeof(pINDEX_TYPE), 0)) / \
						sizeof(pINDEX_TYPE)); \
			) \
	\
			if(vNumberOfElementsPerNode > 0) \
			{ \
				double tNumberOfElementsPerNode = 0; \
	\
				CRXM__IFELSE(CRXM__OR(CRXM__NOT(pHAS_INDEX), \
						CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY))) \
				( \
					tNumberOfElementsPerNode = ((pDesiredByteSizeOfHotRegionInNode - \
									(((volatile void const *)&(tLeafNode.gPrivate_buffer)) + 1 - \
											((volatile void const *)&tLeafNode)) - \
									CRXM__IFELSE2(pIS_TO_USE_RINGS, \
											sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
											pELEMENT_TYPE)), 0)) / \
							sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE))); \
				) \
				( \
					tNumberOfElementsPerNode = ((pDesiredByteSizeOfHotRegionInNode -  \
									(((volatile void const *)&(tLeafNode.gPrivate_buffer)) + 1 - \
											((volatile void const *)&tLeafNode)) - \
									CRXM__IFELSE2(pIS_TO_USE_RINGS, sizeof(pINDEX_TYPE), 0)) / \
							sizeof(pINDEX_TYPE)); \
				) \
	\
				if(vNumberOfElementsPerNode > tNumberOfElementsPerNode) \
					{vNumberOfElementsPerNode = tNumberOfElementsPerNode;} \
			} \
		} \
		else \
		{ \
			pTREE_TYPE_NAME ## _Private_LeafNode tLeafNode /*= ?*/; \
	\
			CRXM__IFELSE(CRXM__OR(CRXM__NOT(pHAS_INDEX), \
					CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY))) \
			( \
				vNumberOfElementsPerNode = ((pDesiredByteSizeOfHotRegionInNode - \
								(((volatile void const *)&(tLeafNode.gPrivate_buffer)) + 1 - \
										((volatile void const *)&tLeafNode)) - \
								CRXM__IFELSE2(pIS_TO_USE_RINGS, \
										sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
										pELEMENT_TYPE)), 0)) / \
						sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE))); \
			) \
			( \
				vNumberOfElementsPerNode = ((pDesiredByteSizeOfHotRegionInNode - \
								(((volatile void const *)&(tLeafNode.gPrivate_buffer)) + 1 - \
										((volatile void const *)&tLeafNode)) - \
								CRXM__IFELSE2(pIS_TO_USE_RINGS, sizeof(pINDEX_TYPE), 0)) / \
						sizeof(pINDEX_TYPE)); \
			) \
		} \
	\
		if(vNumberOfElementsPerNode < 3.0) \
		{ \
			pMEMBER_FUNCTIONS_PREFIX ## construct(pThis, 2); \
		} \
		else \
		{ \
			pMEMBER_FUNCTIONS_PREFIX ## construct(pThis, \
					(((uint32_t)vNumberOfElementsPerNode) >> 1)); \
		} \
	} \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## copyConstruct(pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME const * CRX_NOT_NULL pTree) \
	{ \
		CRXM__IFELSE2(CRXM__NOT(pIS_COPYABLE), abort();, \
	\
		uint32_t vTypeOfRootNode = ((pTree->gPrivate_node__root != NULL) ? \
				pTree->gPrivate_node__root->gPrivate_type : 0); \
	\
		pThis->gPrivate_node__root = (pTREE_TYPE_NAME ## _Private_Node *)calloc(1, \
				((vTypeOfRootNode != 0) ? pTree->gPrivate_internalNode_byteLength : \
				pTree->gPrivate_leafNode_byteLength)); \
		pThis->gPrivate_internalNode_byteOffsetToChildNodes = \
				pTree->gPrivate_internalNode_byteOffsetToChildNodes; \
	\
		CRXM__IFELSE(pHAS_INDEX) \
		( \
			CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
			pThis->gPrivate_internalNode_byteOffsetToElementData = \
					pTree->gPrivate_internalNode_byteOffsetToElementData;, ) \
			CRXM__IFELSE2(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY), \
			pThis->gPrivate_leafNode_byteOffsetToElementData = \
					pTree->gPrivate_leafNode_byteOffsetToElementData;, ) \
		)() \
	\
		pThis->gPrivate_internalNode_byteLength = pTree->gPrivate_internalNode_byteLength; \
		pThis->gPrivate_leafNode_byteLength = pTree->gPrivate_leafNode_byteLength; \
		pThis->gPrviate_countOfMidElementInNode = pTree->gPrviate_countOfMidElementInNode; \
		pThis->gPrivate_numberOfElements = 0; \
		pThis->gPrivate_numberOfNodes = 0; \
	\
		if(pThis->gPrivate_node__root != NULL) \
		{ \
			pThis->gPrivate_node__root->gPrivate_type = ((vTypeOfRootNode == 0) ? 0 : 1); \
			pThis->gPrivate_node__root->gPrivate_numberOfEntries = \
					pTree->gPrivate_node__root->gPrivate_numberOfEntries; \
			CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
			pThis->gPrivate_node__root->gPrivate_node__parent = NULL;, ) \
			CRXM__IFELSE2(pIS_TO_USE_RINGS, \
			pThis->gPrivate_node__root->gPrivate_startIndex = 0;, ) \
	\
			CRXM__IFELSE(pIS_ELEMENT_DATA_IN_LEAVES_ONLY) \
			( \
				if(vTypeOfRootNode == 0) \
				{ \
					((pTREE_TYPE_NAME ## _Private_LeafNode *)(pThis->gPrivate_node__root))-> \
							gPrivate_leafNode__prev = NULL; \
					((pTREE_TYPE_NAME ## _Private_LeafNode *)(pThis->gPrivate_node__root))-> \
							gPrivate_leafNode__next = NULL; \
				} \
			)() \
	\
			if(CRXM__IFELSE2(CRXM__AND(pIS_PERSISTANT, CRXM__AND(CRXM__NOT( \
							pHAS_INDEX), pIS_ELEMENT_DATA_IN_LEAVES_ONLY)), \
					pMEMBER_FUNCTIONS_PREFIX ## private_copyConstruct__finishBuildingNode( \
							pThis, pTree, pThis->gPrivate_node__root, \
							pTree->gPrivate_node__root, NULL), \
					pMEMBER_FUNCTIONS_PREFIX ## private_copyConstruct__finishBuildingNode( \
							pThis, pTree, pThis->gPrivate_node__root, \
							pTree->gPrivate_node__root))) \
			{ \
				pThis->gPrivate_numberOfElements = pTree->gPrivate_numberOfElements; \
				pThis->gPrivate_numberOfNodes = pTree->gPrivate_numberOfNodes; \
			} \
			else \
			{ \
				if(vTypeOfRootNode != 0) \
				{ \
					free(pThis->gPrivate_node__root); \
					pThis->gPrivate_node__root = (pTREE_TYPE_NAME ## _Private_Node *)calloc(1, \
							pThis->gPrivate_leafNode_byteLength); \
				} \
	\
				if(pThis->gPrivate_node__root != NULL) \
				{ \
					pThis->gPrivate_node__root->gPrivate_type = 0; \
					pThis->gPrivate_node__root->gPrivate_numberOfEntries = 0; \
					CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
					pThis->gPrivate_node__root->gPrivate_node__parent = NULL;, ) \
					CRXM__IFELSE2(pIS_TO_USE_RINGS, \
					pThis->gPrivate_node__root->gPrivate_startIndex = 0;, ) \
	\
					CRXM__IFELSE(pIS_ELEMENT_DATA_IN_LEAVES_ONLY) \
					( \
						((pTREE_TYPE_NAME ## _Private_LeafNode *)(pThis->gPrivate_node__root))-> \
								gPrivate_leafNode__prev = NULL; \
						((pTREE_TYPE_NAME ## _Private_LeafNode *)(pThis->gPrivate_node__root))-> \
								gPrivate_leafNode__next = NULL; \
					)() \
	\
					pThis->gPrivate_numberOfNodes = 1; \
				} \
			} \
		} \
	)} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	CRXM__IFELSE2(CRXM__AND(pIS_PERSISTANT, CRXM__AND(CRXM__NOT(pHAS_INDEX), \
			CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_TO_USE_DELEGATION))), \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_copyConstruct__finishBuildingNode( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME const * CRX_NOT_NULL pTree, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__target, \
			pTREE_TYPE_NAME ## _Private_Node const * CRX_NOT_NULL pNode__source, \
			pELEMENT_TYPE * * pElement__lastSeenNonFirstChildInTarget), \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_copyConstruct__finishBuildingNode( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME const * CRX_NOT_NULL pTree, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__target, \
			pTREE_TYPE_NAME ## _Private_Node const * CRX_NOT_NULL pNode__source)) \
	{ \
		bool vIsNoError = true; \
	\
		if(pNode__source->gPrivate_type == 1) \
		{ \
			/*WE ALWAYS NEED TO CLEANUP THE ELEMENTS IF THEY EXIST IN THE INTERNAL NODES AND THERE \
					IS AN ERROR, BUT THERE IS NO DANGER OF FAILING WHILE CREATING THE ELEMENTS \
					WHEN THE TREE IS NOT PERSISTANT. tIndexInElements IS ONLY REQUIRED WHEN THE \
					DANGER EXISTS AND WE NEED TO DO THE CLEANUP AFTER AN ERROR. REMEMBER THAT WHEN \
					THE TREE IS PERSISTANT AND DATA IS IN THE LEAVES ONLY, IF ELEMENTS ENTRIES \
					EXIST IN THE INTERNAL NODES, WE DO NOT NEED TO CLEAN THEM UP. THE INTERNAL \
					NODES WOULD BE HOLDING COPIES OF POINTERS TO ELEMENTS THEN, AND HENCE CLEANING \
					IS INSTEAD LEFT FOR THE LEAVES TO DO.*/ \
			CRXM__IFELSE2(CRXM__AND(CRXM__OR(CRXM__NOT(pHAS_INDEX), \
							CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)), \
					CRXM__AND(pIS_PERSISTANT, CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY))), \
			size_t tIndexInElements = 0;, ) \
			bool tAreChildNodesInternal = ((*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode__source, \
					pTree, 0)))->gPrivate_type == 1); \
	\
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				CRX__C__TREE__PRIVATE__COPY(pIS_TO_USE_RINGS, \
						pINDEX_TYPE, \
						pFUNC_INDEX_COPY_CONSTRUCTOR, \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__target, pThis, 0), \
						pNode__target, 0, \
						pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__source, pTree, 0), \
						pNode__source, 0, pNode__source->gPrivate_numberOfEntries) \
			)() \
	\
			CRXM__IFELSE(CRXM__OR(CRXM__NOT(pHAS_INDEX), \
					CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY))) \
			( \
				CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
				( \
					CRX__C__TREE__PRIVATE__COPY(pIS_TO_USE_RINGS, \
							pELEMENT_TYPE, \
							pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
							2 * pThis->gPrviate_countOfMidElementInNode, \
							pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pNode__target, pThis, 0), \
							pNode__target, 0, \
							pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pNode__source, pTree, 0), \
							pNode__source, 0, pNode__source->gPrivate_numberOfEntries); \
				) \
				( \
					CRXM__IFELSE(CRXM__OR(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
							CRXM__NOT(pIS_TO_USE_DELEGATION))) \
					( \
						CRX_FOR(tIndexInElements = 0, \
								tIndexInElements < pNode__source->gPrivate_numberOfEntries, \
								tIndexInElements++) \
						{ \
							pELEMENT_TYPE * tElement = (pELEMENT_TYPE *)calloc(1, \
									sizeof(pELEMENT_TYPE)); \
	\
							if(tElement != NULL) \
							{ \
								CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
								( \
									pFUNC_ELEMENT_COPY_CONSTRUCTOR(tElement, \
											pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode__source, pTree, tIndexInElements)); \
								) \
								( \
									memcpy(tElement, \
											pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode__source, pTree, tIndexInElements), \
											sizeof(pELEMENT_TYPE)); \
								) \
	\
								*(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode__target, pThis, tIndexInElements)) = tElement; \
							} \
							else \
							{ \
								vIsNoError = false; \
	\
								break; \
							} \
						} \
						CRX_ENDFOR \
					) \
					( \
						/*THE FOLLOWING IS NOT REQUIRED. THE CODE CAN BE USEFUL FOR DEBUGGING IN THE
						FUTURE* / \
						CRX__C__TREE__PRIVATE__COPY(pIS_TO_USE_RINGS, \
								pELEMENT_TYPE *, \
								CRXM__FALSE, \
								2 * pThis->gPrviate_countOfMidElementInNode, \
								pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode__target, pThis, 0), \
								pNode__target, 0, \
								pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode__source, pTree, 0), \
								pNode__source, 0, pNode__source->gPrivate_numberOfEntries); \
						*/ \
					) \
				) \
			)() \
	\
			if(vIsNoError) \
			{ \
				CRX_FOR(size_t tI = 0, tI <= pNode__source->gPrivate_numberOfEntries, tI++) \
				{ \
					pTREE_TYPE_NAME ## _Private_Node * tNode /*= ?*/; \
	\
					if(tAreChildNodesInternal) \
					{ \
						tNode = (pTREE_TYPE_NAME ## _Private_Node *)calloc(1, \
								pThis->gPrivate_internalNode_byteLength); \
					} \
					else \
					{ \
						tNode = (pTREE_TYPE_NAME ## _Private_Node *)calloc(1, \
								pThis->gPrivate_leafNode_byteLength); \
	\
						if(tNode != NULL) \
						{ \
							CRXM__IFELSE(pIS_ELEMENT_DATA_IN_LEAVES_ONLY) \
							( \
								if(tI != 0) \
								{ \
									((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
											gPrivate_leafNode__prev = \
											((pTREE_TYPE_NAME ## _Private_LeafNode *) \
											(*(pINTERNAL__GET_NODE( \
											pTREE_TYPE_NAME, pNode__target, pThis, tI - 1)))); \
									((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
											gPrivate_leafNode__prev-> gPrivate_leafNode__next = \
											((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode); \
								} \
								else \
								{ \
									((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
											gPrivate_leafNode__prev = NULL; \
								} \
	\
								((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
										gPrivate_leafNode__next = NULL; \
							)() \
						} \
					} \
	\
					if(tNode != NULL) \
					{ \
						tNode->gPrivate_type = 1; \
						tNode->gPrivate_numberOfEntries = (*(pINTERNAL__GET_NODE( \
								pTREE_TYPE_NAME, pNode__source, pTree, \
								tI)))->gPrivate_numberOfEntries; \
						CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
						tNode->gPrivate_node__parent = pNode__target;, ) \
						CRXM__IFELSE2(pIS_TO_USE_RINGS, \
						tNode->gPrivate_startIndex = 0;, ) \
	\
						if(CRXM__IFELSE2(CRXM__AND(pIS_PERSISTANT, CRXM__AND(CRXM__NOT( \
										pHAS_INDEX), CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, \
										pIS_TO_USE_DELEGATION))), \
								pMEMBER_FUNCTIONS_PREFIX ## private_copyConstruct__finishBuildingNode( \
										pThis, pTree, tNode, *(pINTERNAL__GET_NODE( \
										pTREE_TYPE_NAME, pNode__source, pTree, tI)), \
										((tI == 0) ? pElement__lastSeenNonFirstChildInTarget : \
										pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
										pELEMENT_TYPE, pNode__target, pThis, tI - 1))), \
								pMEMBER_FUNCTIONS_PREFIX ## private_copyConstruct__finishBuildingNode( \
										pThis, pTree, tNode, *(pINTERNAL__GET_NODE( \
										pTREE_TYPE_NAME, pNode__source, pTree, tI))))) \
						{ \
							*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode__target, pThis, tI)) = \
									tNode; \
						} \
						else \
						{ \
							free(tNode); \
							tNode = NULL; \
						} \
					} \
	\
					if(tNode == NULL) \
					{ \
						vIsNoError = false; \
	\
						CRX_FOR(size_t tI2 = 0, tI2 < tI, tI2++) \
						{ \
							pMEMBER_FUNCTIONS_PREFIX ## private_deleteNode(pThis, \
									*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode__target, pThis, \
									tI2))); \
							/* *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode__target, pThis, tI2)) = \
									NULL;*/ \
						} \
						CRX_ENDFOR \
	\
						break; \
					} \
				} \
				CRX_ENDFOR \
			} \
	\
			if(!vIsNoError) \
			{ \
				CRXM__IFELSE(CRXM__OR(CRXM__NOT(pHAS_INDEX), \
						CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY))) \
				( \
					CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
					( \
						CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
						( \
							CRX_FOR(size_t tI = 0, \
									tI < pNode__target->gPrivate_numberOfEntries, tI++) \
							{ \
								pFUNC_ELEMENT_DESTRUCTOR(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
										pELEMENT_TYPE, pNode__target, pThis, tI)); \
							} \
							CRX_ENDFOR \
						)() \
					) \
					( \
						CRXM__IFELSE(CRXM__OR(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
								CRXM__NOT(pIS_TO_USE_DELEGATION))) \
						( \
							CRX_FOR(size_t tI = 0, tI < tIndexInElements, tI++) \
							{ \
								CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
								pFUNC_ELEMENT_DESTRUCTOR(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
										pELEMENT_TYPE, pNode__target, pThis, tI));, ) \
	\
								free(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode__target, pThis, tI)); \
								/* *(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode__target, pThis, tI)) = NULL;*/ \
							} \
							CRX_ENDFOR \
						)() \
					) \
				)() \
	\
				pNode__target->gPrivate_numberOfEntries = 0; \
			} \
		} \
		else \
		{ \
			CRXM__IFELSE(CRXM__AND(pHAS_INDEX, CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY))) \
			( \
				CRX__C__TREE__PRIVATE__COPY(pIS_TO_USE_RINGS, \
						pINDEX_TYPE, \
						pFUNC_INDEX_COPY_CONSTRUCTOR, \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode__target, pThis, 0), \
						pNode__target, 0, \
						pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode__source, pTree, 0), \
						pNode__source, 0, pNode__source->gPrivate_numberOfEntries) \
			)() \
	\
			CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
			( \
				CRX__C__TREE__PRIVATE__COPY(pIS_TO_USE_RINGS, \
						pELEMENT_TYPE, \
						pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode__target, pThis, 0), \
						pNode__target, 0, \
						pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode__source, pTree, 0), \
						pNode__source, 0, pNode__source->gPrivate_numberOfEntries); \
			) \
			( \
				CRX_FOR(size_t tI = 0, \
						tI < pNode__source->gPrivate_numberOfEntries, tI++) \
				{ \
					pELEMENT_TYPE * tElement = (pELEMENT_TYPE *)calloc(1, \
							sizeof(pELEMENT_TYPE)); \
	\
					if(tElement != NULL) \
					{ \
						CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
						( \
							pFUNC_ELEMENT_COPY_CONSTRUCTOR(tElement, pLEAF__GET_ELEMENT( \
									pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__source, pTree, \
									tI)); \
						) \
						( \
							memcpy(tElement, pLEAF__GET_ELEMENT( \
									pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__source, pTree, \
									tI), sizeof(pELEMENT_TYPE)); \
						) \
	\
						*(pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode__target, pThis, tI)) = tElement; \
	\
						CRXM__IFELSE(CRXM__AND(CRXM__NOT(pHAS_INDEX), \
								CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, \
								pIS_TO_USE_DELEGATION))) \
						( \
							if(tI == 0) \
							{ \
								if(pElement__lastSeenNonFirstChildInTarget != NULL) \
									{*pElement__lastSeenNonFirstChildInTarget = tElement;} \
							} \
						)() \
					} \
					else \
					{ \
						vIsNoError = false; \
	\
						CRX_FOR(size_t tI2 = 0, tI2 < tI, tI2++) \
						{ \
							CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
							pFUNC_ELEMENT_DESTRUCTOR(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
									pELEMENT_TYPE, pNode__target, pThis, tI2));, ) \
	\
							free(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__target, \
									pThis, tI2)); \
						} \
						CRX_ENDFOR \
	\
						break; \
					} \
				} \
				CRX_ENDFOR \
			) \
		} \
	\
		return vIsNoError; \
	}, ) \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## destruct(pTREE_TYPE_NAME * pThis) \
	{ \
		if(pThis->gPrivate_node__root != NULL) \
			{pMEMBER_FUNCTIONS_PREFIX ## private_deleteNode(pThis, pThis->gPrivate_node__root);} \
	} \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## free(pTREE_TYPE_NAME * pThis) \
		{free(pThis);} \
	\
	CRX__C__TYPE_BLUE_PRINT__DEFINE_GET_BLUE_PRINT( \
			pTREE_TYPE_NAME, pMEMBER_FUNCTIONS_PREFIX, \
			CRXM__TRUE, CRXM__TRUE, \
			pIS_COPYABLE, CRXM__TRUE, \
			CRXM__FALSE, CRXM__FALSE); \
	\
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_deleteNode( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode) \
	{ \
		if(pNode->gPrivate_type) \
		{ \
			CRX_FOR(size_t tI = 0, tI <= pNode->gPrivate_numberOfEntries, tI++) \
			{ \
				pMEMBER_FUNCTIONS_PREFIX ## private_deleteNode(pThis, \
						*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, tI))); \
			} \
			CRX_ENDFOR \
	\
			CRXM__IFELSE(CRXM__OR(CRXM__NOT(pHAS_INDEX), \
					CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY))) \
			( \
				CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
				( \
					CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
					( \
						CRX_FOR(size_t tI = 0, tI < pNode->gPrivate_numberOfEntries, tI++) \
						{ \
							pFUNC_ELEMENT_DESTRUCTOR(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
									pELEMENT_TYPE, pNode, pThis, tI)); \
						}  \
						CRX_ENDFOR \
					)() \
				) \
				( \
					CRXM__IFELSE(CRXM__OR(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
							CRXM__NOT(pIS_TO_USE_DELEGATION))) \
					( \
						CRX_FOR(size_t tI = 0, tI < pNode->gPrivate_numberOfEntries, tI++) \
						{ \
							CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
							pFUNC_ELEMENT_DESTRUCTOR(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
									pELEMENT_TYPE, pNode, pThis, tI));, ) \
	\
							free(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pNode, pThis, tI)); \
							/* *(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pNode, pThis, tI)) = NULL;*/ \
						} \
						CRX_ENDFOR \
					)() \
				) \
			)() \
		} \
		else \
		{ \
			CRXM__IFELSE(pFUNC_ELEMENT_DESTRUCTOR) \
			( \
				CRX_FOR(size_t tI = 0, tI < pNode->gPrivate_numberOfEntries, tI++) \
				{ \
					pFUNC_ELEMENT_DESTRUCTOR(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
							pNode, pThis, tI)); \
	\
					CRXM__IFELSE2(pIS_PERSISTANT, \
					free(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
							pNode, pThis, tI));, ) \
				}  \
				CRX_ENDFOR \
			) \
			( \
				CRXM__IFELSE(pIS_PERSISTANT) \
				( \
					CRX_FOR(size_t tI = 0, tI < pNode->gPrivate_numberOfEntries, tI++) \
					{ \
						free(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode, pThis, tI)); \
					}  \
					CRX_ENDFOR \
				)() \
			) \
		} \
	\
		free(pNode); \
	} \
	\
	CRXM__IFELSE2(pHAS_INDEX, \
	PRIVATE size_t pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node const * CRX_NOT_NULL pNode, \
			pINDEX_TYPE const * CRX_NOT_NULL pIndex__guide /*pKey*/, \
			int32_t * pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode), \
	PRIVATE size_t pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node const * CRX_NOT_NULL pNode, \
			pELEMENT_TYPE const * CRX_NOT_NULL pElement /*pKey*/, \
			int32_t * pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode)) \
	{ \
		CRX_SCOPE_META \
		if(pNode->gPrivate_numberOfEntries == 0) \
		{ \
			if(pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode != NULL) \
				{*pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 1;} \
	\
			return 0 /*-1*/; \
		} \
	\
		CRX_SCOPE \
		size_t vBeginingIndex = 0; \
		size_t vEndingIndex = pNode->gPrivate_numberOfEntries; \
	\
		if(pNode->gPrivate_type) \
		{ \
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				while(vBeginingIndex < vEndingIndex) \
				{ \
					size_t tMiddleIndex = (vBeginingIndex + vEndingIndex) >> 1; \
	\
					if(pCOMPARE_INDICES(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
							tMiddleIndex), pIndex__guide) < 0) \
						{vBeginingIndex = tMiddleIndex + 1;} \
					else \
						{vEndingIndex = tMiddleIndex;} \
				} \
			) \
			( \
				while(vBeginingIndex < vEndingIndex) \
				{ \
					size_t tMiddleIndex = (vBeginingIndex + vEndingIndex) >> 1; \
	\
					if(pCOMPARE_ELEMENTS(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
							pNode, pThis, tMiddleIndex), pElement) < 0) \
						{vBeginingIndex = tMiddleIndex + 1;} \
					else \
						{vEndingIndex = tMiddleIndex;} \
				} \
			) \
		} \
		else \
		{ \
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
				( \
					while(vBeginingIndex < vEndingIndex) \
					{ \
						size_t tMiddleIndex = (vBeginingIndex + vEndingIndex) >> 1; \
	\
						if(pCOMPARE_INDICES(pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
								tMiddleIndex), pIndex__guide) < 0) \
							{vBeginingIndex = tMiddleIndex + 1;} \
						else \
							{vEndingIndex = tMiddleIndex;} \
					} \
				) \
				( \
					unsigned char * tIndex__guide = ((unsigned char *)CRX__ALLOCA( \
							sizeof(pINDEX_TYPE))); \
	\
					while(vBeginingIndex < vEndingIndex) \
					{ \
						size_t tMiddleIndex = (vBeginingIndex + vEndingIndex) >> 1; \
	\
						pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
								tMiddleIndex)); \
	\
						if(pCOMPARE_INDICES(((pINDEX_TYPE *)tIndex__guide), pIndex__guide) < 0) \
							{vBeginingIndex = tMiddleIndex + 1;} \
						else \
							{vEndingIndex = tMiddleIndex;} \
					} \
				) \
			) \
			( \
				while(vBeginingIndex < vEndingIndex) \
				{ \
					size_t tMiddleIndex = (vBeginingIndex + vEndingIndex) >> 1; \
	\
					if(pCOMPARE_ELEMENTS(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
							pNode, pThis, tMiddleIndex), pElement) < 0) \
						{vBeginingIndex = tMiddleIndex + 1;} \
					else \
						{vEndingIndex = tMiddleIndex;} \
				} \
			) \
		} \
	\
		if(vBeginingIndex == pNode->gPrivate_numberOfEntries) \
		{ \
			if(pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode != NULL) \
				{*pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 1;} \
	\
			return pNode->gPrivate_numberOfEntries /*- 1*/; \
		} \
		else \
		{ \
			int32_t tResult /*= ?*/; \
	\
			if(pNode->gPrivate_type) \
			{ \
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					tResult = pCOMPARE_INDICES(pIndex__guide, pINTERNAL__GET_INDEX( \
							pTREE_TYPE_NAME, pNode, pThis, vBeginingIndex)); \
				) \
				( \
					tResult = pCOMPARE_ELEMENTS(pElement, pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
							pELEMENT_TYPE, pNode, pThis, vBeginingIndex)); \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
					( \
						tResult = pCOMPARE_INDICES(pIndex__guide, pLEAF__GET_INDEX( \
								pTREE_TYPE_NAME, pNode, pThis, vBeginingIndex)); \
					) \
					( \
						unsigned char * tIndex__guide = ((unsigned char *)CRX__ALLOCA( \
								sizeof(pINDEX_TYPE))); \
	\
						pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
								vBeginingIndex)); \
	\
						tResult = pCOMPARE_INDICES(pIndex__guide, ((pINDEX_TYPE *)tIndex__guide)); \
					) \
				) \
				( \
					tResult = pCOMPARE_ELEMENTS(pElement, pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
							pELEMENT_TYPE, pNode, pThis, vBeginingIndex)); \
				) \
			} \
	\
			if(pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode != NULL) \
				{*pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = tResult;} \
	\
			if(tResult < 0) \
				{return vBeginingIndex; /*--vBeginingIndex;*/} \
			else \
				{return (vBeginingIndex + 1);} \
	\
			/*return ((size_t)(vBeginingIndex + 1)) /*vBeginingIndex*/; \
		} \
		CRX_SCOPE_END \
	} \
	\
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_transferPushFromNodeToNode( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__target, \
			bool pIsToIncludeBegginingChildNode, size_t pStartingIndex) \
	{ \
		assert(pNode->gPrivate_type == pNode__target->gPrivate_type); \
	\
		if(pNode->gPrivate_type) \
		{ \
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				CRX__C__TREE__PRIVATE__TRANSFER(pIS_TO_USE_RINGS, pINDEX_TYPE, \
						pFUNC_INDEX_MOVE_CONSTRUCTOR, \
						pFUNC_INDEX_MOVE_DESTRUCTOR, \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__target, pThis, 0), \
						pNode__target, pNode__target->gPrivate_numberOfEntries, \
						pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 0), \
						pNode, pStartingIndex, \
						pNode->gPrivate_numberOfEntries - pStartingIndex); \
			) \
			( \
				CRX__C__TREE__PRIVATE__TRANSFER(pIS_TO_USE_RINGS, \
						CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__target, \
								pThis, 0), \
						pNode__target, pNode__target->gPrivate_numberOfEntries, \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
								pThis, 0), \
						pNode, pStartingIndex, \
						pNode->gPrivate_numberOfEntries - pStartingIndex); \
			) \
	\
			CRXM__IFELSE(CRXM__NOT(pIS_PREEMPTIVE)) \
			( \
				CRX_FOR(size_t tI = pStartingIndex + (pIsToIncludeBegginingChildNode ? 0 : 1), \
						tI <= pNode->gPrivate_numberOfEntries, tI++) \
				{ \
					(*pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, tI))-> \
							gPrivate_node__parent = pNode__target; \
				} \
				CRX_ENDFOR \
			)() \
	\
			CRX__C__TREE__PRIVATE__TRANSFER(pIS_TO_USE_RINGS, \
					pTREE_TYPE_NAME ## _Private_Node *, \
					CRXM__FALSE, \
					CRXM__FALSE, \
					2 * pThis->gPrviate_countOfMidElementInNode, \
					pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode__target, pThis, 0), \
					pNode__target, pNode__target->gPrivate_numberOfEntries + \
					(pIsToIncludeBegginingChildNode ? 0 : 1), \
					pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, 0), \
					pNode, pStartingIndex + (pIsToIncludeBegginingChildNode ? 0 : 1), \
					pNode->gPrivate_numberOfEntries - pStartingIndex + \
							(pIsToIncludeBegginingChildNode ? 1 : 0)); \
	\
			CRXM__IFELSE(CRXM__AND(pHAS_INDEX, CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY))) \
			( \
				CRX__C__TREE__PRIVATE__TRANSFER(pIS_TO_USE_RINGS, \
						CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__target, \
								pThis, 0), \
						pNode__target, pNode__target->gPrivate_numberOfEntries, \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
								pThis, 0), \
						pNode, pStartingIndex, \
						pNode->gPrivate_numberOfEntries - pStartingIndex); \
			)() \
		} \
		else \
		{ \
			CRXM__IFELSE(CRXM__AND(pHAS_INDEX, CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY))) \
			( \
				CRX__C__TREE__PRIVATE__TRANSFER(pIS_TO_USE_RINGS, pINDEX_TYPE, \
						pFUNC_INDEX_MOVE_CONSTRUCTOR, \
						pFUNC_INDEX_MOVE_DESTRUCTOR, \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode__target, pThis, 0), \
						pNode__target, pNode__target->gPrivate_numberOfEntries, \
						pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 0), \
						pNode, pStartingIndex, \
						pNode->gPrivate_numberOfEntries - pStartingIndex); \
			)() \
	\
			CRX__C__TREE__PRIVATE__TRANSFER(pIS_TO_USE_RINGS, \
					CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE), \
					CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
					CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
					2 * pThis->gPrviate_countOfMidElementInNode, \
					pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__target, pThis, 0), \
					pNode__target, pNode__target->gPrivate_numberOfEntries, \
					pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, 0), \
					pNode, pStartingIndex, \
					pNode->gPrivate_numberOfEntries - pStartingIndex); \
		} \
	} \
	\
	CRXM__IFELSE2(pHAS_INDEX, \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
			pTREE_TYPE_NAME * pThis, pINDEX_TYPE * CRX_NOT_NULL pIndex__guide, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__child, \
			pELEMENT_TYPE * pElement, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t pIndex, bool pIsToIncludeBegginingChildNode), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
			pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__child, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t pIndex, bool pIsToIncludeBegginingChildNode)) \
	{ \
		CRXM__IFELSE2(pIS_TO_USE_RINGS, \
		bool vIsToRotateRight = ((pNode->gPrivate_numberOfEntries >> 1) < pIndex);, ) \
	\
		if(pNode->gPrivate_type) \
		{ \
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				CRX__C__TREE__PRIVATE__INSERT_SPACE_AT(pIS_TO_USE_RINGS, \
						pINDEX_TYPE, \
						pFUNC_INDEX_MOVE_CONSTRUCTOR, \
						pFUNC_INDEX_MOVE_DESTRUCTOR, \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						CRXM__IFELSE2(pIS_TO_USE_RINGS, vIsToRotateRight, CRXM__FALSE), pNode, \
						pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 0), \
						pNode->gPrivate_numberOfEntries, pIndex, 1); \
			) \
			( \
				CRX__C__TREE__PRIVATE__INSERT_SPACE_AT(pIS_TO_USE_RINGS, \
						CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						CRXM__IFELSE2(pIS_TO_USE_RINGS, vIsToRotateRight, CRXM__FALSE), pNode, \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
								0), \
						pNode->gPrivate_numberOfEntries, pIndex, 1); \
			) \
	\
			CRX__C__TREE__PRIVATE__INSERT_SPACE_AT(pIS_TO_USE_RINGS, \
					pTREE_TYPE_NAME ## _Private_Node *, \
					CRXM__FALSE, CRXM__FALSE, \
					2 * pThis->gPrviate_countOfMidElementInNode, \
					CRXM__IFELSE2(pIS_TO_USE_RINGS, vIsToRotateRight, CRXM__FALSE), pNode, \
					pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, 0), \
					pNode->gPrivate_numberOfEntries + 1, \
					(pIsToIncludeBegginingChildNode ? pIndex : pIndex + 1), 1); \
	\
			CRXM__IFELSE(CRXM__AND(pHAS_INDEX, CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY))) \
			( \
				CRX__C__TREE__PRIVATE__INSERT_SPACE_AT(pIS_TO_USE_RINGS, \
						CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						CRXM__IFELSE2(pIS_TO_USE_RINGS, vIsToRotateRight, CRXM__FALSE), pNode, \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
								0), \
						pNode->gPrivate_numberOfEntries, pIndex, 1); \
			)() \
	\
			CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_INSERTION_OF_SPACE(pIS_TO_USE_RINGS, \
					2 * pThis->gPrviate_countOfMidElementInNode, \
					CRXM__IFELSE2(pIS_TO_USE_RINGS, vIsToRotateRight, CRXM__FALSE), \
					pNode, pIndex, 1); \
	\
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				CRXM__IFELSE(pFUNC_INDEX_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_INDEX_MOVE_CONSTRUCTOR( \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, pIndex), \
							pIndex__guide); \
				) \
				( \
					memmove(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
							pIndex), pIndex__guide, sizeof(pINDEX_TYPE)); \
				) \
	\
				CRXM__IFELSE2(pFUNC_INDEX_MOVE_DESTRUCTOR, \
				pFUNC_INDEX_MOVE_DESTRUCTOR(pIndex__guide);, ) \
			) \
			( \
				CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
				( \
					CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
					( \
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
								pELEMENT_TYPE, pNode, pThis, pIndex), pElement); \
					) \
					( \
						memmove(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode, pThis, pIndex), pElement, sizeof(pELEMENT_TYPE)); \
					) \
	\
					CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
					pFUNC_ELEMENT_MOVE_DESTRUCTOR(pElement);, ) \
				) \
				( \
					*(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
							pIndex)) = pElement; \
				) \
			) \
	\
			*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, (pIsToIncludeBegginingChildNode ? \
					pIndex : pIndex + 1))) = pNode__child; \
	\
			CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
			pNode__child->gPrivate_node__parent = pNode;, ) \
	\
			CRXM__IFELSE(CRXM__AND(pHAS_INDEX, CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY))) \
			( \
				CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
				( \
					CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
					( \
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
								pELEMENT_TYPE, pNode, pThis, pIndex), pElement); \
					) \
					( \
						memmove(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode, pThis, pIndex), pElement, sizeof(pELEMENT_TYPE)); \
					) \
	\
					CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
					pFUNC_ELEMENT_MOVE_DESTRUCTOR(pElement);, ) \
				) \
				( \
					*(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
							pIndex)) = pElement; \
				) \
			)() \
		} \
		else \
		{ \
			CRXM__IFELSE(CRXM__AND(pHAS_INDEX, CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY))) \
			( \
				CRX__C__TREE__PRIVATE__INSERT_SPACE_AT(pIS_TO_USE_RINGS, \
						pINDEX_TYPE, \
						pFUNC_INDEX_MOVE_CONSTRUCTOR, \
						pFUNC_INDEX_MOVE_DESTRUCTOR, \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						CRXM__IFELSE2(pIS_TO_USE_RINGS, vIsToRotateRight, CRXM__FALSE), pNode, \
						pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 0), \
						pNode->gPrivate_numberOfEntries, pIndex, 1); \
			)() \
	\
			CRX__C__TREE__PRIVATE__INSERT_SPACE_AT(pIS_TO_USE_RINGS, \
					CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE), \
					CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
					CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
					2 * pThis->gPrviate_countOfMidElementInNode, \
					CRXM__IFELSE2(pIS_TO_USE_RINGS, vIsToRotateRight, CRXM__FALSE), pNode, \
					pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, 0), \
					pNode->gPrivate_numberOfEntries, pIndex, 1); \
	\
			CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_INSERTION_OF_SPACE(pIS_TO_USE_RINGS, \
					2 * pThis->gPrviate_countOfMidElementInNode, \
					CRXM__IFELSE2(pIS_TO_USE_RINGS, vIsToRotateRight, CRXM__FALSE), \
					pNode, pIndex, 1); \
	\
			CRXM__IFELSE(CRXM__AND(pHAS_INDEX, CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY))) \
			( \
				CRXM__IFELSE(pFUNC_INDEX_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_INDEX_MOVE_CONSTRUCTOR( \
							pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, pIndex), \
							pIndex__guide); \
				) \
				( \
					memmove(pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, pIndex), \
							pIndex__guide, sizeof(pINDEX_TYPE)); \
				) \
	\
				CRXM__IFELSE2(pFUNC_INDEX_MOVE_DESTRUCTOR, \
				pFUNC_INDEX_MOVE_DESTRUCTOR(pIndex__guide);, ) \
			)() \
	\
			CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
			( \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
							pELEMENT_TYPE, pNode, pThis, pIndex), pElement); \
				) \
				( \
					memmove(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
							pIndex), pElement, sizeof(pELEMENT_TYPE)); \
				) \
	\
				CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR(pElement);, ) \
			) \
			( \
				*(pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
						pIndex)) = pElement; \
			) \
	\
		} \
	\
		(pNode->gPrivate_numberOfEntries)++; \
	} \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_removeFirstNEntriesFrom( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t pWidth) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_TO_USE_RINGS)) \
		( \
			if(pNode->gPrivate_type) \
			{ \
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					CRXM__IFELSE(CRXM__OR(pFUNC_INDEX_MOVE_CONSTRUCTOR, \
							pFUNC_INDEX_MOVE_DESTRUCTOR)) \
					( \
						CRXM__IFELSE(pFUNC_INDEX_MOVE_CONSTRUCTOR) \
						( \
							CRX_FOR(size_t tI = pWidth, \
									tI < pNode->gPrivate_numberOfEntries, tI++) \
							{ \
								pFUNC_INDEX_MOVE_CONSTRUCTOR(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
										pNode, pThis, tI - pWidth), \
										pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, tI)); \
	\
								CRXM__IFELSE2(pFUNC_INDEX_MOVE_DESTRUCTOR, \
								pFUNC_INDEX_MOVE_DESTRUCTOR(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
										pNode, pThis, tI));, ) \
							} \
							CRX_ENDFOR \
						) \
						( \
							CRX_FOR(size_t tI = pWidth, \
									tI < pNode->gPrivate_numberOfEntries, tI++) \
							{ \
								memmove(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
										pNode, pThis, tI - pWidth), \
										pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, tI), \
										sizeof(pINDEX_TYPE)); \
	\
								pFUNC_INDEX_MOVE_DESTRUCTOR(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
										pNode, pThis, tI)); \
							} \
							CRX_ENDFOR \
						) \
					) \
					( \
						memmove(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 0), \
								pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, pWidth), \
								(pNode->gPrivate_numberOfEntries - pWidth) * \
										sizeof(pINDEX_TYPE)); \
					) \
				) \
				( \
					CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
					( \
						CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR)) \
						( \
							CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
							( \
								CRX_FOR(size_t tI = pWidth, \
										tI < pNode->gPrivate_numberOfEntries, tI++) \
								{ \
									pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pINTERNAL__GET_ELEMENT( \
													pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
													tI - pWidth), \
											pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
													pNode, pThis, tI)); \
	\
									CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
									pFUNC_ELEMENT_MOVE_DESTRUCTOR(pINTERNAL__GET_ELEMENT( \
											pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, tI));, ) \
								} \
								CRX_ENDFOR \
							) \
							( \
								CRX_FOR(size_t tI = pWidth, \
										tI < pNode->gPrivate_numberOfEntries, tI++) \
								{ \
									memmove(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, pNode, pThis, tI - pWidth), \
											pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, pNode, pThis, tI), \
											sizeof(pELEMENT_TYPE)); \
	\
									pFUNC_ELEMENT_MOVE_DESTRUCTOR(pINTERNAL__GET_ELEMENT( \
											pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, tI)); \
								} \
								CRX_ENDFOR \
							) \
						) \
						( \
							memmove(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode, pThis, 0), \
									pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode, pThis, pWidth), \
									(pNode->gPrivate_numberOfEntries - pWidth) * \
											sizeof(pELEMENT_TYPE)); \
						) \
					) \
					( \
						memmove(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode, pThis, 0), \
								pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode, pThis, pWidth), \
								(pNode->gPrivate_numberOfEntries - pWidth) * \
										sizeof(pELEMENT_TYPE *)); \
					) \
				) \
	\
				memmove(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, 0), \
						pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, pWidth), \
						(pNode->gPrivate_numberOfEntries + 1 - pWidth) * \
						sizeof(pTREE_TYPE_NAME ## _Private_Node *)); \
	\
				CRXM__IFELSE(CRXM__AND(pHAS_INDEX, CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY))) \
				( \
					CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
					( \
						CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR)) \
						( \
							CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
							( \
								CRX_FOR(size_t tI = pWidth, \
										tI < pNode->gPrivate_numberOfEntries, tI++) \
								{ \
									pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pINTERNAL__GET_ELEMENT( \
													pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
													tI - pWidth), \
											pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
													pNode, pThis, tI)); \
	\
									CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
									pFUNC_ELEMENT_MOVE_DESTRUCTOR(pINTERNAL__GET_ELEMENT( \
											pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, tI));, ) \
								} \
								CRX_ENDFOR \
							) \
							( \
								CRX_FOR(size_t tI = pWidth, \
										tI < pNode->gPrivate_numberOfEntries, tI++) \
								{ \
									memmove(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, pNode, pThis, tI - pWidth), \
											pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, pNode, pThis, tI), \
											sizeof(pELEMENT_TYPE)); \
	\
									pFUNC_ELEMENT_MOVE_DESTRUCTOR(pINTERNAL__GET_ELEMENT( \
											pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, tI)); \
								} \
								CRX_ENDFOR \
							) \
						) \
						( \
							memmove(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode, pThis, 0), \
									pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode, pThis, pWidth), \
									(pNode->gPrivate_numberOfEntries - pWidth) * \
											sizeof(pELEMENT_TYPE)); \
						) \
					) \
					( \
						memmove(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode, pThis, 0), \
								pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode, pThis, pWidth), \
								(pNode->gPrivate_numberOfEntries - pWidth) * \
										sizeof(pELEMENT_TYPE *)); \
					) \
				)() \
			} \
			else \
			{ \
				CRXM__IFELSE(CRXM__AND(pHAS_INDEX, CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY))) \
				( \
					CRXM__IFELSE(CRXM__OR(pFUNC_INDEX_MOVE_CONSTRUCTOR, \
							pFUNC_INDEX_MOVE_DESTRUCTOR)) \
					( \
						CRXM__IFELSE(pFUNC_INDEX_MOVE_CONSTRUCTOR) \
						( \
							CRX_FOR(size_t tI = pWidth, \
									tI < pNode->gPrivate_numberOfEntries, tI++) \
							{ \
								pFUNC_INDEX_MOVE_CONSTRUCTOR(pLEAF__GET_INDEX(pTREE_TYPE_NAME, \
										pNode, pThis, tI - pWidth), \
										pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, tI)); \
	\
								CRXM__IFELSE2(pFUNC_INDEX_MOVE_DESTRUCTOR, \
								pFUNC_INDEX_MOVE_DESTRUCTOR(pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, \
										pThis, tI));, ) \
							} \
							CRX_ENDFOR \
						) \
						( \
							CRX_FOR(size_t tI = pWidth, \
									tI < pNode->gPrivate_numberOfEntries, tI++) \
							{ \
								memmove(pLEAF__GET_INDEX(pTREE_TYPE_NAME, \
										pNode, pThis, tI - pWidth), \
										pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, tI), \
										sizeof(pINDEX_TYPE)); \
	\
								pFUNC_INDEX_MOVE_DESTRUCTOR(pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, \
										pThis, tI)); \
							} \
							CRX_ENDFOR \
						) \
					) \
					( \
						memmove(pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 0), \
								pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, pWidth), \
								(pNode->gPrivate_numberOfEntries - pWidth) * sizeof(pINDEX_TYPE)); \
					) \
				)() \
	\
				CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
				( \
					CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_MOVE_CONSTRUCTOR, \
							pFUNC_ELEMENT_MOVE_DESTRUCTOR)) \
					( \
						CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
						( \
							CRX_FOR(size_t tI = pWidth, \
									tI < pNode->gPrivate_numberOfEntries, tI++) \
							{ \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pLEAF__GET_ELEMENT( \
												pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
												tI - pWidth), \
										pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
												pNode, pThis, tI)); \
	\
								CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR(pLEAF__GET_ELEMENT( \
										pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, tI));, ) \
							} \
							CRX_ENDFOR \
						) \
						( \
							CRX_FOR(size_t tI = pWidth, \
									tI < pNode->gPrivate_numberOfEntries, tI++) \
							{ \
								memmove(pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
												pNode, pThis, tI - pWidth), \
										pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
												pNode, pThis, tI), \
										sizeof(pELEMENT_TYPE)); \
	\
								pFUNC_ELEMENT_MOVE_DESTRUCTOR(pLEAF__GET_ELEMENT( \
										pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, tI)); \
							} \
							CRX_ENDFOR \
						) \
					) \
					( \
						memmove(pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
										pThis, 0), \
								pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
										pThis, pWidth), \
								(pNode->gPrivate_numberOfEntries - pWidth) * \
										sizeof(pELEMENT_TYPE)); \
					) \
				) \
				( \
					memmove(pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
									pThis, 0), \
							pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
									pThis, pWidth), \
							(pNode->gPrivate_numberOfEntries - pWidth) * \
									sizeof(pELEMENT_TYPE *)); \
				) \
			} \
		) \
		( \
			pNode->gPrivate_startIndex = ((pNode->gPrivate_startIndex + pWidth) & \
					((pThis->gPrviate_countOfMidElementInNode * 2) - 1)); \
		) \
	} \
	\
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_rotateRight(pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, size_t pIndexOfNodeInParent, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__parent, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__rightSibling) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			if(pNode->gPrivate_type) \
			{ \
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, pThis, \
									pIndexOfNodeInParent), \
							*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
									pNode->gPrivate_numberOfEntries)), \
							pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__parent, \
									pThis, pIndexOfNodeInParent), \
							pNode__rightSibling, 0, true); \
	\
					CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT(sizeof(pINDEX_TYPE), \
							pFUNC_INDEX_MOVE_CONSTRUCTOR, \
							pFUNC_INDEX_MOVE_DESTRUCTOR, \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, \
									pThis, pIndexOfNodeInParent), \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
									pNode->gPrivate_numberOfEntries - 1)); \
				) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
							pThis, \
							*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
									pNode->gPrivate_numberOfEntries)), \
							pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__parent, \
									pThis, pIndexOfNodeInParent), \
							pNode__rightSibling, 0, true); \
				) \
	\
				CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
						sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE)), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode__parent, pThis, pIndexOfNodeInParent), \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode, pThis, pNode->gPrivate_numberOfEntries - 1)); \
			} \
			else \
			{ \
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
					( \
						pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
								pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, pThis, \
										pIndexOfNodeInParent), \
								NULL, \
								pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode__parent, pThis, pIndexOfNodeInParent), \
								pNode__rightSibling, 0, true); \
	\
						CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT(sizeof(pINDEX_TYPE), \
								pFUNC_INDEX_MOVE_CONSTRUCTOR, \
								pFUNC_INDEX_MOVE_DESTRUCTOR, \
								pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, pThis, \
										pIndexOfNodeInParent), \
								pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
										pNode->gPrivate_numberOfEntries - 1)); \
					) \
					( \
						unsigned char * tIndex__guide = ((unsigned char *)CRX__ALLOCA( \
								sizeof(pINDEX_TYPE))); \
	\
						pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
								pThis, pNode->gPrivate_numberOfEntries - 1)); \
	\
						pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
								pThis, \
								NULL, \
								NULL, \
								pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode__parent, pThis, pIndexOfNodeInParent), \
								pNode__rightSibling, 0, true); \
	\
						memcpy(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, \
										pThis, pIndexOfNodeInParent), \
								((pINDEX_TYPE *)tIndex__guide), \
								sizeof(pINDEX_TYPE)); \
					) \
				) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
							pThis, \
							NULL, \
							pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__parent, \
									pThis, pIndexOfNodeInParent), \
							pNode__rightSibling, 0, true); \
				) \
	\
				CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
						sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE)), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode__parent, pThis, pIndexOfNodeInParent), \
						pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode, pThis, pNode->gPrivate_numberOfEntries - 1)); \
			} \
		) \
		( \
			if(pNode->gPrivate_type) \
			{ \
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, pThis, \
									pIndexOfNodeInParent), \
							*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
									pNode->gPrivate_numberOfEntries)), \
							NULL, \
							pNode__rightSibling, 0, true); \
	\
					CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT(sizeof(pINDEX_TYPE), \
							pFUNC_INDEX_MOVE_CONSTRUCTOR, \
							pFUNC_INDEX_MOVE_DESTRUCTOR, \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, \
									pThis, pIndexOfNodeInParent), \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
									pNode->gPrivate_numberOfEntries - 1)); \
				) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
							pThis, \
							*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
									pNode->gPrivate_numberOfEntries)), \
							pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__parent, \
									pThis, pIndexOfNodeInParent), \
							pNode__rightSibling, 0, true); \
	\
					CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
							sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE)), \
							CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
									pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
							CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
									pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
							pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pNode__parent, pThis, pIndexOfNodeInParent), \
							pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pNode, pThis, pNode->gPrivate_numberOfEntries - 1)); \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
					( \
						pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
								pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
										pNode->gPrivate_numberOfEntries - 1), \
								NULL, \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
										pNode->gPrivate_numberOfEntries - 1), \
								pNode__rightSibling, 0, true); \
	\
						memcpy(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, pThis, \
										pIndexOfNodeInParent), \
								pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode__rightSibling, pThis, 0), \
								sizeof(pINDEX_TYPE)); \
					) \
					( \
						unsigned char * tIndex__guide = ((unsigned char *)CRX__ALLOCA( \
								sizeof(pINDEX_TYPE))); \
	\
						pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
								pNode->gPrivate_numberOfEntries - 1)); \
	\
						pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
								pThis, \
								NULL, \
								NULL, \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
										pNode->gPrivate_numberOfEntries - 1), \
								pNode__rightSibling, 0, true); \
	\
						memcpy(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, pThis, \
										pIndexOfNodeInParent), \
								((pINDEX_TYPE *)tIndex__guide), \
								sizeof(pINDEX_TYPE)); \
					) \
				) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
							pThis, \
							NULL, \
							pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
									pNode->gPrivate_numberOfEntries - 1), \
							pNode__rightSibling, 0, true); \
	\
					CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_DESTRUCTOR, CRXM__OR( \
							CRXM__NOT(pIS_PERSISTANT), CRXM__NOT(pIS_TO_USE_DELEGATION))), \
					pFUNC_ELEMENT_DESTRUCTOR(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
							pELEMENT_TYPE, pNode__parent, pThis, pIndexOfNodeInParent));, ) \
	\
					CRXM__IFELSE(CRXM__AND(pIS_PERSISTANT, pIS_TO_USE_DELEGATION)) \
					( \
						*(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode__parent, pThis, pIndexOfNodeInParent)) = \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode__rightSibling, pThis, 0); \
					) \
					( \
						CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
						( \
							pFUNC_ELEMENT_COPY_CONSTRUCTOR( \
									pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode__parent, pThis, pIndexOfNodeInParent), \
									pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode__rightSibling, pThis, 0)); \
						) \
						( \
							memcpy(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode__parent, pThis, pIndexOfNodeInParent), \
									pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode__rightSibling, pThis, 0), \
									sizeof(pELEMENT_TYPE)); \
						) \
					) \
				) \
			} \
		) \
	\
		(pNode->gPrivate_numberOfEntries)--; \
	} \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_rotateLeft(pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, size_t pIndexOfNodeInParent, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__parent, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__leftSibling) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			if(pNode->gPrivate_type) \
			{ \
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, pThis, \
									pIndexOfNodeInParent - 1), \
							*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
									0)), \
							pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__parent, \
									pThis, pIndexOfNodeInParent - 1), \
							pNode__leftSibling, \
							pNode__leftSibling->gPrivate_numberOfEntries, false); \
	\
					CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT(sizeof(pINDEX_TYPE), \
							pFUNC_INDEX_MOVE_CONSTRUCTOR, \
							pFUNC_INDEX_MOVE_DESTRUCTOR, \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, \
									pThis, pIndexOfNodeInParent - 1), \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
									0)); \
				) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
							pThis, \
							*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, 0)), \
							pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__parent, \
									pThis, pIndexOfNodeInParent - 1), \
							pNode__leftSibling, \
							pNode__leftSibling->gPrivate_numberOfEntries, false); \
				) \
	\
				CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
						sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE)), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode__parent, pThis, pIndexOfNodeInParent - 1), \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode, pThis, 0)); \
			} \
			else \
			{ \
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
					( \
						pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
								pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, pThis, \
										pIndexOfNodeInParent - 1), \
								NULL, \
								pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode__parent, pThis, pIndexOfNodeInParent - 1), \
								pNode__leftSibling, \
								pNode__leftSibling->gPrivate_numberOfEntries, false); \
	\
						CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT(sizeof(pINDEX_TYPE), \
								pFUNC_INDEX_MOVE_CONSTRUCTOR, \
								pFUNC_INDEX_MOVE_DESTRUCTOR, \
								pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, pThis, \
										pIndexOfNodeInParent - 1), \
								pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 0)); \
					) \
					( \
						unsigned char * tIndex__guide = ((unsigned char *)CRX__ALLOCA( \
								sizeof(pINDEX_TYPE))); \
	\
						pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
								pThis, 0)); \
	\
						pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
								pThis, \
								NULL, \
								NULL, \
								pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
										pNode__parent, pThis, pIndexOfNodeInParent - 1), \
								pNode__leftSibling, \
								pNode__leftSibling->gPrivate_numberOfEntries, false); \
	\
						memcpy(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, \
										pThis, pIndexOfNodeInParent - 1), \
								((pINDEX_TYPE *)tIndex__guide), \
								sizeof(pINDEX_TYPE)); \
					) \
				) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
							pThis, \
							NULL, \
							pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pNode__parent, pThis, pIndexOfNodeInParent - 1), \
							pNode__leftSibling, \
							pNode__leftSibling->gPrivate_numberOfEntries, false); \
				) \
	\
				CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
						sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE)), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode__parent, pThis, pIndexOfNodeInParent - 1), \
						pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode, pThis, 0)); \
			} \
		) \
		( \
			if(pNode->gPrivate_type) \
			{ \
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, pThis, \
									pIndexOfNodeInParent - 1), \
							*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
									0)), \
							NULL, \
							pNode__leftSibling, \
							pNode__leftSibling->gPrivate_numberOfEntries, false); \
	\
					CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT(sizeof(pINDEX_TYPE), \
							pFUNC_INDEX_MOVE_CONSTRUCTOR, \
							pFUNC_INDEX_MOVE_DESTRUCTOR, \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, \
									pThis, pIndexOfNodeInParent - 1), \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
									0)); \
				) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
							pThis, \
							*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
									pThis, 0)), \
							pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode__parent, \
									pThis, pIndexOfNodeInParent - 1), \
							pNode__leftSibling, \
							pNode__leftSibling->gPrivate_numberOfEntries, false); \
	\
					CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
							sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, pELEMENT_TYPE)), \
							CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
									pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
							CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
									pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
							pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pNode__parent, pThis, pIndexOfNodeInParent - 1), \
							pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pNode, pThis, 0)); \
				) \
			} \
			else \
			{ \
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
					( \
						pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
								pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 0), \
								NULL, \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
										0), \
								pNode__leftSibling, \
								pNode__leftSibling->gPrivate_numberOfEntries, false); \
	\
						memcpy(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, pThis, \
										pIndexOfNodeInParent - 1), \
								pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 1), \
								sizeof(pINDEX_TYPE)); \
					) \
					( \
						unsigned char * tIndex__guide = ((unsigned char *)CRX__ALLOCA( \
								sizeof(pINDEX_TYPE))); \
	\
						pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
								1)); \
	\
						pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
								pThis, \
								NULL, \
								NULL, \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
										0), \
								pNode__leftSibling, \
								pNode__leftSibling->gPrivate_numberOfEntries, false); \
	\
						memcpy(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode__parent, pThis, \
										pIndexOfNodeInParent - 1), \
								((pINDEX_TYPE *)tIndex__guide), \
								sizeof(pINDEX_TYPE)); \
					) \
				) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
							pThis, \
							NULL, \
							pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
									0), \
							pNode__leftSibling, \
							pNode__leftSibling->gPrivate_numberOfEntries, false); \
	\
					CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_DESTRUCTOR, CRXM__OR( \
							CRXM__NOT(pIS_PERSISTANT), CRXM__NOT(pIS_TO_USE_DELEGATION))), \
					pFUNC_ELEMENT_DESTRUCTOR(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
							pELEMENT_TYPE, pNode__parent, pThis, pIndexOfNodeInParent - 1));, ) \
	\
					CRXM__IFELSE(CRXM__AND(pIS_PERSISTANT, pIS_TO_USE_DELEGATION)) \
					( \
						*(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode__parent, pThis, pIndexOfNodeInParent - 1)) = \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode, pThis, 1); \
					) \
					( \
						CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
						( \
							pFUNC_ELEMENT_COPY_CONSTRUCTOR( \
									pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode__parent, pThis, pIndexOfNodeInParent - 1), \
									pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode, pThis, 1)); \
						) \
						( \
							memcpy(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode__parent, pThis, pIndexOfNodeInParent - 1), \
									pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode, pThis, 1), \
									sizeof(pELEMENT_TYPE)); \
						) \
					) \
				) \
			} \
		) \
	\
		pMEMBER_FUNCTIONS_PREFIX ## private_removeFirstNEntriesFrom(pThis, pNode, 1); \
		(pNode->gPrivate_numberOfEntries)--; \
	} \
	\
	CRXM__IFELSE2(pIS_PREEMPTIVE, \
	PRIVATE uint32_t pMEMBER_FUNCTIONS_PREFIX ## private_resolveFullNode(pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode__parent, \
			size_t pIndexOfNodeInParent), \
	PRIVATE uint32_t pMEMBER_FUNCTIONS_PREFIX ## private_resolveFullNode(pTREE_TYPE_NAME * pThis, \
			pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t * CRX_NOT_NULL pIndicesOfNodesInParents)) \
	{ \
		CRX_SCOPE_META \
		assert(pNode->gPrivate_numberOfEntries == \
				(2 * pThis->gPrviate_countOfMidElementInNode) - 1); \
	\
		CRX_SCOPE \
		pTREE_TYPE_NAME ## _Private_Node * vNode__parent = CRXM__IFELSE2(pIS_PREEMPTIVE, \
				pNode__parent, pNode->gPrivate_node__parent); \
		size_t vIndexOfNodeInParent = CRXM__IFELSE2(pIS_PREEMPTIVE, \
				pIndexOfNodeInParent, *pIndicesOfNodesInParents); \
		uint32_t vReturn = 1; \
	\
		if(vNode__parent == NULL) \
		{ \
			pTREE_TYPE_NAME ## _Private_InternalNode * tInternalNode = \
					((pTREE_TYPE_NAME ## _Private_InternalNode *)calloc(1, \
					pThis->gPrivate_internalNode_byteLength)); \
	\
			if(tInternalNode != NULL) \
			{ \
				pThis->gPrivate_node__root = &(tInternalNode->gPrivate_node); \
				pThis->gPrivate_node__root->gPrivate_type = 1; \
				pThis->gPrivate_node__root->gPrivate_numberOfEntries = 0; \
	\
				*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pThis->gPrivate_node__root, pThis, 0)) = \
						pNode; \
				/*REMEMBER: THIS IS NECESSARY FOR THE CODE LATER*/ \
				*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pThis->gPrivate_node__root, pThis, 1)) = \
						NULL; \
	\
				CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
				pNode->gPrivate_node__parent = pThis->gPrivate_node__root;, ) \
	\
				++(pThis->gPrivate_numberOfNodes); \
	\
				vNode__parent = pThis->gPrivate_node__root; \
			} \
			else \
				{vReturn = 0;} \
		} \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_PREEMPTIVE)) \
		( \
			if(vReturn != 0) \
			{ \
				if((vNode__parent->gPrivate_numberOfEntries == \
						(2 * pThis->gPrviate_countOfMidElementInNode) - 1)) \
				{ \
					/*WARNING: FORMAL VIOLATION. SEMANTIC OF vReturn IS CHANGED TEMPORARILY HERE*/ \
					vReturn = pMEMBER_FUNCTIONS_PREFIX ## private_resolveFullNode(pThis, \
							vNode__parent, pIndicesOfNodesInParents - 1); \
	\
					if(vReturn == 1) \
					{ \
						if(vIndexOfNodeInParent >= pThis->gPrviate_countOfMidElementInNode) \
						{ \
							vNode__parent = pNode->gPrivate_node__parent; \
\
							*(pIndicesOfNodesInParents - 1) = \
									*(pIndicesOfNodesInParents - 1) + 1; \
							*pIndicesOfNodesInParents = *pIndicesOfNodesInParents - \
									pThis->gPrviate_countOfMidElementInNode; \
							vIndexOfNodeInParent = *pIndicesOfNodesInParents; \
						} \
					} \
					else if(CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, true, false)) \
					{ \
						if(vReturn == 2) \
						{ \
							if(vIndexOfNodeInParent == 0) \
							{ \
								vNode__parent = pNode->gPrivate_node__parent; \
	\
								*(pIndicesOfNodesInParents - 1) = \
										*(pIndicesOfNodesInParents - 1) - 1; \
								*pIndicesOfNodesInParents = \
										vNode__parent->gPrivate_numberOfEntries; \
								vIndexOfNodeInParent = *pIndicesOfNodesInParents; \
							} \
						} \
						else if(vReturn == 3) \
						{ \
							if(vIndexOfNodeInParent > vNode__parent->gPrivate_numberOfEntries) \
							{ \
								vNode__parent = pNode->gPrivate_node__parent; \
	\
								*(pIndicesOfNodesInParents - 1) = \
										*(pIndicesOfNodesInParents - 1) + 1; \
								*pIndicesOfNodesInParents = 0; \
								vIndexOfNodeInParent = *pIndicesOfNodesInParents; \
							} \
						} \
					} \
					else \
						{assert(vReturn == 0);} \
				} \
			} \
		)() \
	\
		if(vReturn != 0) \
		{ \
			CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, \
			bool tIsToSplit = false;, ) \
	\
			CRXM__IFELSE(pIS_CONSERVATIVE_IN_GROWTH) \
			( \
				pTREE_TYPE_NAME ## _Private_Node * tNode__sibling = ( \
						(vIndexOfNodeInParent < (2 * pThis->gPrviate_countOfMidElementInNode)) ? \
						*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, vNode__parent, pThis, \
						vIndexOfNodeInParent + 1)) : NULL); \
	\
				if((tNode__sibling != NULL) && (tNode__sibling->gPrivate_numberOfEntries < \
						((2 * pThis->gPrviate_countOfMidElementInNode) - 2))) \
				{ \
					pMEMBER_FUNCTIONS_PREFIX ## private_rotateRight(pThis, \
							pNode, vIndexOfNodeInParent, vNode__parent, tNode__sibling); \
					vReturn = 3; \
				} \
				else \
				{ \
					tNode__sibling = ((vIndexOfNodeInParent > 0) ? \
							*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, vNode__parent, pThis, \
							vIndexOfNodeInParent - 1)) : NULL); \
	\
					if((tNode__sibling != NULL) && (tNode__sibling->gPrivate_numberOfEntries < \
							((2 * pThis->gPrviate_countOfMidElementInNode) - 2))) \
					{ \
						pMEMBER_FUNCTIONS_PREFIX ## private_rotateLeft(pThis, \
								pNode, vIndexOfNodeInParent, vNode__parent, tNode__sibling); \
						vReturn = 2; \
					} \
					else \
						{tIsToSplit = true;} \
				} \
			)() \
	\
			if(CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, tIsToSplit, true)) \
			{ \
				pTREE_TYPE_NAME ## _Private_Node * tNode = NULL; \
				CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pHAS_INDEX), \
						CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, \
						CRXM__OR(CRXM__NOT(pIS_PERSISTANT), \
								CRXM__NOT(pIS_TO_USE_DELEGATION)))), \
				unsigned char * tElement = NULL;, ) \
	\
				if(pNode->gPrivate_type) \
				{ \
					pTREE_TYPE_NAME ## _Private_InternalNode * tInternalNode = \
							(pTREE_TYPE_NAME ## _Private_InternalNode *)calloc(1, \
							pThis->gPrivate_internalNode_byteLength); \
	\
					if(tInternalNode != NULL) \
						{tNode = &(tInternalNode->gPrivate_node);} \
				} \
				else \
				{ \
					pTREE_TYPE_NAME ## _Private_LeafNode * tLeafNode = \
							(pTREE_TYPE_NAME ## _Private_LeafNode *)calloc(1, \
							pThis->gPrivate_leafNode_byteLength); \
	\
					if(tLeafNode != NULL) \
						{tNode = &(tLeafNode->gPrivate_node);} \
				} \
	\
				CRXM__IFELSE(CRXM__AND(pIS_PERSISTANT, CRXM__AND(CRXM__NOT(pHAS_INDEX), \
						CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, \
						CRXM__NOT(pIS_TO_USE_DELEGATION))))) \
				( \
					if((tNode != NULL) && (pNode->gPrivate_type == 0)) \
					{ \
						tElement = ((unsigned char *)calloc(1, sizeof(pELEMENT_TYPE))); \
	\
						if(tElement == NULL) \
						{ \
							free(tNode); \
							tNode = NULL; \
						} \
					} \
				)() \
	\
				if(tNode != NULL) \
				{ \
					(pThis->gPrivate_numberOfNodes)++; \
	\
					tNode->gPrivate_type = pNode->gPrivate_type; \
					tNode->gPrivate_numberOfEntries = 0; \
					CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
					tNode->gPrivate_node__parent = pNode->gPrivate_node__parent;, ) \
	\
					pMEMBER_FUNCTIONS_PREFIX ## private_transferPushFromNodeToNode(pThis, pNode, \
							tNode, true, pThis->gPrviate_countOfMidElementInNode); \
	\
					tNode->gPrivate_numberOfEntries = \
							pThis->gPrviate_countOfMidElementInNode - 1; \
	\
					CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
					( \
						if(pNode->gPrivate_type) \
						{ \
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
										pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
												pThis->gPrviate_countOfMidElementInNode - 1), \
										tNode, \
										pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
												pThis, pThis->gPrviate_countOfMidElementInNode - 1), \
										vNode__parent, vIndexOfNodeInParent, false); \
							) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
										tNode, \
										pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
												pThis, pThis->gPrviate_countOfMidElementInNode - 1), \
										vNode__parent, vIndexOfNodeInParent, false); \
							) \
						} \
						else \
						{ \
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
								( \
									pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
											pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
													pThis->gPrviate_countOfMidElementInNode - 1), \
											tNode, \
											pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, pNode, pThis, \
													pThis->gPrviate_countOfMidElementInNode - 1), \
											vNode__parent, vIndexOfNodeInParent, false); \
								) \
								( \
									unsigned char * tIndex__guide = (unsigned char *) CRX__ALLOCA( \
											sizeof(pINDEX_TYPE)); \
	\
									pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
											pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode, pThis, \
											pThis->gPrviate_countOfMidElementInNode - 1)); \
	\
									pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
											((pINDEX_TYPE *)tIndex__guide), \
											tNode, \
											pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, pNode, pThis, \
													pThis->gPrviate_countOfMidElementInNode - 1), \
											vNode__parent, vIndexOfNodeInParent, false); \
								) \
							) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
										tNode, \
										pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
												pThis, pThis->gPrviate_countOfMidElementInNode - 1), \
										vNode__parent, vIndexOfNodeInParent, false); \
							) \
						} \
	\
						pNode->gPrivate_numberOfEntries = \
								pThis->gPrviate_countOfMidElementInNode - 1; \
					) \
					( \
						if(pNode->gPrivate_type) \
						{ \
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
										pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
												pThis->gPrviate_countOfMidElementInNode - 1), \
										tNode, \
										NULL, \
										vNode__parent, vIndexOfNodeInParent, false); \
							) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
										tNode, \
										pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
												pNode, pThis, \
												pThis->gPrviate_countOfMidElementInNode - 1), \
										vNode__parent, vIndexOfNodeInParent, false); \
							) \
	\
							pNode->gPrivate_numberOfEntries = \
									pThis->gPrviate_countOfMidElementInNode - 1; \
						} \
						else \
						{ \
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								unsigned char * tIndex__guide = (unsigned char *) CRX__ALLOCA( \
										sizeof(pINDEX_TYPE)); \
	\
								CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
								( \
									memcpy(tIndex__guide, pLEAF__GET_INDEX(pTREE_TYPE_NAME, \
											tNode, pThis, 0), sizeof(pINDEX_TYPE)); \
								) \
								( \
									pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
											pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											tNode, pThis, 0)); \
								) \
	\
								pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
										((pINDEX_TYPE *)tIndex__guide), \
										tNode, \
										NULL, \
										vNode__parent, vIndexOfNodeInParent, false); \
							) \
							( \
								CRXM__IFELSE(CRXM__OR(CRXM__NOT(pIS_PERSISTANT), \
										CRXM__NOT(pIS_TO_USE_DELEGATION))) \
								( \
									CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
									tElement = (unsigned char *) CRX__ALLOCA( \
											sizeof(pELEMENT_TYPE)), ); \
	\
									CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
									( \
										pFUNC_ELEMENT_COPY_CONSTRUCTOR( \
												((pELEMENT_TYPE *)tElement), \
												pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
														tNode, pThis, 0)); \
									) \
									( \
										memcpy(tElement, pLEAF__GET_ELEMENT( \
												pTREE_TYPE_NAME, pELEMENT_TYPE, tNode, pThis, 0), \
												sizeof(pELEMENT_TYPE)); \
									) \
	\
									pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
											tNode, \
											((pELEMENT_TYPE *)tElement), \
											vNode__parent, vIndexOfNodeInParent, false); \
								) \
								( \
									pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
											tNode, \
											pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
													tNode, pThis, 0), \
											vNode__parent, vIndexOfNodeInParent, false); \
								) \
							) \
	\
							pNode->gPrivate_numberOfEntries = \
									pThis->gPrviate_countOfMidElementInNode; \
	\
							((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)->gPrivate_leafNode__prev = \
									((pTREE_TYPE_NAME ## _Private_LeafNode *)pNode); \
							((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)->gPrivate_leafNode__next = \
									((pTREE_TYPE_NAME ## _Private_LeafNode *)pNode)-> \
											gPrivate_leafNode__next; \
	\
							if(((pTREE_TYPE_NAME ## _Private_LeafNode *)pNode)-> \
									gPrivate_leafNode__next != NULL) \
							{ \
								((pTREE_TYPE_NAME ## _Private_LeafNode *)pNode)-> \
										gPrivate_leafNode__next->gPrivate_leafNode__prev = \
										((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode); \
							} \
	\
							((pTREE_TYPE_NAME ## _Private_LeafNode *)pNode)-> \
									gPrivate_leafNode__next = \
									((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode); \
						} \
					) \
	\
					/*(vNode__parent->gPrivate_numberOfEntries)++;*/ \
				} \
				else \
					{vReturn = 0;} \
			} \
		} \
		else \
			{vReturn = 0;} \
	\
		return vReturn; \
	\
		CRX_SCOPE_END \
	} \
	\
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry( \
			pTREE_TYPE_NAME * pThis, pELEMENT_TYPE * CRX_NOT_NULL pElement) \
	{ \
		CRX_SCOPE_META \
		if(pThis->gPrivate_node__root == NULL) \
			{return false;} \
	\
		CRX_SCOPE \
		bool vIsNoError = true; \
		CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
		size_t vIndices[65] /*= ?*/;, ) \
	\
		CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
		vIndices[0] = 0;, ) \
		CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
		vIndices[1] = 0;, ) \
	\
		CRXM__IFELSE(pIS_PREEMPTIVE) \
		( \
			if(pThis->gPrivate_node__root->gPrivate_numberOfEntries == \
					2 * pThis->gPrviate_countOfMidElementInNode - 1) \
			{ \
				vIsNoError = (pMEMBER_FUNCTIONS_PREFIX ## private_resolveFullNode(pThis, \
						pThis->gPrivate_node__root, NULL, 0) != 0); \
			} \
		)() \
	\
		if(CRXM__IFELSE2(pIS_PREEMPTIVE, vIsNoError, true)) \
		{ \
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				unsigned char * tIndex__guide = (unsigned char *) CRX__ALLOCA( \
						sizeof(pINDEX_TYPE)); \
	\
				pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), pElement); \
	\
				CRXM__IFELSE(pIS_PREEMPTIVE) \
				( \
					vIsNoError = pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
							pThis, pThis->gPrivate_node__root, \
							((pINDEX_TYPE *)tIndex__guide), pElement); \
				) \
				( \
					vIsNoError = pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
							pThis, pThis->gPrivate_node__root, &(vIndices[1]), \
							((pINDEX_TYPE *)tIndex__guide), pElement); \
				) \
			) \
			( \
				CRXM__IFELSE(pIS_PREEMPTIVE) \
				( \
					vIsNoError = pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
							pThis, pThis->gPrivate_node__root, pElement); \
				) \
				( \
					vIsNoError = pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
							pThis, pThis->gPrivate_node__root, &(vIndices[1]), pElement); \
				) \
			) \
	\
			if(vIsNoError) \
			{ \
				++(pThis->gPrivate_numberOfElements); \
	\
				return true; \
			} \
			else \
				{return false;} \
		} \
		else \
			{return false;} \
		CRX_SCOPE_END \
	} \
	CRXM__IFELSE2(pHAS_INDEX, \
	CRXM__IFELSE2(pIS_PREEMPTIVE, \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			pINDEX_TYPE * CRX_NOT_NULL pIndex__guide, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement), \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t * CRX_NOT_NULL pIndexOfNodeInParent, \
			pINDEX_TYPE * CRX_NOT_NULL pIndex__guide, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement)), \
	CRXM__IFELSE2(pIS_PREEMPTIVE, \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement), \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t * CRX_NOT_NULL pIndexOfNodeInParent, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement))) \
	{ \
		/*pGUIDE_TYPE * vReturn = NULL;*/ \
	\
		if(pNode->gPrivate_type) \
		{ \
			bool tIsNoError = true; \
	\
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				size_t tIndex = pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
						pThis, pNode, pIndex__guide, NULL) /*+ 1*/; \
				pTREE_TYPE_NAME ## _Private_Node * tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
						pNode, pThis, tIndex)); \
	\
				CRXM__IFELSE(pIS_PREEMPTIVE) \
				( \
					if(tNode->gPrivate_numberOfEntries == \
							((2 * pThis->gPrviate_countOfMidElementInNode) - 1)) \
					{ \
						uint32_t tResult = pMEMBER_FUNCTIONS_PREFIX ## private_resolveFullNode( \
								pThis, tNode, pNode, tIndex); \
	\
						/*NOTE: IN THIS CASE WE ARE DELIBRATELY DECIDING ON THE INSERTION WITH \
								">" AND "<" INSTEAD OF ">=" AND "<" THAT WOULD BE PER THE \
								ALGORITHM OF Tree::getSuitableImagineryIndexFor(). THIS IS TO \
								AVOID RE ASSIGNING TO tNode. \
						*/ \
						if(tResult != 0) \
						{ \
							if(((tResult == 1) || CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, \
											(tResult == 3), false)) && \
									(pCOMPARE_INDICES(pIndex__guide, pINTERNAL__GET_INDEX( \
											pTREE_TYPE_NAME, pNode, pThis, tIndex)) > 0)) \
							{ \
								tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
										tIndex + 1)); \
							} \
							else if((tResult == 2) && CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, \
									(pCOMPARE_INDICES(pIndex__guide, pINTERNAL__GET_INDEX( \
											pTREE_TYPE_NAME, pNode, pThis, tIndex - 1)) < 0), \
									false)) \
							{ \
								CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, \
								tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
										tIndex - 1));, ) \
							} \
						} \
						else \
							{tIsNoError = false;} \
					} \
	\
					if(tIsNoError) \
					{ \
						tIsNoError = \
								pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
								pThis, tNode, pIndex__guide, pElement); \
					} \
				) \
				( \
					*(pIndexOfNodeInParent + 1) = tIndex; \
	\
					tIsNoError = pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
							pThis, tNode, pIndexOfNodeInParent + 1, pIndex__guide, pElement); \
				) \
			) \
			( \
				size_t tIndex = pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
						pThis, pNode, pElement, NULL) /*+ 1*/; \
				pTREE_TYPE_NAME ## _Private_Node * tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
						pNode, pThis, tIndex)); \
	\
				CRXM__IFELSE(pIS_PREEMPTIVE) \
				( \
					if(tNode->gPrivate_numberOfEntries == \
							((2 * pThis->gPrviate_countOfMidElementInNode) - 1)) \
					{ \
						uint32_t tResult = pMEMBER_FUNCTIONS_PREFIX ## private_resolveFullNode( \
								pThis, tNode, pNode, tIndex); \
	\
						/*NOTE: IN THIS CASE WE ARE DELIBRATELY DECIDING ON THE INSERTION WITH \
								">" AND "<" INSTEAD OF ">=" AND "<" THAT WOULD BE PER THE \
								ALGORITHM OF Tree::getSuitableImagineryIndexFor(). THIS IS TO \
								AVOID RE ASSIGNING TO tNode. \
						*/ \
						if(tResult != 0) \
						{ \
							if(((tResult == 1) || CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, \
											(tResult == 3), false)) && \
									(pCOMPARE_ELEMENTS(pElement, pINTERNAL__GET_ELEMENT( \
											pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
											tIndex)) > 0)) \
							{ \
								tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
										tIndex + 1)); \
							} \
							else if((tResult == 2) && CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, \
									(pCOMPARE_ELEMENTS(pElement, pINTERNAL__GET_ELEMENT( \
											pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
											tIndex - 1)) < 0), false)) \
							{ \
								CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, \
								tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
										tIndex - 1));, ) \
							} \
						} \
						else \
							{tIsNoError = false;} \
					} \
	\
					if(tIsNoError) \
					{ \
						tIsNoError = \
								pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
								pThis, tNode, pElement); \
					} \
				) \
				( \
					*(pIndexOfNodeInParent + 1) = tIndex; \
	\
					tIsNoError = pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry__do( \
							pThis, tNode, pIndexOfNodeInParent + 1, pElement); \
				) \
			) \
	\
			return tIsNoError; \
		} \
		else \
		{ \
			CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
			bool tIsNoError = true;, ) \
			pTREE_TYPE_NAME ## _Private_Node * tNode = pNode; \
	\
			CRXM__IFELSE(CRXM__NOT(pIS_PREEMPTIVE)) \
			( \
				if(tNode->gPrivate_numberOfEntries == \
						((2 * pThis->gPrviate_countOfMidElementInNode) - 1)) \
				{ \
					uint32_t tResult = pMEMBER_FUNCTIONS_PREFIX ## private_resolveFullNode(pThis, \
							tNode, pIndexOfNodeInParent); \
	\
					if(tResult != 0) \
					{ \
						/*NOTE: IN THIS CASE WE ARE DELIBRATELY DECIDING ON THE INSERTION WITH \
								">" AND "<" INSTEAD OF ">=" AND "<" THAT WOULD BE PER THE \
								ALGORITHM OF Tree::getSuitableImagineryIndexFor(). THIS IS TO \
								AVOID RE ASSIGNING TO tNode. \
						*/ \
						CRXM__IFELSE(pHAS_INDEX) \
						( \
							if(((tResult == 1) || CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, \
											(tResult == 3), false)) && \
									(pCOMPARE_INDICES(pIndex__guide, pINTERNAL__GET_INDEX( \
											pTREE_TYPE_NAME, tNode->gPrivate_node__parent, pThis, \
											*pIndexOfNodeInParent)) > 0)) \
							{ \
								tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
										tNode->gPrivate_node__parent, pThis, \
										(*pIndexOfNodeInParent) + 1)); \
							} \
							else if((tResult == 2) && CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, \
									(pCOMPARE_INDICES(pIndex__guide, pINTERNAL__GET_INDEX( \
											pTREE_TYPE_NAME, tNode->gPrivate_node__parent, pThis, \
											(*pIndexOfNodeInParent) - 1)) < 0), \
									false)) \
							{ \
								CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, \
								tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
										tNode->gPrivate_node__parent, pThis, \
										(*pIndexOfNodeInParent) - 1));, ) \
							} \
						) \
						( \
							if(((tResult == 1) || CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, \
											(tResult == 3), false)) && \
									(pCOMPARE_ELEMENTS(pElement, pINTERNAL__GET_ELEMENT( \
											pTREE_TYPE_NAME, pELEMENT_TYPE, \
											tNode->gPrivate_node__parent, pThis, \
											*pIndexOfNodeInParent)) > 0)) \
							{ \
								tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
										tNode->gPrivate_node__parent, pThis, \
										(*pIndexOfNodeInParent) + 1)); \
							} \
							else if((tResult == 2) && CRXM__IFELSE2(pIS_CONSERVATIVE_IN_GROWTH, \
									(pCOMPARE_ELEMENTS(pElement, pINTERNAL__GET_ELEMENT( \
											pTREE_TYPE_NAME, pELEMENT_TYPE, \
											tNode->gPrivate_node__parent, pThis, \
											(*pIndexOfNodeInParent) - 1)) < 0), \
									false)) \
							{ \
								tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
										tNode->gPrivate_node__parent, pThis, \
										(*pIndexOfNodeInParent) - 1)); \
							} \
						) \
					} \
					else \
						{tIsNoError = false;} \
				} \
			)() \
	\
			if(CRXM__IFELSE2(pIS_PREEMPTIVE, true, tIsNoError)) \
			{ \
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					size_t tImaginaryIndex = \
							pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
							pThis, tNode, pIndex__guide, NULL); \
	\
					CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
					( \
						pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
								pIndex__guide, NULL, pElement, tNode, tImaginaryIndex, false); \
					) \
					( \
						pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, \
								NULL, NULL, pElement, tNode, tImaginaryIndex, false); \
					) \
				) \
				( \
					size_t tImaginaryIndex = \
							pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
							pThis, tNode, pElement, NULL); \
	\
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode(pThis, NULL, \
							pElement, tNode, tImaginaryIndex, false); \
				) \
	\
				/*vReturn = pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, tNode, pThis, \
						tImaginaryIndex);*/ \
				return true; \
			} \
			else \
				{return false;} \
		} \
	} \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## tryMoveAndInsertElement(pTREE_TYPE_NAME * pThis, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement) \
	{ \
		CRXM__IFELSE(CRXM__OR(pFUNC_ELEMENT_MOVE_DESTRUCTOR, pIS_PERSISTANT)) \
		( \
			unsigned char * tElement = CRXM__IFELSE2(pIS_PERSISTANT, \
					((unsigned char *)calloc(1, sizeof(pELEMENT_TYPE))), \
					((unsigned char *)CRX__ALLOCA(sizeof(pELEMENT_TYPE)))); \
	\
			if(tElement != NULL) \
			{ \
				CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
				( \
					pFUNC_ELEMENT_MOVE_CONSTRUCTOR(((pELEMENT_TYPE *)tElement), pElement); \
				) \
				( \
					memcpy(tElement, pElement, sizeof(pELEMENT_TYPE)); \
				) \
	\
				if(pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry(pThis, \
						((pELEMENT_TYPE *)tElement))) \
					{return true;} \
				else \
				{ \
					CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
					pFUNC_ELEMENT_MOVE_DESTRUCTOR(pElement);, ) \
	\
					CRXM__IFELSE(pFUNC_ELEMENT_MOVE_CONSTRUCTOR) \
					( \
						pFUNC_ELEMENT_MOVE_CONSTRUCTOR(pElement, ((pELEMENT_TYPE *)tElement)); \
					) \
					( \
						memcpy(pElement, tElement, sizeof(pELEMENT_TYPE)); \
					) \
	\
					CRXM__IFELSE2(pFUNC_ELEMENT_MOVE_DESTRUCTOR, \
					pFUNC_ELEMENT_MOVE_DESTRUCTOR(((pELEMENT_TYPE *)tElement));, ) \
	\
					CRXM__IFELSE2(pIS_PERSISTANT, \
					free(tElement);, ) \
	\
					return false; \
				} \
			} \
			else \
				{return false;} \
		) \
		( \
			return pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry(pThis, \
					pElement); \
		) \
	} \
	CRXM__IFELSE2(pIS_COPYABLE, \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## insertElement(pTREE_TYPE_NAME * pThis, \
			pELEMENT_TYPE * CRX_NOT_NULL pElement) \
	{ \
		CRXM__IFELSE2(CRXM__OR(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, \
				CRXM__OR(pFUNC_ELEMENT_MOVE_DESTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR)), \
				pIS_PERSISTANT), \
		unsigned char * vElement = CRXM__IFELSE2(pIS_PERSISTANT, \
					((unsigned char *) calloc(1, sizeof(pELEMENT_TYPE))), \
					((unsigned char *) CRX__ALLOCA(sizeof(pELEMENT_TYPE))));, ) \
		bool vReturn /*= ?*/; \
	\
		CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
		( \
			pFUNC_ELEMENT_COPY_CONSTRUCTOR(((pELEMENT_TYPE *)vElement), pElement); \
	\
			vReturn = pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry(pThis, \
					((pELEMENT_TYPE *)vElement)); \
		) \
		( \
			CRXM__IFELSE(CRXM__OR(pIS_PERSISTANT, \
					CRXM__OR(pFUNC_ELEMENT_MOVE_DESTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR))) \
			( \
				memcpy(vElement, pElement, sizeof(pELEMENT_TYPE)); \
	\
				vReturn = pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry(pThis, \
						((pELEMENT_TYPE *)vElement)); \
			) \
			( \
				return pMEMBER_FUNCTIONS_PREFIX ## private_transferAndInsertElementEntry(pThis, \
						pElement); \
			) \
		) \
	\
		CRXM__IFELSE(CRXM__OR(pIS_PERSISTANT, CRXM__AND(pFUNC_ELEMENT_DESTRUCTOR, \
				CRXM__OR(CRXM__OR(pFUNC_ELEMENT_COPY_CONSTRUCTOR, pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
				pFUNC_ELEMENT_MOVE_DESTRUCTOR)))) \
		( \
			if(!vReturn) \
			{ \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
				pFUNC_ELEMENT_DESTRUCTOR(((pELEMENT_TYPE *)vElement));, ) \
	\
				CRXM__IFELSE2(pIS_PERSISTANT, \
				free(vElement);, ) \
			} \
		)() \
	\
		return vReturn; \
	}, ) \
	\
	PRIVATE pTREE_TYPE_NAME ## _Private_Node * pMEMBER_FUNCTIONS_PREFIX ## mergeTwoNodesAndGetRemainingNode( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			size_t pIndex) \
	{ \
		CRX_SCOPE_META \
		assert(pNode->gPrivate_type); \
	\
		CRX_SCOPE \
		pTREE_TYPE_NAME ## _Private_Node * tNode__left = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
				pNode, pThis, pIndex)); \
		pTREE_TYPE_NAME ## _Private_Node * tNode__right = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
				pNode, pThis, pIndex + 1)); \
		CRXM__IFELSE2(pIS_TO_USE_RINGS, \
		bool vIsToRotateRight = ((pNode->gPrivate_numberOfEntries >> 1) > pIndex);, ) \
	\
		/*WE HAVE TO CONSIDER THE NON PR EMPTIVE CASE, HENCE NO STRICT '==' WITH \
				"gPrivate_numberOfEntries - 1", AND INSTEAD WHEN USES '<' WITH
				"gPrivate_numberOfEntries"*/ \
		assert((tNode__left->gPrivate_numberOfEntries < \
						pThis->gPrviate_countOfMidElementInNode) && \
				(tNode__right->gPrivate_numberOfEntries < \
						pThis->gPrviate_countOfMidElementInNode)); \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				/*NOTES: \
					- NULL IS ACTUALLY INSERTED FOR THE NODE IN THIS CASE UNLIKE ELSEWHERE IN THE \
							CODE. \
					- STRICTLY, WE WOULD NEED TO CHECK FOR pARE_INDICES_IN_INTERNAL_NODES_ONLY BUT \
							THERE IS UNLIKELY A PERFORMANCE COST SAVING OF CHECKING WHETHER THE \
							CHILD NODE IS A LEAF AND THEN PASSING NULL OR THE INDEX, OR JUST \
							IMMEDIATELY PASSING AN INDEX AND RELYING ON transferAllIntoNode() TO \
							SIMPLY IGNORE IT. \
				*/ \
				pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
						pThis, \
						pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
								pNode, pThis, pIndex), \
						NULL, \
						pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
								pELEMENT_TYPE, pNode, pThis, pIndex), \
						tNode__left, \
						tNode__left->gPrivate_numberOfEntries, false); \
	\
				CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, pINDEX_TYPE, \
						pFUNC_INDEX_MOVE_CONSTRUCTOR, \
						pFUNC_INDEX_MOVE_DESTRUCTOR, \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						pNode, \
						pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, \
								pThis, 0), \
						pNode->gPrivate_numberOfEntries, pIndex, 1, vIsToRotateRight) \
			) \
			( \
				/*NOTE: NULL IS ACTUALLY INSERTED FOR THE NODE IN THIS \
						CASE UNLIKE ELSEWHERE IN THE CODE.*/ \
				pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
						pThis, \
						NULL, \
						pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
								pELEMENT_TYPE, pNode, pThis, pIndex), \
						tNode__left, \
						tNode__left->gPrivate_numberOfEntries, false); \
	\
				CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								pELEMENT_TYPE *, pELEMENT_TYPE), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						pNode, \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
								pELEMENT_TYPE, pNode, pThis, 0), \
						pNode->gPrivate_numberOfEntries, pIndex, 1, vIsToRotateRight) \
			) \
	\
			/*(tNode__left->gPrivate_numberOfEntries)++;*/ \
	\
			CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
					pTREE_TYPE_NAME ## _Private_Node *, \
					CRXM__FALSE, CRXM__FALSE, \
					2 * pThis->gPrviate_countOfMidElementInNode, \
					pNode, \
					pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
							pThis, 0), \
					pNode->gPrivate_numberOfEntries + 1, pIndex + 1, 1, vIsToRotateRight) \
	\
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								pELEMENT_TYPE *, pELEMENT_TYPE), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						pNode, \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
								pELEMENT_TYPE, pNode, pThis, 0), \
						pNode->gPrivate_numberOfEntries, pIndex, 1, vIsToRotateRight) \
			)() \
	\
			CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_REMOVAL_OF_SPACE( \
					pIS_TO_USE_RINGS, 2 * pThis->gPrviate_countOfMidElementInNode, \
					pNode, 1, vIsToRotateRight) \
	\
			pMEMBER_FUNCTIONS_PREFIX ## private_transferPushFromNodeToNode( \
					pThis, tNode__right, tNode__left, true, 0); \
		) \
		( \
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				if(tNode__left->gPrivate_type) \
				{ \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
							pThis, \
							pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
									pNode, pThis, pIndex), \
							NULL, \
							NULL, \
							tNode__left, \
							tNode__left->gPrivate_numberOfEntries, true); \
				} \
	\
				CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
						pINDEX_TYPE, \
						pFUNC_INDEX_MOVE_CONSTRUCTOR, \
						pFUNC_INDEX_MOVE_DESTRUCTOR, \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						pNode, \
						pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, \
								pThis, 0), \
						pNode->gPrivate_numberOfEntries, pIndex, 1, vIsToRotateRight) \
			) \
			( \
				if(tNode__left->gPrivate_type) \
				{ \
					/*NOTE: NULL IS ACTUALLY INSERTED FOR THE NODE IN THIS \
							CASE UNLIKE ELSEWHERE IN THE CODE.*/ \
					pMEMBER_FUNCTIONS_PREFIX ## private_transferAllIntoNode( \
							pThis, \
							NULL, \
							pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
									pELEMENT_TYPE, pNode, pThis, pIndex), \
							tNode__left, \
							tNode__left->gPrivate_numberOfEntries, true); \
				} \
				else \
				{ \
					CRXM__IFELSE(CRXM__OR(CRXM__NOT(pIS_PERSISTANT), \
							CRXM__NOT(pIS_TO_USE_DELEGATION))) \
					( \
						CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
						pFUNC_ELEMENT_DESTRUCTOR(pINTERNAL__GET_ELEMENT( \
								pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
								pIndex));, ) \
	\
						CRXM__IFELSE2(pIS_PERSISTANT, \
						free(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
								pIndex));, ) \
					)() \
				} \
	\
				CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
						CRXM__IFELSE2(pIS_PERSISTANT, \
								pELEMENT_TYPE *, pELEMENT_TYPE), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						2 * pThis->gPrviate_countOfMidElementInNode, \
						pNode, \
						pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
								pELEMENT_TYPE, pNode, pThis, 0), \
						pNode->gPrivate_numberOfEntries, pIndex, 1, vIsToRotateRight) \
			) \
	\
			/*(tNode__left->gPrivate_numberOfEntries)++;*/ \
	\
			CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
					pTREE_TYPE_NAME ## _Private_Node *, \
					CRXM__FALSE, CRXM__FALSE, \
					2 * pThis->gPrviate_countOfMidElementInNode, \
					pNode, \
					pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
							pThis, 0), \
					pNode->gPrivate_numberOfEntries + 1, pIndex + 1, 1, vIsToRotateRight) \
	\
			CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_REMOVAL_OF_SPACE( \
					pIS_TO_USE_RINGS, 2 * pThis->gPrviate_countOfMidElementInNode, \
					pNode, 1, vIsToRotateRight) \
	\
			pMEMBER_FUNCTIONS_PREFIX ## private_transferPushFromNodeToNode( \
					pThis, tNode__right, tNode__left, true, 0); \
	\
			if(tNode__left->gPrivate_type == 0) \
			{ \
				((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode__left)->gPrivate_leafNode__next = \
						((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode__right)-> \
								gPrivate_leafNode__next; \
	\
				if(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode__right)-> \
						gPrivate_leafNode__next != NULL) \
				{ \
					((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode__right)-> \
							gPrivate_leafNode__next->gPrivate_leafNode__prev = \
							((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode__left); \
				} \
			} \
		) \
	\
		tNode__left->gPrivate_numberOfEntries += \
				tNode__right->gPrivate_numberOfEntries; \
	\
		--(pNode->gPrivate_numberOfEntries); \
	\
		free(tNode__right); \
		tNode__right = NULL; \
	\
		--(pThis->gPrivate_numberOfNodes); \
	\
		return tNode__left; \
	\
		CRX_SCOPE_END \
	} \
	\
	PUBLIC bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## removeElement(pTREE_TYPE_NAME * pThis, \
			pELEMENT_TYPE const * CRX_NOT_NULL pElement) \
	{ \
		CRXM__IFELSE2(pHAS_INDEX, \
		unsigned char * vIndex__guide = ((unsigned char *)CRX__ALLOCA(sizeof(pINDEX_TYPE)));, ) \
		CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
				pHAS_INDEX), \
		pTREE_TYPE_NAME ## _Iterator vIterator /*= ?*/;, ) \
		CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
				pHAS_INDEX), \
		pTREE_TYPE_NAME ## _Iterator_Private_Position vPositions[64] /*= ?*/;, ) \
		bool vReturn /*= ?*/; \
	\
		CRXM__IFELSE2(pHAS_INDEX, \
		pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)vIndex__guide), pElement);, ) \
		CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
				pHAS_INDEX), \
		pMEMBER_FUNCTIONS_PREFIX ## iterator_private_construct3(&vIterator, \
				&(vPositions[0]), pThis);, ) \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
				( \
					vReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do(pThis, 0, \
							pThis->gPrivate_node__root, ((pINDEX_TYPE *)vIndex__guide), \
							((pELEMENT_TYPE *)pElement), &vIterator); \
				) \
				( \
					vReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do(pThis, 0, \
							pThis->gPrivate_node__root, ((pINDEX_TYPE *)vIndex__guide), \
							((pELEMENT_TYPE * *)&pElement), &vIterator); \
				) \
			) \
			( \
				CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
				( \
					vReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do(pThis, 0, \
							pThis->gPrivate_node__root, ((pELEMENT_TYPE *)pElement)); \
				) \
				( \
					vReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do(pThis, 0, \
							pThis->gPrivate_node__root, \
							((pELEMENT_TYPE * *)&pElement)); \
				) \
			) \
		) \
		( \
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
				( \
					vReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do(pThis, 0, \
							pThis->gPrivate_node__root, ((pINDEX_TYPE *)vIndex__guide), \
							pElement, NULL); \
				) \
				( \
					vReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do(pThis, 0, \
							pThis->gPrivate_node__root, ((pINDEX_TYPE *)vIndex__guide), \
							pElement, NULL); \
				) \
			) \
			( \
				CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
				( \
					vReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do(pThis, 0, \
							pThis->gPrivate_node__root, pElement, NULL); \
				) \
				( \
					vReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do(pThis, 0, \
							pThis->gPrivate_node__root, pElement, NULL); \
				) \
			) \
		) \
	\
		if(vReturn) \
		{ \
			--pThis->gPrivate_numberOfElements; \
	\
			/*HAPPENS WHEN WE HAVE ONE LEAF NODE ATTACHED TO THE ROOT, AN INTERNAL NODE.*/ \
			if((pThis->gPrivate_node__root->gPrivate_numberOfEntries == 0) && \
					(pThis->gPrivate_node__root->gPrivate_type)) \
			{ \
				pTREE_TYPE_NAME ## _Private_Node * tNode = pThis->gPrivate_node__root; \
	\
				pThis->gPrivate_node__root = *pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
						tNode, pThis, 0); \
				CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
				pThis->gPrivate_node__root->gPrivate_node__parent = NULL;, ) \
	\
				(pThis->gPrivate_numberOfNodes)--; \
	\
				free(tNode); \
			} \
		} \
	\
		return vReturn; \
	} \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	CRXM__IFELSE2(pHAS_INDEX, \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE * pElement, \
			pTREE_TYPE_NAME ## _Iterator * pIterator), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE * * pElement, \
			pTREE_TYPE_NAME ## _Iterator * pIterator)), \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pELEMENT_TYPE * pElement), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pELEMENT_TYPE * * pElement))), \
	CRXM__IFELSE2(pHAS_INDEX, \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE const * pElement, \
			pINDEX_TYPE * pIndex__out), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE const * pElement, \
			pINDEX_TYPE * pIndex__out)), \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pELEMENT_TYPE const * pElement, pELEMENT_TYPE * pElement__out), \
	PRIVATE bool /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
			pTREE_TYPE_NAME * pThis, uint32_t pMode, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pELEMENT_TYPE const * pElement, pELEMENT_TYPE * * pElement__out)))) \
	{ \
		/*if(pNode == NULL) \
			{return *pKey;} \
		else*/ \
	\
		if(pNode != NULL) \
		{ \
			size_t tImaginaryIndex; \
			int32_t tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 0; \
	\
			/*if(pMode) \
			{ /* pMode can only be 0, 1 or 2 * / \
				tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = \
						((pNode->gPrivate_type == 0) ? 0 : ((pMode == 1) ? 1 : -1)); \
				tImaginaryIndex = ((pMode == 1) ? (pNode->gPrivate_numberOfEntries /*- 1* /) : 0/*-1* /); \
			}*/ \
			CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
			( \
				if(pMode == 1) \
				{ \
					if(pNode->gPrivate_type) \
						{tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 1;} \
	\
					tImaginaryIndex = pNode->gPrivate_numberOfEntries /*- 1*/; \
				} \
				else if(pMode == 2) \
				{ \
					if(pNode->gPrivate_type) \
					{ \
						tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = -1; \
						tImaginaryIndex = 0 /*-1*/; \
					} \
					else \
						{tImaginaryIndex = 1 /*0*/;} \
				} \
				else /*pMode == 0*/ \
				{ \
					CRXM__IFELSE(pHAS_INDEX) \
					( \
						tImaginaryIndex = \
								pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
								pThis, pNode, pIndex__guide, \
								&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode); \
					) \
					( \
						tImaginaryIndex = \
								pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
								pThis, pNode, CRXM__IFELSE2(pIS_PERSISTANT, *pElement, pElement), \
								&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode); \
					) \
				} \
			) \
			( \
				/* CRXM__IFELSE(pHAS_INDEX) \
				( \
					tImaginaryIndex = \
							pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
							pThis, pNode, pIndex__guide, \
							&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode); \
				) \
				( \
					tImaginaryIndex = \
							pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
							pThis, pNode, pElement, \
							&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode); \
				) */ \
	\
				/*UNLIKE THE ABOVE CODE, THE FOLLOWING ASSUMES THAT THE ELEMENT FROM THE LEAVES \
						THAT WAS COPIED TO THE INTERNAL NODES REMAINS AT THE RIGHT MOST EDGE OF \
						THE LEAF THAT IT IS IN NO MATTER HOW MUCH SPLITTING HAPPENS OR THE COPY \
						MOVES THE TREE RELATIVE TO THE LEAVES.*/ \
				if(pMode == 1) \
				{ \
					/*SHOULD NOT HAPPEN*/ \
					assert(false); \
					if(pNode->gPrivate_type) \
						{tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 1;} \
	\
					tImaginaryIndex = pNode->gPrivate_numberOfEntries /*- 1*/; \
				} \
				if(pMode == 2) \
				{ \
					if(pNode->gPrivate_type) \
					{ \
						tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = -1; \
						tImaginaryIndex = 0 /*-1*/; \
					} \
					else \
						{tImaginaryIndex = 1 /*0*/;} \
				} \
				else \
				{ \
					CRXM__IFELSE(pHAS_INDEX) \
					( \
						tImaginaryIndex = \
								pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
								pThis, pNode, pIndex__guide, \
								&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode); \
					) \
					( \
						tImaginaryIndex = \
								pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
								pThis, pNode, pElement, \
								&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode); \
					) \
				} \
			) \
	\
			if(pNode->gPrivate_type) \
			{ \
				bool tIsDone = false; \
				bool tReturn = false; \
	\
				if((tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0) && \
						CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), true, \
						(pMode == 0))) \
				{ \
					/*EVEN WHEN ELEMENT DATA IS NOT IN LEAVES ONLY, pMode MUST ALSO BE 0 IF WE ARE \
							HERE. THIS IS BECAUSE WE ARE STICKING TO THE FIRST FOUND ENTRY IN THE \
							INTERNAL NODES IN THAT CASE. \
							NOTE THAT THIS WAS NECESSARY WHEN THE ALGORITHM CONTINUED TO DO A \
							BINARY SEARCH IN THE CASE WHEN MODE WAS NOT ZERO AND ELEMENT DATA WAS \
							IN LEAVES. LATER I CHANED THAT, BUT KEEPING THE CODE ABOVE IN THE IF
							CONDITION, AND THE ASSERTION BELOW, FOR THE TIME BEING.
					*/ \
					CRX_SCOPE_META \
					assert(pMode == 0); \
	\
					CRX_SCOPE \
					size_t tNumberOfKeysInLeftNode = 0; \
					size_t tNumberOfKeysInRightNode = (*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
							pNode, pThis, \
							tImaginaryIndex /*+ 1*/)))->gPrivate_numberOfEntries; \
					int32_t tBranchToTake = -2;	/*-2: non,  -1: left,  0: merge and try again, \
												1: right*/ \
					bool tIsFound = false; \
	\
					CRXM__IFELSE(CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_PREEMPTIVE)) \
					( \
						if(tNumberOfKeysInRightNode < pThis->gPrviate_countOfMidElementInNode) \
						{ \
							tNumberOfKeysInLeftNode = (*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
									pNode, pThis, \
									tImaginaryIndex - 1)))->gPrivate_numberOfEntries; \
	\
							if(tNumberOfKeysInLeftNode >= pThis->gPrviate_countOfMidElementInNode) \
							{ \
								pMEMBER_FUNCTIONS_PREFIX ## private_rotateRight(pThis, \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
												tImaginaryIndex - 1)), \
										tImaginaryIndex - 1, pNode, \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
												tImaginaryIndex /*+ 1*/))); \
	\
								CRXM__IFELSE(pHAS_INDEX) \
								( \
									tReturn = \
											pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
											pThis, 0, pNode, pIndex__guide, pElement, NULL); \
								) \
								( \
									tReturn = \
											pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
											pThis, 0, pNode, pElement, NULL); \
								) \
	\
								tIsDone = true; \
							} \
						} \
					)() \
	\
					/*THE FOLLOWING CHECK FOR tIsDone IS ONLY REQUIRED WHEN DATA IS IN THE 
							LEAVES ONLY, BUT TO KEEP THINGS SIMPLE THE CHECK IS ALWAYS DONE.
					*/ \
					if(!tIsDone) \
					{ \
						CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
								pHAS_INDEX), \
						pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPush(pIterator, \
								pNode, tImaginaryIndex - 1);, ) \
	\
						if(tNumberOfKeysInRightNode >= pThis->gPrviate_countOfMidElementInNode) \
							{tBranchToTake = 1;} \
						else \
						{ \
							CRXM__IFELSE(pIS_PREEMPTIVE) \
							( \
								CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
								( \
									tNumberOfKeysInLeftNode = (*(pINTERNAL__GET_NODE( \
											pTREE_TYPE_NAME, pNode, pThis, \
											tImaginaryIndex - 1)))->gPrivate_numberOfEntries; \
	\
									if(tNumberOfKeysInLeftNode >= \
											pThis->gPrviate_countOfMidElementInNode) \
										{tBranchToTake = -1;} \
									else \
										{tBranchToTake = 0;} \
								) \
								( \
									assert((tNumberOfKeysInLeftNode > 0) && \
											(tNumberOfKeysInLeftNode < \
													pThis->gPrviate_countOfMidElementInNode)); \
	\
									tBranchToTake = 0; \
								) \
							) \
							( \
								CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
								( \
									tBranchToTake = -1; \
								) \
								( \
									tBranchToTake = 1; \
								) \
							) \
						} \
	\
						if(tBranchToTake != 0) \
						{ \
							CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
							( \
								CRXM__IFELSE(pHAS_INDEX) \
								( \
									pTREE_TYPE_NAME ## _Iterator tIterator /*= ?*/; \
									unsigned char * tPositions /*= ?*/; \
									uint32_t tResult /*= ?*/; \
	\
									/*THIS IS FORMAL VIOLATION. THIS IS DONE BECAUSE WE CAN NOT \
									GUARANTEE WHEN THE ALLOCATION OF THE LARGE BUFFER HAPPENS \
									ON THE STACK, AND IT MIGHT END UP HAPPENING IN EVERY \
									ITERATION*/ \
									tPositions = ((unsigned char *) CRX__ALLOCA(sizeof( \
											pTREE_TYPE_NAME ## _Iterator_Private_Position) * 64)); \
									pMEMBER_FUNCTIONS_PREFIX ## iterator_private_construct3( \
											&tIterator, \
											((pTREE_TYPE_NAME ## _Iterator_Private_Position *) \
													tPositions), \
											pThis); \
	\
									tResult = \
											pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do__findExactEntry( \
											pThis, pIndex__guide, pElement, pIterator, &tIterator); \
	\
									if(tResult != 0) \
									{ \
										if(tResult == 1) \
										{ \
											CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
											pFUNC_ELEMENT_DESTRUCTOR(pINTERNAL__GET_ELEMENT( \
													pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
													tImaginaryIndex - 1));, ) \
	\
											CRXM__IFELSE2(pIS_PERSISTANT, \
											free(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, pNode, pThis, \
													tImaginaryIndex - 1));, ) \
										} \
										else \
										{ \
											assert(tResult == 2); \
	\
											CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
											pFUNC_ELEMENT_DESTRUCTOR( \
													pMEMBER_FUNCTIONS_PREFIX ## iterator_get( \
													&tIterator));, ) \
	\
											CRXM__IFELSE2(pIS_PERSISTANT, \
											free(pMEMBER_FUNCTIONS_PREFIX ## iterator_get( \
													&tIterator));, ) \
	\
											if(CRXM__IFELSE2(CRXM__NOT( \
													pARE_INDICES_IN_INTERNAL_NODES_ONLY), true, \
													pMEMBER_FUNCTIONS_PREFIX ## iterator_private_isInInternalNode( \
													&tIterator))) \
											{ \
												CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
														sizeof(pINDEX_TYPE), \
														pFUNC_INDEX_MOVE_CONSTRUCTOR, \
														pFUNC_INDEX_MOVE_DESTRUCTOR, \
														pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getIndex( \
																&tIterator), \
														pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
																pNode, pThis, \
																tImaginaryIndex - 1)); \
											} \
	\
											CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
													sizeof(CRXM__IFELSE2(pIS_PERSISTANT, \
															pELEMENT_TYPE *, pELEMENT_TYPE)), \
													CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
															pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
													CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
															pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
													pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getEntry( \
															&tIterator), \
													pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
															pELEMENT_TYPE, pNode, pThis, \
															tImaginaryIndex - 1)); \
										} \
	\
										tIsFound = true; \
									} \
	\
									pMEMBER_FUNCTIONS_PREFIX ## iterator_destruct(&tIterator); \
								) \
								( \
									CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
									pFUNC_ELEMENT_DESTRUCTOR(pINTERNAL__GET_ELEMENT( \
											pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
											tImaginaryIndex - 1));, ) \
	\
									CRXM__IFELSE2(pIS_PERSISTANT, \
									free(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
											pELEMENT_TYPE, pNode, pThis, tImaginaryIndex - 1));, ) \
	\
									tIsFound = true; \
								) \
							) \
							( \
								/*NOTICE: EFFECTIVELY WE ARE TREATING TWO EQUAL INDICES AS IF THEY \
										ARE BYTE WISE EQUAL. THIS IS CONTRARY TO ALMOST EVERY \
										WHERE, IF NOT EVERY WHERE, ELSE IN THE CODE. IF OTHER \
										WORDS, WHEN THE TREE HAS AN INDEX WE DO NOT ATTEMPT TO \
										CHECK IF IT IS EXACTLY THE INDEX THAT IS CREATED FROM THE \
										ELEMENT THAT WE SHALL EVENTUALLY REMOVE FROM A LEAF. \
										INSTEAD, WE REASON THAT WHATEVER THAT INDEX IS IT MUST BE \
										EQUAL UNDER THE INDEX ORDERING TO THE ONE FOUND HERE, BUT \
										THIS EFFECTIVELY ASSUMES BYTE WISE EQUALITY ALSO.*/ \
	\
								CRXM__IFELSE(CRXM__NOT(pHAS_INDEX)) \
								( \
									CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
									( \
										CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_DESTRUCTOR, \
												pIS_TO_USE_DELEGATION), \
										pFUNC_ELEMENT_DESTRUCTOR(pINTERNAL__GET_ELEMENT( \
												pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
												tImaginaryIndex - 1));, ) \
									) \
									( \
										CRXM__IFELSE2(pIS_TO_USE_DELEGATION, \
										*(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
												pELEMENT_TYPE, pNode, pThis, \
												tImaginaryIndex - 1)) = NULL;, ) \
									) \
								)() \
	\
								tIsFound = true; \
							) \
						} \
	\
						if(tBranchToTake == 1) \
						{ \
							if(tIsFound) \
							{ \
								CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
								( \
									/*vKey = __KB_KEY(pGUIDE_TYPE, pNode)[tImaginaryIndex - 1];*/ \
									CRXM__IFELSE(pHAS_INDEX) \
									( \
										/*NOTE THAT THE NEXT NODE WE GO INTO IS tImaginaryIndex, \
												NOT tImaginaryIndex - 1. BUT BECAUSE \
												name__findExactEntry() WILL EXPECT THE \
												CURRENT CHILD NODE INDEX IN pIterator TO BE THE \
												KEY INDEX OF THE FOUND INDEX(GUIDE), WE PUSHED \
												tImaginaryIndex - 1 EARLIER INSTEAD. \
										*/ \
										pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPop( \
												pIterator); \
	\
										pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPush( \
												pIterator, pNode, tImaginaryIndex /*+ 1*/); \
	\
										tReturn = \
												pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
												pThis, 2, \
												*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
														pThis, tImaginaryIndex /*+ 1*/)), \
												pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, \
														pThis, tImaginaryIndex - 1), \
												pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
														pELEMENT_TYPE, pNode, pThis, \
														tImaginaryIndex - 1), \
												pIterator); \
									) \
									( \
										tReturn = \
												pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
												pThis, 2, \
												*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
														tImaginaryIndex /*+ 1*/)), \
												pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
														pELEMENT_TYPE, pNode, pThis, \
														tImaginaryIndex - 1)); \
									) \
	\
									/*return vKey;*/ \
								) \
								( \
									/*IT IS NOT IMPORTANT THAT THE VERY SAME ELEMENT THAT WE THE 
											INDEX FROM TO STORE IN THE INTERNAL NODE BE THE ONE
											FOUND. HENCE, WHEN pHAS_INDEX, NO SEARCHING FOR THE 
											EXACT ENTRY IS DONE.*/ \
	\
									CRXM__IFELSE(pHAS_INDEX) \
									( \
										pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
												pThis, 2, \
												*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
														pThis, tImaginaryIndex /*+ 1*/)), \
												pIndex__guide, pElement, \
												CRXM__IFELSE2(pIS_TO_USE_DELEGATION, \
														pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
														pNode, pThis, \
														tImaginaryIndex - 1), NULL)); \
									) \
									( \
										pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
												pThis, 2, \
												*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
														pThis, tImaginaryIndex /*+ 1*/)), \
												pElement, \
												CRXM__IFELSE2(pIS_TO_USE_DELEGATION, \
														pINTERNAL__GET_ELEMENT_ENTRY( \
														pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
														pThis, tImaginaryIndex - 1), NULL)); \
									) \
								) \
								/*vKey = __KB_KEY(pGUIDE_TYPE, pNode)[tImaginaryIndex - 1];*/ \
	\
								/*return vKey;*/ \
								CRXM__IFELSE2(pIS_PREEMPTIVE, \
								tIsDone = true;, ) \
							} \
							else \
								{tIsDone = true;} \
						} \
						else if(tBranchToTake == -1) \
						{ \
							CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
							( \
								if(tIsFound) \
								{ \
									if(tNumberOfKeysInLeftNode == 0) \
									{ \
										tNumberOfKeysInLeftNode = (*(pINTERNAL__GET_NODE( \
												pTREE_TYPE_NAME, pNode, pThis, \
												tImaginaryIndex - 1)))-> \
												gPrivate_numberOfEntries; \
									} \
	\
									CRXM__IFELSE(pHAS_INDEX) \
									( \
										tReturn = \
												pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
												pThis, 1, \
												*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
														pThis, tImaginaryIndex - 1)), \
												pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, \
														pThis, tImaginaryIndex - 1), \
												pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
														pELEMENT_TYPE, pNode, pThis, \
														tImaginaryIndex - 1), \
												pIterator); \
									) \
									( \
										tReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
												pThis, 1, \
												*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
														pThis, tImaginaryIndex - 1)), \
												pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
														pELEMENT_TYPE, pNode, \
														pThis, tImaginaryIndex - 1)); \
									) \
	\
									CRXM__IFELSE(pIS_PREEMPTIVE) \
									( \
										tIsDone = true; \
									) \
									( \
										/*WARNING: tImaginaryIndex HERE CHANGES ITS SEMANTICS*/ \
										tImaginaryIndex = tImaginaryIndex - 1; \
									) \
								} \
								else \
									{tIsDone = true;} \
							) \
							( \
								assert(false); \
							) \
						} \
						else \
						{ \
							CRXM__IFELSE(pIS_PREEMPTIVE) \
							( \
								assert(tBranchToTake == 0); \
	\
								/*THE FOLLOWING SHOULD ALWAYS BE TRUE IF I AM NOT WRONG, BUT \
										STICKING TO REFERENCE FOR NOW*/ \
								if((tNumberOfKeysInLeftNode == \
												pThis->gPrviate_countOfMidElementInNode - 1) && \
										(tNumberOfKeysInRightNode == \
												pThis->gPrviate_countOfMidElementInNode - 1)) \
								{ \
									pTREE_TYPE_NAME ## _Private_Node * tNode__left = \
											pMEMBER_FUNCTIONS_PREFIX ## mergeTwoNodesAndGetRemainingNode( \
											pThis, pNode, tImaginaryIndex - 1); \
	\
									/*return pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
											pMode, pThis, tNode__left, pKey)*/ \
									CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
									( \
										CRXM__IFELSE(pHAS_INDEX) \
										( \
											tReturn = \
													pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
													pThis, 0 /*pMode*/, tNode__left, pIndex__guide, \
													pElement, pIterator); \
										) \
										( \
											tReturn = \
													pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
													pThis, 0 /*pMode*/, tNode__left, pElement); \
										) \
									) \
									( \
										CRXM__IFELSE(pHAS_INDEX) \
										( \
											tReturn = \
													pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
													pThis, 0 /*pMode*/, tNode__left, pIndex__guide, \
													pElement, pIndex__out); \
										) \
										( \
											tReturn = \
													pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
													pThis, 0 /*pMode*/, tNode__left, pElement, \
													pElement__out); \
										) \
									) \
	\
									tIsDone = true; \
								} \
								else \
									{assert(false);} \
							)() \
						} \
	\
						CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
								pHAS_INDEX), \
						pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPop(pIterator);, ) \
					} \
					CRX_SCOPE_END \
				} \
				else \
				{ \
					CRXM__IFELSE(CRXM__NOT(pIS_PREEMPTIVE)) \
					( \
						CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
						( \
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPush(pIterator, \
										pNode, tImaginaryIndex /*+ 1*/); \
	\
								tReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
										pThis, pMode, \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
												tImaginaryIndex /*+ 1*/)), \
										pIndex__guide, pElement, pIterator); \
	\
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPop(pIterator); \
							) \
							( \
								tReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
										pThis, pMode, \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
												tImaginaryIndex /*+ 1*/)), \
										pElement); \
							) \
						) \
						( \
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								tReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
										pThis, pMode, \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
												tImaginaryIndex /*+ 1*/)), \
										pIndex__guide, pElement, pIndex__out); \
							) \
							( \
								tReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
										pThis, pMode, \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
												tImaginaryIndex /*+ 1*/)), \
										pElement, pElement__out); \
							) \
						) \
					)() \
				} \
	\
				if(!tIsDone) \
				{ \
					/*TO EASE ANALYSIS, 
						- REMEMBER THAT tNode BELOW IS ALWAYS THE NODE TO THE RIGHT \
								OF THE 'FOUND' ENTRY POSITION. THE ONLY EXCEPTION IS WHEN THE \
								ALGORITHM IS NOT PRE EMPTIVE, AND THE ELEMENT HAS ALREADY BEEN \
								FOUND ABOVE, AND ENTRIES ARE NOT STORED IN THE LEAVES ONLY AND THE \
								ALGORITHM ABOVE CHOOSE TO TAKE THE LEFT BRANCH TO HOIST AN ELEMENT \
								BACK UP. \
						- IF pIS_PREEMPTIVE AND (pMode == 0) AND \
								(tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0) \
								WE SHOULD NOT BE HERE AT ALL. \
						- IF PRIMARY ENTRIES ARE NOT IN THE LEAVES ONLY, AND \
								(tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0) \
								IT IS GUARANTEED THAT WE ARE AT THE END OF THE TRACE THAT IS IN \
								THE ITERATOR. IN OTHER WORDS, THE INDEX IN THE TRACE AT THAT \
								POINT, MEANING Iterator::Position::gIndex, IS THE INDEX OF THE \
								ELEMENT, AND NOT THE INDEX OF THE NEXT CHILD NODE AS IT IS \
								OTHERWISE. IF PRIMARY ENTRIES ARE IN THE LEAVES ONLY, THEN \
								REGARDLESS OF THE VALUE OF \
								tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode THE INDEX IN \
								THE TRACE THAT IS IN THE ITERATOR AT THAT POINT, MEANING \
								Iterator::Position::gIndex, IS THE INDEX OF THE NEXT NODE. \
					*/ \
	\
					pTREE_TYPE_NAME ## _Private_Node * tNode; \
	\
					/*WARNING: tImaginaryIndex CHANGES ITS SEMANTICS HERE. IN THE NON PREMTIVE \
							CASE, tImaginaryIndex WOULD HAVE ALREADY BEEN DECREMENTED ONCE IF THE \
							CODE ABOVE WENT DOWN THE LEFT NODE RELATIVE TO THE FOUND RECORD. \
							AFTER THE FOLLOWING, tImaginaryIndex IS GUARANTEED TO BE THE INDEX OF \
							THE NODE THAT WILL BE TAKEN NEXT, IN THE PRE EMPTIVE CASE, OR \
							HAS BEEN TAKEN IN THE NON PRE EMPTIVE CASE.
					*/ \
					/*i++;*/ \
	\
					tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
							tImaginaryIndex)); \
	\
					/*WE HAVE TO USE '<=' INSTEAD OF '==' BECAUSE WE COULD BE FIXING UNDER FILLED 
							NODES AFTER THE FACT, MEANING THE ALGORITHM IS NOT PRE EMPTIVE.*/ \
					if(tNode->gPrivate_numberOfEntries <= \
							pThis->gPrviate_countOfMidElementInNode - 1) \
					{ \
						assert(tNode->gPrivate_numberOfEntries >= \
								pThis->gPrviate_countOfMidElementInNode - 2); \
	\
						/*NOTE THAT 'PREVIOUS' AND 'NEXT' AND SIMILAR ARE RELATIVE TO THE \
								KEY "FOUND" BY private_getSuitableImagineryIndexFor(), WHICH, AFTER \
								tImaginaryIndex CHANGED ITS SEMANTICS ABOVE, IS AT INDEX \
								tImaginaryIndex - 1 IN THE PREEMPTIVE CASE. \
								IN THE NON PREEMPTIVE CASE, tImaginaryIndex, BEFORE THE CHANGE OF \
								SEMANTICS ABOVE, IS EITHER THE INDEX OF THE KEY "FOUND" + 1, OR \
								THE INDEX OF THE KEY BEFORE THE BRANCH THAT IS TAKEN TO HOIST AN \
								ELEMENT BACK  UP TO WHERE THE KEY WAS ALREADY FOUND + 1, AND HENCE, 
								'PREVIOUS' AND 'NEXT' ARE SIMPLY RELATIVE TO THE KEY AT \
								tImaginaryIndex - 1 WHICH IS NOT NECESSARILY THE INDEX OF THE KEY \
								FOUND OR "FOUND" \
						*/ \
						if((tImaginaryIndex > 0) && \
								((*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
										tImaginaryIndex - 1)))->gPrivate_numberOfEntries >= \
										pThis->gPrviate_countOfMidElementInNode)) \
						{ \
							/*ROTATE PREVIOUS CHILD NODE'S LAST KEY AND KEY AND NEXT \
									CHILD NODE'S FIRST KEY RIGHT */ \
							pMEMBER_FUNCTIONS_PREFIX ## private_rotateRight(pThis, \
									(*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
											tImaginaryIndex - 1))), \
									tImaginaryIndex - 1, pNode, tNode); \
						} \
						else if((tImaginaryIndex < pNode->gPrivate_numberOfEntries) && \
								((*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
										tImaginaryIndex + 1)))->gPrivate_numberOfEntries >= \
										pThis->gPrviate_countOfMidElementInNode)) \
						{ \
							/*ROTATE NEXT CHILD NODE'S LAST KEY AND PARENT NODE'S NEXT KEY AND 
									NEXT NEXT CHILD NODE'S FIRST KEY LEFT*/ \
							pMEMBER_FUNCTIONS_PREFIX ## private_rotateLeft(pThis, \
									(*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
											tImaginaryIndex + 1))), \
									tImaginaryIndex + 1, pNode, tNode); \
						} \
						else if((tImaginaryIndex > 0) && \
								((*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
										tImaginaryIndex - 1)))->gPrivate_numberOfEntries == \
								pThis->gPrviate_countOfMidElementInNode - 1)) \
						{ \
							/*MERGE PREVIOUS CHILD NODE, KEY, AND NEXT CHILD NODE*/ \
							tNode = pMEMBER_FUNCTIONS_PREFIX ## mergeTwoNodesAndGetRemainingNode( \
									pThis, pNode, tImaginaryIndex - 1); \
	\
							tImaginaryIndex = tImaginaryIndex - 1; \
						} \
						else if((tImaginaryIndex < pNode->gPrivate_numberOfEntries) && \
								((*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis, \
										tImaginaryIndex + 1)))->gPrivate_numberOfEntries == \
								pThis->gPrviate_countOfMidElementInNode - 1)) \
						{ \
							/*MERGE NEXT CHILD NODE, NEXT KEY, AND NEXT NEXT CHILD NODE*/ \
							tNode = pMEMBER_FUNCTIONS_PREFIX ## mergeTwoNodesAndGetRemainingNode( \
									pThis, pNode, tImaginaryIndex); \
						} \
					} \
	\
					/* \
						NOTE THAT THE CODE ABOVE TAKES CARE OF THE IREGULAR SITUATION OF A NODE \
						HAVING NO KEYS, MAKING gPrivate_numberOfEntries == 0, WHILE STILL \
						HAVING ONE NODE. IN THE PREEMPTIVE CASE, THIS HAPPENS WHEN THERE IS ONE \
						LEAF REMAINIG, AND THAT WOULD MEAN ONE INTERNAL NODE REMAINING, AND THAT \
						WOULD BE THE ROOT NODE. THAT INTERNAL NODE WOULD HAVE A SINGLE CHILD NODE, \
						THE LEAF, AND NO KEYS. IN THE NON PRE EMPTIVE CASE, THIS HAPPENS BECAUSE \
						WE ONLY CHECK THE NODES ON THE WAY BACK UP TO MAKE SURE THAT THEY ARE NOT \
						TOO EMPTY, AND 'N', SEE NOTES ABOVE, COULD BE 2, WHICH MEANS N - 1, THE \
						MINIMAL ALLOWED LENGTH OF A NODE COULD BE 1, WHICH MEANS THAT IF A MERGER 
						HAPPENS ON THE WAY DOWN THE LENGTH COULD BECOME 0, AND THE CODE ABOVE \
						WOULD OBSERVE '0' THAT ON THE WAY UP. \
					*/ \
					/*return pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do(pMode, pThis, \
							tNode, pKey); */ \
					CRXM__IFELSE(pIS_PREEMPTIVE) \
					( \
						CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
						( \
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPush( \
										pIterator, pNode, tImaginaryIndex); \
	\
								tReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
										pThis, pMode, tNode, pIndex__guide, pElement, pIterator); \
	\
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPop(pIterator); \
							) \
							( \
								tReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
										pThis, pMode, tNode, pElement); \
							) \
						) \
						( \
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								tReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
										pThis, pMode, tNode, pIndex__guide, pElement, \
										pIndex__out); \
							) \
							( \
								tReturn = pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do( \
										pThis, pMode, tNode, pElement, pElement__out); \
							) \
						) \
					)() \
				} \
	\
				return tReturn; \
			} \
			else \
			{ \
				bool tIsFound = false; \
	\
				/*vKey = __KB_KEY(pGUIDE_TYPE, pNode)[tImaginaryIndex - 1];*/ \
				CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
				( \
					if((tImaginaryIndex > 0 /*>=*/) && \
							(tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0)) \
					{ \
						if(pMode != 0) \
						{ \
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
								( \
									CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT(sizeof(pINDEX_TYPE), \
											pFUNC_INDEX_MOVE_CONSTRUCTOR, \
											pFUNC_INDEX_MOVE_DESTRUCTOR, pIndex__guide, \
											pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, \
											pThis, tImaginaryIndex - 1)); \
								) \
								( \
									pCONSTRUCT_INDEX_FROM(pIndex__guide, \
											pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode, pThis, tImaginaryIndex - 1)); \
								) \
							)() \
	\
							CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
									sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
											pELEMENT_TYPE)), \
									CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
											pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
									CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
											pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
									pElement, \
									pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode, pThis, tImaginaryIndex - 1)); \
	\
							tIsFound = true; \
						} \
						else \
						{ \
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								pTREE_TYPE_NAME ## _Iterator tIterator /*= ?*/; \
								unsigned char * tPositions /*= ?*/; \
								uint32_t tResult = 0; \
	\
								/*THIS IS FORMAL VIOLATION. THIS IS DONE BECAUSE WE CAN NOT \
								GUARANTEE WHEN THE ALLOCATION OF THE LARGE BUFFER HAPPENS \
								ON THE STACK, AND IT MIGHT END UP HAPPENING IN EVERY \
								ITERATION*/ \
								tPositions = ((unsigned char *) CRX__ALLOCA(sizeof( \
										pTREE_TYPE_NAME ## _Iterator_Private_Position) * 64)); \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_construct3( \
										&tIterator, \
										((pTREE_TYPE_NAME ## _Iterator_Private_Position *) \
												tPositions), \
										pThis); \
	\
								CRXM__IFELSE2(pHAS_INDEX, \
										pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPush( \
										pIterator, pNode, tImaginaryIndex - 1);, ) \
								tResult = \
										pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do__findExactEntry( \
										pThis, pIndex__guide, pElement, pIterator, &tIterator); \
								CRXM__IFELSE2(pHAS_INDEX, \
										pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPop( \
										pIterator);, ) \
	\
								if(tResult != 0) \
								{ \
									if(tResult == 1) \
									{ \
										CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
										pFUNC_ELEMENT_DESTRUCTOR(pLEAF__GET_ELEMENT( \
												pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
												tImaginaryIndex - 1));, ) \
	\
										CRXM__IFELSE2(pIS_PERSISTANT, \
										free(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
												pELEMENT_TYPE, pNode, pThis, \
												tImaginaryIndex - 1));, ) \
									} \
									else \
									{ \
										CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
										pFUNC_ELEMENT_DESTRUCTOR( \
												pMEMBER_FUNCTIONS_PREFIX ## iterator_get( \
												&tIterator));, ) \
	\
										CRXM__IFELSE2(pIS_PERSISTANT, \
										free(pMEMBER_FUNCTIONS_PREFIX ## iterator_get( \
												&tIterator));, ) \
	\
										CRXM__IFELSE2(CRXM__NOT( \
												pARE_INDICES_IN_INTERNAL_NODES_ONLY), \
										CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
												sizeof(pINDEX_TYPE), \
												pFUNC_INDEX_MOVE_CONSTRUCTOR, \
												pFUNC_INDEX_MOVE_DESTRUCTOR, \
												pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getIndex( \
														&tIterator), \
												pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
														tImaginaryIndex - 1));, ) \
	\
										CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
												sizeof(CRXM__IFELSE2(pIS_PERSISTANT, \
														pELEMENT_TYPE *, pELEMENT_TYPE)), \
												CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
														pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
												CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
														pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
												pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getEntry( \
														&tIterator), \
												pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
														pELEMENT_TYPE, pNode, pThis, \
														tImaginaryIndex - 1)); \
									} \
	\
									tIsFound = true; \
								} \
	\
								pMEMBER_FUNCTIONS_PREFIX ## iterator_destruct(&tIterator); \
							) \
							( \
								CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
								pFUNC_ELEMENT_DESTRUCTOR(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
										pELEMENT_TYPE, pNode, pThis, tImaginaryIndex - 1));, ) \
	\
								CRXM__IFELSE2(pIS_PERSISTANT, \
								free(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
										pThis, tImaginaryIndex - 1));, ) \
	\
								tIsFound = true; \
							) \
						} \
	\
						if(tIsFound) \
						{ \
							CRXM__IFELSE2(pIS_TO_USE_RINGS, \
							bool tIsToRotateRight = \
									((pNode->gPrivate_numberOfEntries >> 1) > \
									(tImaginaryIndex - 1));, ) \
	\
							CRXM__IFELSE(CRXM__AND(pHAS_INDEX, \
									CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY))) \
							( \
								CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
										pINDEX_TYPE, \
										pFUNC_INDEX_MOVE_CONSTRUCTOR, \
										pFUNC_INDEX_MOVE_DESTRUCTOR, \
										2 * pThis->gPrviate_countOfMidElementInNode, \
										pNode, \
										pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 0), \
										pNode->gPrivate_numberOfEntries, \
										tImaginaryIndex - 1, 1, tIsToRotateRight) \
							)() \
	\
							CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
									CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
											pELEMENT_TYPE), \
									CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
											pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
									CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
											pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
									2 * pThis->gPrviate_countOfMidElementInNode, \
									pNode, \
									pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode, pThis, 0), \
									pNode->gPrivate_numberOfEntries, \
									tImaginaryIndex - 1, 1, tIsToRotateRight) \
	\
							CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_REMOVAL_OF_SPACE(pIS_TO_USE_RINGS, \
									2 * pThis->gPrviate_countOfMidElementInNode, pNode, 1, \
									tIsToRotateRight); \
						} \
					} \
				) \
				( \
					if((tImaginaryIndex > 0 /*>=*/) && \
							(tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0)) \
					{ \
						CRXM__IFELSE(pHAS_INDEX) \
						( \
							pTREE_TYPE_NAME ## _Private_Node * tNode = pNode; \
							size_t tIndex = tImaginaryIndex - 1; \
							/*REMEMBER: THE FOLLOWING IS FORMALLY INCORRECT. ALLOCA MUST APPEAR
									AT THE TOP LEVEL SCOPE OF THE FUNCTION. BUT THINGS KEPT THIS
									WAY FOR PERFORMANCE FOR THE TIME BEING.*/ \
							CRXM__IFELSE2(pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
							unsigned char * tIndex__guide = ((unsigned char *)CRX__ALLOCA( \
									sizeof(pINDEX_TYPE)));, ) \
							bool tIsToSwap = false; \
	\
							if(pCOMPARE_ELEMENTS(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
									pELEMENT_TYPE, pNode, pThis, tImaginaryIndex - 1), \
									pElement) == 0) \
								{tIsFound = true;} \
	\
							if(!tIsFound) \
							{ \
								pTREE_TYPE_NAME ## _Private_Node * tNode2 = tNode; \
								size_t tIndex2 = tIndex; \
								int32_t tOrderOfIndices = 0; \
	\
								if(tIndex2 < (tNode2->gPrivate_numberOfEntries - 1)) \
									{tIndex2 = tIndex2 + 1;} \
								else \
								{ \
									tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
											tNode)->gPrivate_leafNode__next->gPrivate_node); \
	\
									tIndex2 = 0; \
								} \
	\
								if(tNode2 != NULL) \
								{ \
									CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
									( \
										pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
												pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
												pELEMENT_TYPE, tNode2, pThis, tIndex2)); \
	\
										tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
												((pINDEX_TYPE *)tIndex__guide)); \
									) \
									( \
										tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
												pLEAF__GET_INDEX(pTREE_TYPE_NAME, tNode2, \
												pThis, tIndex2)); \
									) \
								} \
	\
								while(tOrderOfIndices == 0) \
								{ \
									if(pCOMPARE_ELEMENTS(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
											pELEMENT_TYPE, tNode2, pThis, tIndex2), \
											pElement) == 0) \
									{ \
										tIsFound = true; \
										tIsToSwap = true; \
										break; \
									} \
									else \
									{ \
										tNode = tNode2; \
										tIndex = tIndex2; \
	\
										if(tIndex2 < (tNode2->gPrivate_numberOfEntries - 1)) \
											{tIndex2 = tIndex2 + 1;} \
										else \
										{ \
											tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
													tNode)->gPrivate_leafNode__next->gPrivate_node); \
											tIndex2 = 0; \
										} \
	\
										if(tNode2 != NULL) /*&& (tIndex2 < \
												tNode2->gPrivate_numberOfEntries)*/ \
										{ \
											CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
											( \
												pCONSTRUCT_INDEX_FROM( \
														((pINDEX_TYPE *)tIndex__guide), \
														pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
														pELEMENT_TYPE, tNode2, pThis, \
														tIndex2)); \
	\
												tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
														((pINDEX_TYPE *)tIndex__guide)); \
											) \
											( \
												tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
														pLEAF__GET_INDEX(pTREE_TYPE_NAME, tNode2, \
														pThis, tIndex2)); \
											) \
										} \
										else \
											{break;} \
									} \
								} \
							} \
	\
							if(!tIsFound) \
							{ \
								pTREE_TYPE_NAME ## _Private_Node * tNode2 = pNode; \
								size_t tIndex2 = tImaginaryIndex - 1; \
								int32_t tOrderOfIndices = -1; \
	\
								tNode = pNode; \
								tIndex = tImaginaryIndex - 1; \
	\
								if(tIndex2 > 0) \
									{tIndex2 = tIndex2 - 1;} \
								else \
								{ \
									tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
											tNode)->gPrivate_leafNode__prev->gPrivate_node); \
	\
									tIndex2 = ((tNode2 != NULL) ? \
											(tNode2->gPrivate_numberOfEntries - 1) : 0); \
								} \
	\
								if(tNode2 != NULL) \
								{ \
									CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
									( \
										pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
												pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
												pELEMENT_TYPE, tNode2, pThis, \
												tIndex2)); \
	\
										tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
												((pINDEX_TYPE *)tIndex__guide)); \
									) \
									( \
										tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
												pLEAF__GET_INDEX(pTREE_TYPE_NAME, tNode2, \
												pThis, tIndex2)); \
									) \
								} \
	\
								while(tOrderOfIndices == 0) \
								{ \
									if(pCOMPARE_ELEMENTS(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
											pELEMENT_TYPE, tNode2, pThis, tIndex2), \
											pElement) == \
											0) \
									{ \
										tIsFound = true; \
										tIsToSwap = true; \
										break; \
									} \
									else \
									{ \
										tNode = tNode2; \
										tIndex = tIndex2; \
	\
										if(tIndex2 > 0) \
											{tIndex2 = tIndex2 - 1;} \
										else \
										{ \
											tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
													tNode)->gPrivate_leafNode__prev->gPrivate_node); \
											tIndex2 = ((tNode2 != NULL) ? \
													(tNode2->gPrivate_numberOfEntries - \
													1) : 0); \
										} \
	\
										if(tNode2 != NULL /*&& (tIndex2 >= 0)*/) \
										{ \
											CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
											( \
												pCONSTRUCT_INDEX_FROM( \
														((pINDEX_TYPE *)tIndex__guide), \
														pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
														pELEMENT_TYPE, tNode2, pThis, \
														tIndex2)); \
	\
												tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
														((pINDEX_TYPE *)tIndex__guide)); \
											) \
											( \
												tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
														pLEAF__GET_INDEX(pTREE_TYPE_NAME, tNode2, \
														pThis, tIndex2)); \
											) \
										} \
										else \
											{break;} \
									} \
								} \
							} \
	\
							if(tIsFound) \
							{ \
								CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
								pFUNC_ELEMENT_DESTRUCTOR(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
										pELEMENT_TYPE, tNode, pThis, tIndex));, ) \
	\
								CRXM__IFELSE2(pIS_PERSISTANT, \
								free(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, tNode, \
										pThis, tIndex));, ) \
	\
								if(tIsToSwap) \
								{ \
									CRXM__IFELSE2(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY), \
									CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
											sizeof(pINDEX_TYPE), \
											pFUNC_INDEX_MOVE_CONSTRUCTOR, \
											pFUNC_INDEX_MOVE_DESTRUCTOR, \
											pLEAF__GET_INDEX(pTREE_TYPE_NAME, tNode, pThis, \
													tIndex), \
											pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, \
													tImaginaryIndex - 1));, ) \
	\
									CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
											sizeof(CRXM__IFELSE2(pIS_PERSISTANT, \
													pELEMENT_TYPE *, pELEMENT_TYPE)), \
											CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
													pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
											CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
													pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
											pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, pNode, pThis, tIndex), \
											pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, pNode, pThis, \
													tImaginaryIndex - 1)); \
								} \
							} \
						) \
						( \
							CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
							pFUNC_ELEMENT_DESTRUCTOR(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
									pELEMENT_TYPE, pNode, pThis, tImaginaryIndex - 1));, ) \
	\
							CRXM__IFELSE2(pIS_PERSISTANT, \
							free(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
									pThis, tImaginaryIndex - 1));, ) \
	\
							tIsFound = true; \
						) \
	\
						if(tIsFound) \
						{ \
							CRXM__IFELSE2(pIS_TO_USE_RINGS, \
							bool tIsToRotateRight = \
									((pNode->gPrivate_numberOfEntries >> 1) > \
									(tImaginaryIndex - 1));, ) \
	\
							CRXM__IFELSE(CRXM__AND(pHAS_INDEX, \
									CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY))) \
							( \
								CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
										pINDEX_TYPE, \
										pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR, \
										2 * pThis->gPrviate_countOfMidElementInNode, \
										pNode, \
										pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 0), \
										pNode->gPrivate_numberOfEntries, \
										tImaginaryIndex - 1, 1, tIsToRotateRight) \
							)() \
	\
							CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
									CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
											pELEMENT_TYPE), \
									CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
											pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
									CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
											pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
									2 * pThis->gPrviate_countOfMidElementInNode, \
									pNode, \
									pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode, pThis, 0), \
									pNode->gPrivate_numberOfEntries, \
									tImaginaryIndex - 1, 1, tIsToRotateRight) \
	\
							CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_REMOVAL_OF_SPACE(pIS_TO_USE_RINGS, \
									2 * pThis->gPrviate_countOfMidElementInNode, pNode, 1, \
									tIsToRotateRight); \
	\
							CRXM__IFELSE(pIS_TO_USE_DELEGATION) \
							( \
								if(pMode != 0) \
								{ \
									/*WHEN USING DELEGATION, HOISTING IS REUIQRED, AND THEREFORE \
											SUCH TREES MUST HAVE N >= 3 AS TO KEEP THE FOLLOWING \
											ASSERTION TRUE. REMEMBER THAT IF N IS 2, AND THE \
											ALGORITHM IS NOT PRE EMPTIVE, pNode COULD NOW BE EMPTY \
											AFTER THE REMOVAL ABOVE, AND HENCE IT WOULD HAVE \
											NOTHING LEFT FOR HOISTING. \
									*/ \
									assert(pNode->gPrivate_numberOfEntries > 1); \
									/*WARNING: REMEMBER, THE LENGTH IS NOT YET UPDATED AT THIS POINT,
											HENCE THE '- 1'.*/ \
									if(pMode == 1) \
										{tImaginaryIndex = pNode->gPrivate_numberOfEntries - 1 /*2*/;} \
									else /*pMode == 2*/ \
										{tImaginaryIndex = 1 /*0*/;} \
	\
									CRXM__IFELSE(pHAS_INDEX) \
									( \
										CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
										( \
											memcpy(pIndex__out, \
													pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, \
															pThis, tImaginaryIndex - 1), \
													sizeof(pINDEX_TYPE)); \
										) \
										( \
											pCONSTRUCT_INDEX_FROM(pIndex__out, \
													pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
															pELEMENT_TYPE, pNode, pThis, \
															tImaginaryIndex - 1)); \
										) \
									) \
									( \
										CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
										( \
											CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
											( \
												pFUNC_ELEMENT_COPY_CONSTRUCTOR(pElement__out, \
														pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
																pELEMENT_TYPE, pNode, pThis, \
																tImaginaryIndex - 1)); \
											) \
											( \
												memcpy(pElement__out, \
														pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
																pELEMENT_TYPE, pNode, pThis, \
																tImaginaryIndex - 1), \
														sizeof(pELEMENT_TYPE)); \
											) \
										) \
										( \
											*pElement__out = pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, pNode, pThis, \
													tImaginaryIndex - 1); \
										) \
									) \
								} \
							)() \
						} \
						else \
							/*REMEMBER: WHEN ELEMENTS ARE ONLY IN LEAVES, INTERNAL NODES WOULD ONLY \
									HOLD INDICES OF ELEMENTS THAT EXIST IN THE LEAVES, OR COPIES OF \
									ELEMENT ENTRIES THAT EXIST IN THE LEAVES DEPENDING ON WHETHER AN \
									INDEX IS USED OR NOT. IN OTHER WORDS, IF pMode IS NOT 0, AN ENTRY \
									MUST BE FOUND IN THE LEAVES. \
									NOTE THAT THIS WAS NECESSARY WHEN THE ALGORITHM CONTINUED TO DO A \
									BINARY SEARCH IN THAT CASE WHEN MODE WAS NOT ZERO. LATER I CHANED \
									THAT, BUT KEEPING THE CODE BELOW FOR THE TIME BEING. \
							*/ \
							{assert(pMode == 0);} \
					} \
					else \
						/*REMEMBER: WHEN ELEMENTS ARE ONLY IN LEAVES, INTERNAL NODES WOULD ONLY \
								HOLD INDICES OF ELEMENTS THAT EXIST IN THE LEAVES, OR COPIES OF \
								ELEMENT ENTRIES THAT EXIST IN THE LEAVES DEPENDING ON WHETHER AN \
								INDEX IS USED OR NOT. IN OTHER WORDS, IF pMode IS NOT 0, AN ENTRY \
								MUST BE FOUND IN THE LEAVES. \
								NOTE THAT THIS WAS NECESSARY WHEN THE ALGORITHM CONTINUED TO DO A \
								BINARY SEARCH IN THAT CASE WHEN MODE WAS NOT ZERO. LATER I CHANED \
								THAT, BUT KEEPING THE CODE BELOW FOR THE TIME BEING. \
						*/ \
						{assert(pMode == 0);} \
				) \
	\
				if(tIsFound) \
					{--(pNode->gPrivate_numberOfEntries);} \
	\
				/*return vKey;*/ \
				return tIsFound; \
			} \
		} \
		else \
			{return false;} \
	} \
	CRXM__IFELSE2(CRXM__AND(pHAS_INDEX, CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)), \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE uint32_t /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do__findExactEntry( \
			pTREE_TYPE_NAME * pThis, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE const * pElement, \
			pTREE_TYPE_NAME ## _Iterator const * pIterator, \
			pTREE_TYPE_NAME ## _Iterator * pIterator__return), \
	PRIVATE uint32_t /*pGUIDE_TYPE*/ pMEMBER_FUNCTIONS_PREFIX ## private_removeElement__do__findExactEntry( \
			pTREE_TYPE_NAME * pThis, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE * * pElement, \
			pTREE_TYPE_NAME ## _Iterator const * pIterator, \
			pTREE_TYPE_NAME ## _Iterator * pIterator__return)) \
	{ \
		pELEMENT_TYPE const * vElement = CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), pElement, \
				*pElement); \
		CRXM__IFELSE2(pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
		unsigned char * vIndex__guide = ((unsigned char *)CRX__ALLOCA( \
				sizeof(pINDEX_TYPE)));, ) \
		bool tIsFound = false; \
		bool tIsToSwap = false; \
	\
		if(pCOMPARE_ELEMENTS(pMEMBER_FUNCTIONS_PREFIX ## iterator_get(pIterator), vElement) == 0) \
			{tIsFound = true;} \
	\
		if(!tIsFound) \
		{ \
			pMEMBER_FUNCTIONS_PREFIX ## iterator_copyAssignFrom(pIterator__return, \
					pIterator); \
	\
			while(true) \
			{ \
				if(pMEMBER_FUNCTIONS_PREFIX ## iterator_next(pIterator__return)) \
				{ \
					int32_t tOrderOfIndices /*= ?*/; \
	\
					CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
					( \
						if(CRXM__IFELSE2(pIS_PREEMPTIVE, \
								pIterator__return->gPrivate_position__current->gNode, \
								pIterator__return->gPrivate_node)->gPrivate_type) \
						{ \
							memcpy(vIndex__guide, \
									pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getIndex( \
									pIterator__return), sizeof(pINDEX_TYPE)); \
						} \
						else \
						{ \
							pCONSTRUCT_INDEX_FROM( \
									((pINDEX_TYPE *)vIndex__guide), \
									pMEMBER_FUNCTIONS_PREFIX ## iterator_get( \
									pIterator__return)); \
						} \
	\
						tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
								((pINDEX_TYPE *)vIndex__guide)); \
					) \
					( \
						tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getIndex( \
								pIterator__return)); \
					) \
	\
					if(tOrderOfIndices == 0) \
					{ \
						if(pCOMPARE_ELEMENTS( \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_get( \
								pIterator__return), vElement) == 0) \
						{ \
							tIsFound = true; \
							tIsToSwap = true; \
							break; \
						} \
					} \
					else \
						{break;} \
				} \
				else \
					{break;} \
			} \
		} \
	\
		if(!tIsFound) \
		{ \
			pMEMBER_FUNCTIONS_PREFIX ## iterator_copyAssignFrom(pIterator__return, \
					pIterator); \
	\
			while(true) \
			{ \
				if(pMEMBER_FUNCTIONS_PREFIX ## iterator_prev(pIterator__return)) \
				{ \
					int32_t tOrderOfIndices /*= ?*/; \
	\
					CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
					( \
						if(CRXM__IFELSE2(pIS_PREEMPTIVE, pIterator__return->gPrivate_position__current->gNode, \
								pIterator__return->gPrivate_node)->gPrivate_type) \
						{ \
							memcpy(vIndex__guide, \
									pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getIndex( \
									pIterator__return), sizeof(pINDEX_TYPE)); \
						} \
						else \
						{ \
							pCONSTRUCT_INDEX_FROM( \
									((pINDEX_TYPE *)vIndex__guide), \
									pMEMBER_FUNCTIONS_PREFIX ## iterator_get( \
									pIterator__return)); \
						} \
	\
						tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
								((pINDEX_TYPE *)vIndex__guide)); \
					) \
					( \
						tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getIndex( \
								pIterator__return)); \
					) \
	\
					if(tOrderOfIndices == 0) \
					{ \
						if(pCOMPARE_ELEMENTS( \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_get( \
								pIterator__return), vElement) == 0) \
						{ \
							tIsFound = true; \
							tIsToSwap = true; \
							break; \
						} \
					} \
					else \
						{break;} \
				} \
				else \
					{break;} \
			} \
		} \
	\
		if(tIsFound) \
		{ \
			if(tIsToSwap) \
				{return 2;} \
			else \
				{return 1;} \
		} \
		else \
			{return 0;} \
	}, ) \
	\
	CRXM__IFELSE2(CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, CRXM__NOT(pIS_PREEMPTIVE)), \
	PRIVATE size_t pMEMBER_FUNCTIONS_PREFIX ## private_findChildNodeIndexInParent( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode) \
	{ \
		CRX_SCOPE_META \
		if(pNode->gPrivate_node__parent == NULL) \
			{return ((size_t)(-1));} \
	\
		CRX_SCOPE \
		size_t vIndex = ((size_t)(-1)); \
		bool vIsFound = false; \
	\
		if(pNode->gPrivate_type) \
		{ \
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				int32_t tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 0; \
				pTREE_TYPE_NAME ## _Private_Node * tNode = NULL; \
	\
				vIndex = pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
						pThis, pNode->gPrivate_node__parent, \
						pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 0), \
						&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode) /*+ 1*/; \
	\
				/*if((vIndex > 0) && \
						(tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0)) \
					{vIndex++;}*/ \
	\
				tNode = *(pINTERNAL__GET_NODE( \
						pTREE_TYPE_NAME, pNode->gPrivate_node__parent, pThis, vIndex)); \
	\
				if(CRX__ARE_POINTERS_TO_SAME_OBJECT(tNode, pNode, false)) \
					{vIsFound = true;} \
	\
				if(!vIsFound) \
				{ \
					/*NEED TO REWIND TO FIND FIRST*/ \
					pTREE_TYPE_NAME ## _Private_Node * tNode2 = \
							&(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
							gPrivate_leafNode__prev->gPrivate_node); \
					size_t tIndex = vIndex; \
	\
					while(tNode2 != NULL) \
					{ \
						if(!CRX__ARE_POINTERS_TO_SAME_OBJECT( \
								pNode->gPrivate_node__parent, \
								tNode2->gPrivate_node__parent, false) || \
								(tIndex == 0)) \
							{break;} \
	\
						tIndex = tIndex - 1; \
	\
						if((pCOMPARE_INDICES(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, \
								pThis, 0), \
								pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, tNode2, \
								pThis, 0)) == 0) && \
								CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, tNode2, false)) \
						{ \
							vIndex = tIndex; \
							vIsFound = true; \
	\
							break; \
						} \
						else \
						{ \
							tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode2)-> \
									gPrivate_leafNode__prev->gPrivate_node); \
						} \
					} \
				} \
	\
				if(!vIsFound) \
				{ \
					/*NEED TO FARWARD TO FIND LAST*/ \
					pTREE_TYPE_NAME ## _Private_Node * tNode2 = \
							&(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
							gPrivate_leafNode__next->gPrivate_node); \
					size_t tIndex = vIndex; \
					int32_t tOrderOfIndices = -1; \
	\
					while(tNode2 != NULL) \
					{ \
						if(!CRX__ARE_POINTERS_TO_SAME_OBJECT( \
								pNode->gPrivate_node__parent, \
								tNode2->gPrivate_node__parent, false) || \
								(tIndex == (pNode->gPrivate_node__parent-> \
										gPrivate_numberOfEntries + 1))) \
							{break;} \
	\
						tIndex = tIndex + 1; \
	\
						if((pCOMPARE_INDICES(pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, \
								pThis, 0), \
								pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, tNode2, \
								pThis, 0)) == 0) && \
								CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, tNode2, false)) \
						{ \
							vIndex = tIndex; \
							vIsFound = true; \
	\
							break; \
						} \
						else \
						{ \
							tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode2)-> \
									gPrivate_leafNode__next->gPrivate_node); \
						} \
					} \
				} \
			) \
			( \
				int32_t tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 0; \
				pTREE_TYPE_NAME ## _Private_Node * tNode = NULL; \
	\
				vIndex = pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
						pThis, pNode->gPrivate_node__parent, \
						pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, 0), \
						&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode) /*+ 1*/; \
	\
				/*if((vIndex > 0) && \
						(tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0)) \
					{vIndex++;}*/ \
	\
				tNode = *(pINTERNAL__GET_NODE( \
						pTREE_TYPE_NAME, pNode->gPrivate_node__parent, pThis, vIndex)); \
	\
				if(CRX__ARE_POINTERS_TO_SAME_OBJECT(tNode, pNode, false)) \
					{vIsFound = true;} \
	\
				if(!vIsFound) \
				{ \
					/*NEED TO REWIND TO FIND FIRST*/ \
					pTREE_TYPE_NAME ## _Private_Node * tNode2 = \
							&(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
							gPrivate_leafNode__prev->gPrivate_node); \
					size_t tIndex = vIndex; \
	\
					while(tNode2 != NULL) \
					{ \
						if(!CRX__ARE_POINTERS_TO_SAME_OBJECT( \
								pNode->gPrivate_node__parent, \
								tNode2->gPrivate_node__parent, false) || \
								(tIndex == 0)) \
							{break;} \
	\
						tIndex = tIndex - 1; \
	\
						if((pCOMPARE_ELEMENTS(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
								pELEMENT_TYPE, pNode, pThis, 0), \
								pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, tNode2, \
								pThis, 0)) == 0) && \
								CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, tNode2, false)) \
						{ \
							vIndex = tIndex; \
							vIsFound = true; \
	\
							break; \
						} \
						else \
						{ \
							tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode2)-> \
									gPrivate_leafNode__prev->gPrivate_node); \
						} \
					} \
				} \
	\
				if(!vIsFound) \
				{ \
					/*NEED TO FARWARD TO FIND LAST*/ \
					pTREE_TYPE_NAME ## _Private_Node * tNode2 = \
							&(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
							gPrivate_leafNode__next->gPrivate_node); \
					size_t tIndex = vIndex; \
	\
					while(tNode2 != NULL) \
					{ \
						if(!CRX__ARE_POINTERS_TO_SAME_OBJECT( \
								pNode->gPrivate_node__parent, \
								tNode2->gPrivate_node__parent, false) || \
								(tIndex == (pNode->gPrivate_node__parent-> \
										gPrivate_numberOfEntries + 1))) \
							{break;} \
	\
						tIndex = tIndex + 1; \
	\
						if((pCOMPARE_ELEMENTS(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
								pELEMENT_TYPE, pNode, pThis, 0), \
								pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, tNode2, \
								pThis, 0)) == 0) && \
								CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, tNode2, false)) \
						{ \
							vIndex = tIndex; \
							vIsFound = true; \
	\
							break; \
						} \
						else \
						{ \
							tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode2)-> \
									gPrivate_leafNode__next->gPrivate_node); \
						} \
					} \
				} \
			) \
		} \
		else \
		{ \
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				int32_t tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 0; \
				CRXM__IFELSE2(pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
				unsigned char * tIndex__guide = ((unsigned char *)CRX__ALLOCA( \
						sizeof(pINDEX_TYPE)));, ) \
				CRXM__IFELSE2(pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
				unsigned char * tIndex__guide2 = ((unsigned char *)CRX__ALLOCA( \
						sizeof(pINDEX_TYPE)));, ) \
				pTREE_TYPE_NAME ## _Private_Node * tNode = NULL; \
	\
				CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
				( \
					pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
							pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, \
							0)); \
	\
					vIndex = pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
							pThis, pNode->gPrivate_node__parent, ((pINDEX_TYPE *)tIndex__guide), \
							&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode) /*+ 1*/; \
				) \
				( \
					vIndex = pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
							pThis, pNode->gPrivate_node__parent, \
							pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis, 0), \
							&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode) /*+ 1*/; \
				) \
	\
				/*if((vIndex > 0) && \
						(tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0)) \
					{vIndex++;}*/ \
	\
				tNode = *(pINTERNAL__GET_NODE( \
						pTREE_TYPE_NAME, pNode->gPrivate_node__parent, pThis, vIndex)); \
	\
				if(CRX__ARE_POINTERS_TO_SAME_OBJECT(tNode, pNode, false)) \
					{vIsFound = true;} \
	\
				if(!vIsFound) \
				{ \
					/*NEED TO REWIND TO FIND FIRST*/ \
					pTREE_TYPE_NAME ## _Private_Node * tNode2 = \
							&(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
							gPrivate_leafNode__prev->gPrivate_node); \
					size_t tIndex = vIndex; \
					int32_t tOrderOfIndices = -1; \
	\
					while(tNode2 != NULL) \
					{ \
						if(!CRX__ARE_POINTERS_TO_SAME_OBJECT( \
								pNode->gPrivate_node__parent, \
								tNode2->gPrivate_node__parent, false) || \
								(tIndex == 0)) \
							{break;} \
	\
						tIndex = tIndex - 1; \
	\
						CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
						( \
							pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide2), \
									pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
									pELEMENT_TYPE, tNode2, pThis, \
									0)); \
	\
							tOrderOfIndices = pCOMPARE_INDICES( \
									((pINDEX_TYPE *)tIndex__guide), \
									((pINDEX_TYPE *)tIndex__guide2)); \
						) \
						( \
							tOrderOfIndices = pCOMPARE_INDICES( \
									pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, \
									pThis, 0), \
									pLEAF__GET_INDEX(pTREE_TYPE_NAME, tNode2, \
									pThis, 0)); \
						) \
	\
						if((tOrderOfIndices == 0) && \
								CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, tNode2, false)) \
						{ \
							vIndex = tIndex; \
							vIsFound = true; \
	\
							break; \
						} \
						else \
						{ \
							tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode2)-> \
									gPrivate_leafNode__prev->gPrivate_node); \
						} \
					} \
				} \
	\
				if(!vIsFound) \
				{ \
					/*NEED TO FARWARD TO FIND LAST*/ \
					pTREE_TYPE_NAME ## _Private_Node * tNode2 = \
							&(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
							gPrivate_leafNode__next->gPrivate_node); \
					size_t tIndex = vIndex; \
					int32_t tOrderOfIndices = -1; \
	\
					while(tNode2 != NULL) \
					{ \
						if(!CRX__ARE_POINTERS_TO_SAME_OBJECT( \
								pNode->gPrivate_node__parent, \
								tNode2->gPrivate_node__parent, false) || \
								(tIndex == (pNode->gPrivate_node__parent-> \
										gPrivate_numberOfEntries + 1))) \
							{break;} \
	\
						tIndex = tIndex + 1; \
	\
						CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
						( \
							pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide2), \
									pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
									pELEMENT_TYPE, tNode2, pThis, \
									0)); \
	\
							tOrderOfIndices = pCOMPARE_INDICES( \
									((pINDEX_TYPE *)tIndex__guide), \
									((pINDEX_TYPE *)tIndex__guide2)); \
						) \
						( \
							tOrderOfIndices = pCOMPARE_INDICES( \
									pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, \
									pThis, 0), \
									pLEAF__GET_INDEX(pTREE_TYPE_NAME, tNode2, \
									pThis, 0)); \
						) \
	\
						if((tOrderOfIndices == 0) && \
								CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, tNode2, false)) \
						{ \
							vIndex = tIndex; \
							vIsFound = true; \
	\
							break; \
						} \
						else \
						{ \
							tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode2)-> \
									gPrivate_leafNode__next->gPrivate_node); \
						} \
					} \
				} \
			) \
			( \
				int32_t tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 0; \
				pTREE_TYPE_NAME ## _Private_Node * tNode = NULL; \
	\
				vIndex = pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
						pThis, pNode->gPrivate_node__parent, \
						pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, pThis, 0), \
						&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode) /*+ 1*/; \
	\
				/*if((vIndex > 0) && \
						(tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0)) \
					{vIndex++;}*/ \
	\
				tNode = *(pINTERNAL__GET_NODE( \
						pTREE_TYPE_NAME, pNode->gPrivate_node__parent, pThis, vIndex)); \
	\
				if(CRX__ARE_POINTERS_TO_SAME_OBJECT(tNode, pNode, false)) \
					{vIsFound = true;} \
	\
				if(!vIsFound) \
				{ \
					/*NEED TO REWIND TO FIND FIRST*/ \
					pTREE_TYPE_NAME ## _Private_Node * tNode2 = \
							&(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
							gPrivate_leafNode__prev->gPrivate_node); \
					size_t tIndex = vIndex; \
	\
					while(tNode2 != NULL) \
					{ \
						if(!CRX__ARE_POINTERS_TO_SAME_OBJECT( \
								pNode->gPrivate_node__parent, \
								tNode2->gPrivate_node__parent, false) || \
								(tIndex == 0)) \
							{break;} \
	\
						tIndex = tIndex - 1; \
	\
						if((pCOMPARE_ELEMENTS(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
								pELEMENT_TYPE, pNode, pThis, 0), \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, tNode2, \
								pThis, 0)) == 0) && \
								CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, tNode2, false)) \
						{ \
							vIndex = tIndex; \
							vIsFound = true; \
	\
							break; \
						} \
						else \
						{ \
							tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode2)-> \
									gPrivate_leafNode__prev->gPrivate_node); \
						} \
					} \
				} \
	\
				if(!vIsFound) \
				{ \
					/*NEED TO FARWARD TO FIND LAST*/ \
					pTREE_TYPE_NAME ## _Private_Node * tNode2 = \
							&(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
							gPrivate_leafNode__next->gPrivate_node); \
					size_t tIndex = vIndex; \
	\
					while(tNode2 != NULL) \
					{ \
						if(!CRX__ARE_POINTERS_TO_SAME_OBJECT( \
								pNode->gPrivate_node__parent, \
								tNode2->gPrivate_node__parent, false) || \
								(tIndex == (pNode->gPrivate_node__parent-> \
										gPrivate_numberOfEntries + 1))) \
							{break;} \
	\
						tIndex = tIndex + 1; \
	\
						if((pCOMPARE_ELEMENTS(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
								pELEMENT_TYPE, pNode, pThis, 0), \
								pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, tNode2, \
								pThis, 0)) == 0) && \
								CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, tNode2, false)) \
						{ \
							vIndex = tIndex; \
							vIsFound = true; \
	\
							break; \
						} \
						else \
						{ \
							tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode2)-> \
									gPrivate_leafNode__next->gPrivate_node); \
						} \
					} \
				} \
			) \
		} \
	\
		if(vIsFound) \
			{return vIndex;} \
		else \
			{return ((size_t)(-1));} \
		CRX_SCOPE_END \
	}, ) \
	\
	CRXM__IFELSE2(CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_PREEMPTIVE), \
	PRIVATE size_t pMEMBER_FUNCTIONS_PREFIX ## private_getTraceOfLeafNode( \
			pTREE_TYPE_NAME * pThis, pTREE_TYPE_NAME ## _Private_Node * CRX_NOT_NULL pNode, \
			pTREE_TYPE_NAME ## _Private_Node * * CRX_NOT_NULL pNodes, \
			size_t * CRX_NOT_NULL pIndices) \
	{ \
		assert(pNode->gPrivate_type == 0); \
	\
		pNodes[0] = NULL; \
		pIndices[0] = 0; \
	\
		if(pThis->gPrivate_node__root->gPrivate_type == 0) \
		{ \
			if(CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, pThis->gPrivate_node__root, false)) \
			{ \
				pNodes[1] = pThis->gPrivate_node__root; \
				pIndices[1] = 0; \
	\
				return 2; \
			} \
			else \
				{return 0;} \
		} \
		else \
		{ \
			pTREE_TYPE_NAME ## _Private_Node * tNode = pThis->gPrivate_node__root; \
			size_t tIndex = 0; \
			CRXM__IFELSE2(pHAS_INDEX, \
			unsigned char * tIndex__guide = CRXM__IFELSE2(pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
					((unsigned char *)CRX__ALLOCA(sizeof(pINDEX_TYPE))), NULL);, ) \
			CRXM__IFELSE2(CRXM__AND(pHAS_INDEX, pARE_INDICES_IN_INTERNAL_NODES_ONLY), \
			unsigned char * tIndex__guide2 = ((unsigned char *)CRX__ALLOCA( \
					sizeof(pINDEX_TYPE)));, ) \
			CRXM__IFELSE2(CRXM__NOT(pHAS_INDEX), \
			pELEMENT_TYPE const * tElement = pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
					pNode, pThis, 0);, ) \
			bool tIsFound = false; \
	\
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
				( \
					pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
							pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
							pELEMENT_TYPE, pNode, pThis, 0)); \
				) \
				( \
					tIndex__guide = ((unsigned char *)pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, \
							pThis, 0)); \
				) \
			)() \
	\
			while(tNode != NULL) \
			{ \
				int32_t tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 0; \
				size_t tImaginaryIndex = CRXM__IFELSE2(pHAS_INDEX, \
						pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
								pThis, tNode, ((pINDEX_TYPE *)tIndex__guide), \
								&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode), \
						pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
								pThis, tNode, tElement, \
								&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode)); \
	\
				if(tImaginaryIndex > 0 /*>=*/ && \
						tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0) \
				{ \
					if(tNode->gPrivate_type) \
					{ \
						tIndex++; \
						pNodes[tIndex] = tNode; \
						pIndices[tIndex] = tImaginaryIndex /*+ 1*/; \
	\
						tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, tNode, pThis, \
								tImaginaryIndex /*+ 1*/)); \
					} \
					else \
					{ \
						/*tIndexInLeaf = tImaginaryIndex - 1;*/ \
	\
						break; \
					} \
				} \
				else \
				{ \
					if(tNode->gPrivate_type) \
					{ \
						tIndex++; \
						pNodes[tIndex] = tNode; \
						pIndices[tIndex] = tImaginaryIndex /*+ 1*/; \
	\
						tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, tNode, pThis, \
								tImaginaryIndex /*+ 1*/)); \
					} \
					else \
					{ \
						/*tIndexInLeaf = ((size_t)(-1));*/ \
	\
						break; \
					} \
				} \
			} \
	\
			if(CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, \
					*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNodes[tIndex], pThis, \
							pIndices[tIndex])), false)) \
				{tIsFound = true;} \
\
			if(!tIsFound) \
			{ \
				size_t tIndex2 = tIndex; \
				bool tIsToSkipUp = false; \
				pTREE_TYPE_NAME ## _Private_Node * tNodes[64]; \
				size_t tIndices[64]; \
\
				memcpy(&(tNodes[0]), &(pNodes[0]), \
						(tIndex + 1) * sizeof(pTREE_TYPE_NAME ## _Private_Node *)); \
				memcpy(&(tIndices[0]), &(pIndices[0]), (tIndex + 1) * sizeof(size_t)); \
\
				while(!tIsFound) \
				{ \
					assert(tNodes[tIndex2]->gPrivate_type); \
\
					while(tNodes[tIndex2]) \
					{ \
						if(tIsToSkipUp || (tNodes[tIndex2]->gPrivate_type == 0)) \
						{ \
							tIsToSkipUp = false; \
\
							break; \
						} \
\
						tNodes[tIndex2 + 1] = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
								tNodes[tIndex2], pThis, tIndices[tIndex2])); \
						tIndices[tIndex2 + 1] = tNodes[tIndex2 + 1]-> \
								gPrivate_numberOfEntries; \
\
						tIndex2++; \
					} \
					tIndex2--; \
\
					/*THIS IS THE REASON 64 PER THE REFERENCE IMPLEMENTATION BECAME 65 HERE*/ \
					if(tIndex2 == 0) \
						{break;} \
					else if(tNodes[tIndex2]) \
					{ \
						if((*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, tNodes[tIndex2], pThis, \
								tIndices[tIndex2])))->gPrivate_type == 0) \
						{ \
							tIsFound = CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, \
									*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, tNodes[tIndex2], \
									pThis, tIndices[tIndex2])), false); \
						} \
\
						if(tIndices[tIndex2] > 0) \
							{(tIndices[tIndex2])--;} \
						else \
							{tIsToSkipUp = true;} \
					} \
				} \
\
				if(tIsFound) \
				{ \
					tIndex = tIndex2; \
\
					memcpy(&(pNodes[0]), &(tNodes[0]), \
							(tIndex + 1) * sizeof(pTREE_TYPE_NAME ## _Private_Node *)); \
					memcpy(&(pIndices[0]), &(tIndices[0]), (tIndex + 1) * sizeof(size_t)); \
				} \
			} \
\
			if(!tIsFound) \
			{ \
				size_t tIndex2 = tIndex; \
				bool tIsToSkipUp = false; \
				pTREE_TYPE_NAME ## _Private_Node * tNodes[64]; \
				size_t tIndices[64]; \
\
				memcpy(&(tNodes[0]), &(pNodes[0]), \
						(tIndex + 1) * sizeof(pTREE_TYPE_NAME ## _Private_Node *)); \
				memcpy(&(tIndices[0]), &(pIndices[0]), (tIndex + 1) * sizeof(size_t)); \
\
				while(true) \
				{ \
					assert(tNodes[tIndex2]->gPrivate_type != 0); \
\
					tIndices[tIndex2]++; \
\
					while(tNodes[tIndex2] && \
							(tIndices[tIndex2] <= tNodes[tIndex2]->gPrivate_numberOfEntries)) \
					{ \
						if(tNodes[tIndex2]->gPrivate_type == 0) \
							{break;} \
\
						tIndices[tIndex2 + 1] = 0; \
						tNodes[tIndex2 + 1] = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
								tNodes[tIndex2], pThis, tIndices[tIndex2])); \
						tIndex2++; \
					} \
					tIndex2--; \
\
					/*THIS IS THE REASON 64 PER THE REFERENCE IMPLEMENTATION BECAME 65 HERE*/ \
					if(tIndex2 == 0) \
						{break;} \
					else if(tNodes[tIndex2] && \
							(tIndices[tIndex2] <= tNodes[tIndex2]->gPrivate_numberOfEntries)) \
					{ \
						if((*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, tNodes[tIndex2], pThis, \
								tIndices[tIndex2])))->gPrivate_type == 0) \
						{ \
							tIsFound = CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, \
									*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, tNodes[tIndex2], \
									pThis, pIndices[tIndex2])), false); \
						} \
					} \
				} \
\
				if(tIsFound) \
				{ \
					tIndex = tIndex2; \
\
					memcpy(&(pNodes[0]), &(tNodes[0]), \
							(tIndex + 1) * sizeof(pTREE_TYPE_NAME ## _Private_Node *)); \
					memcpy(&(pIndices[0]), &(tIndices[0]), (tIndex + 1) * sizeof(size_t)); \
				} \
			} \
	\
			return tIndex + 1; \
		} \
	}, ) \
	\
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_decrementNumberOfElements( \
			pTREE_TYPE_NAME * pThis) \
		{(pThis->gPrivate_numberOfElements)--;} \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_decrementNumberOfNodes( \
			pTREE_TYPE_NAME * pThis) \
		{(pThis->gPrivate_numberOfNodes)--;} \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## private_unsafePopRootNode( \
			pTREE_TYPE_NAME * pThis) \
	{ \
		pTREE_TYPE_NAME ## _Private_Node * vNode = pThis->gPrivate_node__root; \
	\
		pThis->gPrivate_node__root = *pINTERNAL__GET_NODE(pTREE_TYPE_NAME, vNode, pThis, 0); \
		CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
		pThis->gPrivate_node__root->gPrivate_node__parent = NULL;, ) \
	\
		free(vNode); \
	} \
	\
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_construct( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pTREE_TYPE_NAME * pTree) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			_ ## pMEMBER_FUNCTIONS_PREFIX ## iterator_construct(pThis, NULL, false, \
					(pTREE_TYPE_NAME *)pTree); \
		) \
		( \
			_ ## pMEMBER_FUNCTIONS_PREFIX ## iterator_construct(pThis, false, \
					(pTREE_TYPE_NAME *)pTree); \
		) \
	} \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_construct2( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pTREE_TYPE_NAME const * pTree) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			_ ## pMEMBER_FUNCTIONS_PREFIX ## iterator_construct(pThis, NULL, true, \
					(pTREE_TYPE_NAME *)pTree); \
		) \
		( \
			_ ## pMEMBER_FUNCTIONS_PREFIX ## iterator_construct(pThis, true, \
					(pTREE_TYPE_NAME *)pTree); \
		) \
	} \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_construct3( \
			pTREE_TYPE_NAME ## _Iterator * pThis, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPositions, \
			pTREE_TYPE_NAME const * pTree) \
	{ \
		_ ## pMEMBER_FUNCTIONS_PREFIX ## iterator_construct(pThis, pPositions, false, \
				(pTREE_TYPE_NAME *)pTree); \
	}, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE void _ ## pMEMBER_FUNCTIONS_PREFIX ## iterator_construct( \
			pTREE_TYPE_NAME ## _Iterator * pThis, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPositions, \
			bool pIsConstant, pTREE_TYPE_NAME * pTree), \
	PRIVATE void _ ## pMEMBER_FUNCTIONS_PREFIX ## iterator_construct( \
			pTREE_TYPE_NAME ## _Iterator * pThis, bool pIsConstant, \
			pTREE_TYPE_NAME * pTree)) \
	{ \
		pThis->gPrivate_isConstant = pIsConstant; \
		pThis->gPrivate_tree = pTree; \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			pThis->gPrivate_isPositionsMine = (pPositions == NULL); \
			CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
			pThis->gPrivate_node = NULL;, ); \
	\
			if(pPositions != NULL) \
			{ \
				pThis->gPrivate_positions = pPositions; \
				memset(pThis->gPrivate_positions, 0, 64 * sizeof( \
						pTREE_TYPE_NAME ## _Iterator_Private_Position)); \
			} \
			else \
			{ \
				/*IT SHOULD BE 65 WITH THE FIXED ALGORITHM(ASSUMING 64BIT MACHINES) BUT THIS IS 
						ASSUMING 1 BYTE PER NODE*/ \
				pThis->gPrivate_positions = \
						(pTREE_TYPE_NAME ## _Iterator_Private_Position *)calloc(1, 64 * sizeof( \
						pTREE_TYPE_NAME ## _Iterator_Private_Position)); \
			} \
	\
			pThis->gPrivate_position__current = pThis->gPrivate_positions; \
	\
			if(pThis->gPrivate_positions != NULL) \
			{ \
				CRXM__IFELSE2(pIS_PREEMPTIVE, \
				(pThis->gPrivate_positions + 0)->gNode = NULL;, ) \
				(pThis->gPrivate_positions + 0)->gIndex = 0; \
	\
				/*pMEMBER_FUNCTIONS_PREFIX ## iterator_reset(pThis, pTree); */ \
			} \
		) \
		( \
			pThis->gPrivate_node = NULL; \
			pThis->gPrivate_elementIndex = 0; \
	\
			/*pMEMBER_FUNCTIONS_PREFIX ## iterator_reset(pThis, pTree);*/ \
		) \
	} \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_copyConstruct( \
			pTREE_TYPE_NAME ## _Iterator * pThis, \
			pTREE_TYPE_NAME ## _Iterator const * CRX_NOT_NULL pIterator) \
	{ \
		pMEMBER_FUNCTIONS_PREFIX ## iterator_private_copyConstructUsing(pThis, NULL, pIterator); \
	}, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_copyConstructFrom( \
			pTREE_TYPE_NAME ## _Iterator * pThis, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPositions, \
			pTREE_TYPE_NAME ## _Iterator const * CRX_NOT_NULL pIterator) \
	{ \
		pMEMBER_FUNCTIONS_PREFIX ## iterator_private_copyConstructUsing(pThis, pPositions, \
				pIterator); \
	}, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_copyConstructUsing( \
			pTREE_TYPE_NAME ## _Iterator * pThis, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPositions, \
			pTREE_TYPE_NAME ## _Iterator const * CRX_NOT_NULL pIterator) \
	{ \
		pThis->gPrivate_isConstant = pIterator->gPrivate_isConstant; \
		pThis->gPrivate_tree = pIterator->gPrivate_tree; \
		CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
		pThis->gPrivate_node = pIterator->gPrivate_node;, ) \
	\
		if(pIterator->gPrivate_positions != NULL) \
		{ \
			pThis->gPrivate_isPositionsMine = (pPositions == NULL); \
	\
			if(pPositions != NULL) \
			{ \
				pThis->gPrivate_positions = pPositions; \
				memset(pThis->gPrivate_positions, 0, 64 * sizeof( \
						pTREE_TYPE_NAME ## _Iterator_Private_Position)); \
			} \
			else \
			{ \
				pThis->gPrivate_positions = \
						(pTREE_TYPE_NAME ## _Iterator_Private_Position *)calloc(1, 64 * sizeof( \
						pTREE_TYPE_NAME ## _Iterator_Private_Position)); \
			} \
	\
			if(pThis->gPrivate_positions != NULL) \
			{ \
				memcpy(pThis->gPrivate_positions, pIterator->gPrivate_positions, \
						(pIterator->gPrivate_position__current - pIterator->gPrivate_positions + \
						1) * sizeof(pTREE_TYPE_NAME ## _Iterator_Private_Position)); \
	\
				pThis->gPrivate_position__current = pThis->gPrivate_positions + \
						(pIterator->gPrivate_position__current - pIterator->gPrivate_positions); \
			} \
			else \
				{pThis->gPrivate_position__current = NULL;} \
		} \
		else \
		{ \
			pThis->gPrivate_isPositionsMine = false; \
			pThis->gPrivate_positions = NULL; \
			pThis->gPrivate_position__current = NULL; \
		} \
	}, ) \
	\
	PUBLIC pTREE_TYPE_NAME ## _Iterator * pMEMBER_FUNCTIONS_PREFIX ## iterator_new( \
			pTREE_TYPE_NAME * pTree) \
	{ \
		pTREE_TYPE_NAME ## _Iterator * vReturn = (pTREE_TYPE_NAME ## _Iterator *)(calloc(1, \
				sizeof(pTREE_TYPE_NAME ## _Iterator))); \
	\
		if(vReturn != NULL) \
			{pMEMBER_FUNCTIONS_PREFIX ## iterator_construct(vReturn, pTree);} \
	\
		return vReturn; \
	} \
	PUBLIC pTREE_TYPE_NAME ## _Iterator * pMEMBER_FUNCTIONS_PREFIX ## iterator_new2( \
			pTREE_TYPE_NAME const * pTree) \
	{ \
		pTREE_TYPE_NAME ## _Iterator * vReturn = (pTREE_TYPE_NAME ## _Iterator *)(calloc(1, \
				sizeof(pTREE_TYPE_NAME ## _Iterator))); \
	\
		if(vReturn != NULL) \
			{pMEMBER_FUNCTIONS_PREFIX ## iterator_construct2(vReturn, pTree);} \
	\
		return vReturn; \
	} \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE pTREE_TYPE_NAME ## _Iterator * pMEMBER_FUNCTIONS_PREFIX ## iterator_private_new3( \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPositions, \
			pTREE_TYPE_NAME const * pTree) \
	{ \
		pTREE_TYPE_NAME ## _Iterator * vReturn = (pTREE_TYPE_NAME ## _Iterator *)(calloc(1, \
				sizeof(pTREE_TYPE_NAME ## _Iterator))); \
	\
		if(vReturn != NULL) \
			{pMEMBER_FUNCTIONS_PREFIX ## iterator_private_construct3(vReturn, pPositions, pTree);} \
	\
		return vReturn; \
	}, ) \
	PUBLIC pTREE_TYPE_NAME ## _Iterator * pMEMBER_FUNCTIONS_PREFIX ## iterator_moveNew( \
			pTREE_TYPE_NAME ## _Iterator * CRX_NOT_NULL pIterator) \
	{ \
		pTREE_TYPE_NAME ## _Iterator * vReturn = (pTREE_TYPE_NAME ## _Iterator *)(calloc(1, \
				sizeof(pTREE_TYPE_NAME ## _Iterator))); \
	\
		if(vReturn != NULL) \
			{memcpy(vReturn, pIterator, sizeof(pTREE_TYPE_NAME ## _Iterator));} \
	\
		return vReturn; \
	} \
	PUBLIC pTREE_TYPE_NAME ## _Iterator * pMEMBER_FUNCTIONS_PREFIX ## iterator_copyNew( \
			pTREE_TYPE_NAME ## _Iterator const * CRX_NOT_NULL pIterator) \
	{ \
		pTREE_TYPE_NAME ## _Iterator * vReturn = (pTREE_TYPE_NAME ## _Iterator *)(calloc(1, \
				sizeof(pTREE_TYPE_NAME ## _Iterator))); \
	\
		if(vReturn != NULL) \
		{ \
			CRXM__IFELSE(pIS_ELEMENT_DATA_IN_LEAVES_ONLY) \
			( \
				memcpy(vReturn, pIterator, sizeof(pTREE_TYPE_NAME ## _Iterator)); \
			) \
			( \
				pMEMBER_FUNCTIONS_PREFIX ## iterator_copyConstruct(vReturn, pIterator); \
			) \
		} \
	\
		return vReturn; \
	} \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PUBLIC pTREE_TYPE_NAME ## _Iterator * pMEMBER_FUNCTIONS_PREFIX ## iterator_private_copyNewUsing( \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPositions, \
			pTREE_TYPE_NAME ## _Iterator const * CRX_NOT_NULL pIterator) \
	{ \
		pTREE_TYPE_NAME ## _Iterator * vReturn = (pTREE_TYPE_NAME ## _Iterator *)(calloc(1, \
				sizeof(pTREE_TYPE_NAME ## _Iterator))); \
	\
		if(vReturn != NULL) \
		{ \
			CRXM__IFELSE(pIS_ELEMENT_DATA_IN_LEAVES_ONLY) \
			( \
				memcpy(vReturn, pIterator, sizeof(pTREE_TYPE_NAME ## _Iterator)); \
			) \
			( \
				pMEMBER_FUNCTIONS_PREFIX ## iterator_private_copyConstructUsing(vReturn, \
						pPositions, pIterator); \
			) \
		} \
	\
		return vReturn; \
	}, ) \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_destruct( \
			pTREE_TYPE_NAME ## _Iterator * pThis) \
	{ \
		if(pThis->gPrivate_isPositionsMine && (pThis->gPrivate_positions != NULL)) \
		{ \
			free(pThis->gPrivate_positions); \
			pThis->gPrivate_positions = NULL; \
		} \
	}, ) \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_free(pTREE_TYPE_NAME ## _Iterator * pThis) \
		{free(pThis);} \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_copyAssignFrom( \
			pTREE_TYPE_NAME ## _Iterator * pThis, \
			pTREE_TYPE_NAME ## _Iterator const * CRX_NOT_NULL pIterator) \
	{ \
		pThis->gPrivate_tree = pIterator->gPrivate_tree; \
		CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
		pThis->gPrivate_node = pIterator->gPrivate_node;, ) \
	\
		if(pThis->gPrivate_positions != NULL) \
		{ \
			if(pIterator->gPrivate_positions != NULL) \
			{ \
				memcpy(pThis->gPrivate_positions, pIterator->gPrivate_positions, \
						64 * sizeof(pTREE_TYPE_NAME ## _Iterator_Private_Position)); \
	\
				pThis->gPrivate_position__current = pThis->gPrivate_positions + \
						(pIterator->gPrivate_position__current - \
						pIterator->gPrivate_positions); \
			} \
		} \
	}, ) \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_associateWith( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pTREE_TYPE_NAME * pTree) \
		{pMEMBER_FUNCTIONS_PREFIX ## iterator_private_doAssociateWith(pThis, false, pTree);} \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_constantAssociateWith( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pTREE_TYPE_NAME const * pTree) \
		{pMEMBER_FUNCTIONS_PREFIX ## iterator_private_doAssociateWith(pThis, true, pTree);} \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_doAssociateWith( \
			pTREE_TYPE_NAME ## _Iterator * pThis, bool pIsConstant, \
			pTREE_TYPE_NAME const * pTree) \
	{ \
		assert(pThis->gPrivate_isPositionsMine); \
	\
		pThis->gPrivate_isConstant = pIsConstant; \
		pThis->gPrivate_tree = ((pTREE_TYPE_NAME *)pTree); \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
			pThis->gPrivate_node = NULL;, ); \
	\
			pThis->gPrivate_position__current = pThis->gPrivate_positions; \
		) \
		( \
			pThis->gPrivate_node = NULL; \
			pThis->gPrivate_elementIndex = 0; \
		) \
	} \
	\
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_reset(pTREE_TYPE_NAME ## _Iterator * pThis) \
	{ \
		if((pThis->gPrivate_tree == NULL) || \
				CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
				(pThis->gPrivate_positions == NULL), false)) \
			{return;} \
	\
		if(pThis->gPrivate_tree->gPrivate_numberOfElements != 0) \
		{ \
			CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
			( \
				pTREE_TYPE_NAME ## _Private_Node * tNode = \
						pThis->gPrivate_tree->gPrivate_node__root; \
	\
				/*THIS IS THE REASON 64 PER THE REFERENCE IMPLEMENTATION BECAME 65 HERE*/ \
				pThis->gPrivate_position__current = pThis->gPrivate_positions + 1; \
	\
				CRXM__IFELSE(pIS_PREEMPTIVE) \
				( \
					pThis->gPrivate_position__current->gNode = tNode; \
				) \
				( \
					pThis->gPrivate_node = tNode; \
				) \
				pThis->gPrivate_position__current->gIndex = 0; \
	\
				while(tNode->gPrivate_type) \
				{ \
					tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, tNode, pThis->gPrivate_tree, \
							0)); \
	\
					/*ASSERTION: NODES ARE NEVER EMPTY IF \
									pThis->gPrivate_tree->gPrivate_numberOfElements != 0 \
							BUT STICKING TO REFERENCE */ \
					if(tNode != NULL) \
					{ \
						(pThis->gPrivate_position__current)++; \
	\
						CRXM__IFELSE(pIS_PREEMPTIVE) \
						( \
							pThis->gPrivate_position__current->gNode = tNode; \
						) \
						( \
							pThis->gPrivate_node = tNode; \
						) \
	\
						pThis->gPrivate_position__current->gIndex = 0; \
					} \
					else \
						{break;} \
				} \
			) \
			( \
				pThis->gPrivate_node = pThis->gPrivate_tree->gPrivate_node__root; \
				pThis->gPrivate_elementIndex = 0; \
	\
				while(pThis->gPrivate_node->gPrivate_type) \
				{ \
					pThis->gPrivate_node = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
							pThis->gPrivate_node, pThis->gPrivate_tree, 0)); \
	\
					/*ASSERTION: NODES ARE NEVER EMPTY IF \
									pThis->gPrivate_tree->gPrivate_numberOfElements != 0 \
							BUT STICKING TO REFERENCE */ \
					if(pThis->gPrivate_node != NULL) \
						{} \
					else \
						{assert(false); break;} \
				} \
			) \
		} \
		else \
		{ \
			CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
			( \
				CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
				pThis->gPrivate_node = NULL;, ) \
				pThis->gPrivate_position__current = pThis->gPrivate_positions; \
			) \
			( \
				pThis->gPrivate_node = NULL; \
				pThis->gPrivate_elementIndex = 0; \
			) \
		} \
	} \
	PUBLIC void pMEMBER_FUNCTIONS_PREFIX ## iterator_resetToBack( \
			pTREE_TYPE_NAME ## _Iterator * pThis) \
	{ \
		if((pThis->gPrivate_tree == NULL) || \
				CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
				(pThis->gPrivate_positions == NULL), false)) \
			{return;} \
	\
		if(pThis->gPrivate_tree->gPrivate_numberOfElements != 0) \
		{ \
			CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
			( \
				pTREE_TYPE_NAME ## _Private_Node * tNode = \
						pThis->gPrivate_tree->gPrivate_node__root; \
	\
				/*THIS IS THE REASON 64 PER THE REFERENCE IMPLEMENTATION BECAME 65 HERE*/ \
				pThis->gPrivate_position__current = pThis->gPrivate_positions + 1; \
	\
				CRXM__IFELSE(pIS_PREEMPTIVE) \
				( \
					pThis->gPrivate_position__current->gNode = tNode; \
				) \
				( \
					pThis->gPrivate_node = tNode; \
				) \
				pThis->gPrivate_position__current->gIndex = pThis->gPrivate_tree-> \
						gPrivate_node__root->gPrivate_numberOfEntries; \
	\
				while(tNode->gPrivate_type) \
				{ \
					tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, tNode, pThis->gPrivate_tree, \
							tNode->gPrivate_numberOfEntries)); \
	\
					/*ASSERTION: NODES ARE NEVER EMPTY IF \
									pThis->gPrivate_tree->gPrivate_numberOfElements != 0 \
							BUT STICKING TO REFERENCE */ \
					if(tNode != NULL) \
					{ \
						(pThis->gPrivate_position__current)++; \
	\
						CRXM__IFELSE(pIS_PREEMPTIVE) \
						( \
							pThis->gPrivate_position__current->gNode = tNode; \
						) \
						( \
							pThis->gPrivate_node = tNode; \
						) \
	\
						pThis->gPrivate_position__current->gIndex = \
								tNode->gPrivate_numberOfEntries; \
					} \
					else \
						{break;} \
				} \
	\
				if(pThis->gPrivate_position__current->gIndex > 0) \
					{pThis->gPrivate_position__current->gIndex--;} \
			) \
			( \
				pThis->gPrivate_node = pThis->gPrivate_tree->gPrivate_node__root; \
	\
				while(pThis->gPrivate_node->gPrivate_type != 0) \
				{ \
					pThis->gPrivate_node = *(pINTERNAL__GET_NODE( \
							pTREE_TYPE_NAME, pThis->gPrivate_node, pThis->gPrivate_tree, \
							pThis->gPrivate_node->gPrivate_numberOfEntries)); \
	\
					/*ASSERTION: NODES ARE NEVER EMPTY IF \
									pThis->gPrivate_tree->gPrivate_numberOfElements != 0 \
							BUT STICKING TO REFERENCE \
							ALSO NOTE THAT THIS NOT FULLY RELIABLE BECAUSE THE CODE DOES NOT \
							NECESSARY ENFORCE NULL ON EMPTY POINTERS AS FORMALLY REQUIRED IN THE 
							SSTANDARD.*/ \
					if(pThis->gPrivate_node != NULL) \
						{} \
					else \
						{assert(false); break;} \
				} \
	\
				assert(pThis->gPrivate_node->gPrivate_numberOfEntries > 0); \
	\
				pThis->gPrivate_elementIndex = \
						pThis->gPrivate_node->gPrivate_numberOfEntries - 1; \
			) \
		} \
		else \
		{ \
			CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
			( \
				CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
				pThis->gPrivate_node = NULL;, ) \
				pThis->gPrivate_position__current = pThis->gPrivate_positions; \
			) \
			( \
				pThis->gPrivate_node = NULL; \
				pThis->gPrivate_elementIndex = 0; \
			) \
		} \
	} \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_isEqualTo( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pTREE_TYPE_NAME ## _Iterator const * pIterator) \
	{ \
		CRXM__IFELSE(pIS_ELEMENT_DATA_IN_LEAVES_ONLY) \
		( \
			return ((pThis->gPrivate_tree != NULL) && \
					CRX__ARE_POINTERS_TO_SAME_OBJECT(pThis->gPrivate_tree, \
							pIterator->gPrivate_tree, false) && \
					CRX__ARE_POINTERS_TO_SAME_OBJECT(pThis->gPrivate_node, \
					pIterator->gPrivate_node, false) && \
					(pThis->gPrivate_elementIndex == pIterator->gPrivate_elementIndex)); \
		) \
		( \
			/*
				REMEMBER, 
						pThis->gPrivate_position__current == pThis->gPrivate_positions 
				ALSO ACCOUNTS FOR 
						pThis->gPrivate_positions == NULL				
			*/ \
			return ((pThis->gPrivate_tree != NULL) && \
					CRX__ARE_POINTERS_TO_SAME_OBJECT(pThis->gPrivate_tree, \
							pIterator->gPrivate_tree, false) && \
					(((pThis->gPrivate_position__current == pThis->gPrivate_positions) && \
							(pIterator->gPrivate_position__current == \
									pIterator->gPrivate_positions) && \
							(pThis->gPrivate_positions->gIndex == \
									pIterator->gPrivate_positions->gIndex)) || \
							((pThis->gPrivate_position__current != pThis->gPrivate_positions) && \
							(pIterator->gPrivate_position__current != \
									pIterator->gPrivate_positions) && \
							CRXM__IFELSE2(pIS_PREEMPTIVE, \
									CRX__ARE_POINTERS_TO_SAME_OBJECT( \
									pThis->gPrivate_position__current->gNode, \
									pIterator->gPrivate_position__current->gNode, false), \
									CRX__ARE_POINTERS_TO_SAME_OBJECT(pThis->gPrivate_node, \
									pIterator->gPrivate_node, false)) && \
							(pThis->gPrivate_position__current->gIndex ==  \
									pIterator->gPrivate_position__current->gIndex)))); \
		) \
	} \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_next(pTREE_TYPE_NAME ## _Iterator * pThis) \
	{ \
		if(pThis->gPrivate_tree == NULL) \
			{return false;} \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			/*THIS IS THE REASON 64 PER THE REFERENCE IMPLEMENTATION BECAME 65 HERE*/ \
			if(pThis->gPrivate_position__current == pThis->gPrivate_positions) \
				{return false;} \
			else \
			{ \
				CRXM__IFELSE(pIS_PREEMPTIVE) \
				( \
					while(true) \
					{ \
						(pThis->gPrivate_position__current->gIndex)++; \
	\
						while(pThis->gPrivate_position__current->gNode && \
								(pThis->gPrivate_position__current->gIndex <= \
								pThis->gPrivate_position__current->gNode-> \
										gPrivate_numberOfEntries)) \
						{ \
							(pThis->gPrivate_position__current + 1)->gIndex = 0; \
							(pThis->gPrivate_position__current + 1)->gNode = \
									(pThis->gPrivate_position__current-> \
											gNode->gPrivate_type ? \
									*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
											pThis->gPrivate_position__current->gNode, \
											pThis->gPrivate_tree, \
											pThis->gPrivate_position__current->gIndex)) : NULL); \
							(pThis->gPrivate_position__current)++; \
						} \
						(pThis->gPrivate_position__current)--; \
	\
						/*THIS IS THE REASON 64 PER THE REFERENCE IMPLEMENTATION BECAME 65 HERE*/ \
						if(pThis->gPrivate_position__current == pThis->gPrivate_positions) \
						{ \
							pThis->gPrivate_positions->gIndex = 1; \
	\
							return false; \
						} \
						else if(pThis->gPrivate_position__current->gNode && \
								(pThis->gPrivate_position__current->gIndex < \
								pThis->gPrivate_position__current->gNode->gPrivate_numberOfEntries)) \
							{return true;} \
					} \
				) \
				( \
					pTREE_TYPE_NAME ## _Private_Node * tNode = pThis->gPrivate_node; \
	\
					while(true) \
					{ \
						(pThis->gPrivate_position__current->gIndex)++; \
	\
						while(tNode && \
								(pThis->gPrivate_position__current->gIndex <= \
								tNode->gPrivate_numberOfEntries)) \
						{ \
							pThis->gPrivate_node = tNode; \
							(pThis->gPrivate_position__current + 1)->gIndex = 0; \
							tNode = (tNode->gPrivate_type ? *(pINTERNAL__GET_NODE( \
									pTREE_TYPE_NAME, tNode, pThis->gPrivate_tree, \
									pThis->gPrivate_position__current->gIndex)) : NULL); \
							(pThis->gPrivate_position__current)++; \
						} \
						(pThis->gPrivate_position__current)--; \
	\
						if(tNode != NULL) \
						{ \
							tNode = tNode->gPrivate_node__parent; \
							pThis->gPrivate_node = tNode; \
						} \
	\
						/*THIS IS THE REASON 64 PER THE REFERENCE IMPLEMENTATION BECAME 65 HERE*/ \
						if(pThis->gPrivate_position__current == pThis->gPrivate_positions) \
						{ \
							pThis->gPrivate_positions->gIndex = 1; \
							pThis->gPrivate_node = NULL; \
	\
							return false; \
						} \
						else if(pThis->gPrivate_node && \
								(pThis->gPrivate_position__current->gIndex < \
								pThis->gPrivate_node->gPrivate_numberOfEntries)) \
							{return true;} \
						else \
							{tNode = pThis->gPrivate_node;} \
					} \
				) \
			} \
		) \
		( \
			if(pThis->gPrivate_node == NULL) \
				{return false;} \
			else \
			{ \
				if(pThis->gPrivate_elementIndex < \
						(pThis->gPrivate_node->gPrivate_numberOfEntries - 1)) \
					{pThis->gPrivate_elementIndex = pThis->gPrivate_elementIndex + 1;} \
				else \
				{ \
					pThis->gPrivate_node = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
							(pThis->gPrivate_node))->gPrivate_leafNode__next->gPrivate_node); \
					pThis->gPrivate_elementIndex = ((pThis->gPrivate_node != NULL) ? 0 : 1); \
				} \
	\
				return true; \
			} \
		) \
	} \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_prev(pTREE_TYPE_NAME ## _Iterator * pThis) \
	{ \
		if(pThis->gPrivate_tree == NULL) \
			{return false;} \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			/*THIS IS THE REASON 64 PER THE REFERENCE IMPLEMENTATION BECAME 65 HERE*/ \
			if(pThis->gPrivate_position__current == pThis->gPrivate_positions) \
			{ \
				if(pThis->gPrivate_positions->gIndex == 1) \
				{ \
					pThis->gPrivate_positions->gIndex = 0; \
	\
					pMEMBER_FUNCTIONS_PREFIX ## iterator_resetToBack(pThis); \
	\
					return (pThis->gPrivate_position__current != pThis->gPrivate_positions); \
				} \
				else \
					{return false;} \
			} \
			else \
			{ \
				CRXM__IFELSE(pIS_PREEMPTIVE) \
				( \
					bool tIsToSkipUp = false; \
	\
					while(true) \
					{ \
						while(pThis->gPrivate_position__current->gNode /*&& \
								(pThis->gPrivate_position__current->gIndex >= 0)*/) \
						{ \
							/*if((pThis->gPrivate_position__current->gNode-> \
											gPrivate_type == 0) && \
									(pThis->gPrivate_position__current->gIndex == 0))*/ \
							if(!tIsToSkipUp) \
							{ \
								(pThis->gPrivate_position__current + 1)->gNode = \
												(pThis->gPrivate_position__current->gNode-> \
												gPrivate_type ? \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
												pThis->gPrivate_position__current->gNode, \
												pThis->gPrivate_tree, \
												pThis->gPrivate_position__current->gIndex)) : NULL); \
								(pThis->gPrivate_position__current + 1)->gIndex = \
										(pThis->gPrivate_position__current->gNode-> \
												gPrivate_type ? \
										(pThis->gPrivate_position__current + 1)->gNode-> \
												gPrivate_numberOfEntries : 0); \
	\
								(pThis->gPrivate_position__current)++; \
							} \
							else \
							{ \
								tIsToSkipUp = false; \
	\
								break; \
							} \
						} \
						--pThis->gPrivate_position__current; \
	\
						/*THIS IS THE REASON 64 PER THE REFERENCE IMPLEMENTATION BECAME 65 HERE*/ \
						if(pThis->gPrivate_position__current == pThis->gPrivate_positions) \
						{ \
							pThis->gPrivate_positions->gIndex = 0; \
	\
							return false; \
						} \
						else if(pThis->gPrivate_position__current->gNode) \
						{ \
							if(pThis->gPrivate_position__current->gIndex > 0) \
							{ \
								(pThis->gPrivate_position__current->gIndex)--; \
	\
								return true; \
							} \
							else \
								{tIsToSkipUp = true;} \
						} \
					} \
				 ) \
				 ( \
					pTREE_TYPE_NAME ## _Private_Node * tNode = pThis->gPrivate_node; \
					bool tIsToSkipUp = false; \
	\
					while(true) \
					{ \
						while(tNode) \
						{ \
							if(!tIsToSkipUp) \
							{ \
								pThis->gPrivate_node = tNode; \
								tNode = (pThis->gPrivate_node->gPrivate_type ? \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
												tNode, pThis->gPrivate_tree, \
												pThis->gPrivate_position__current->gIndex)) : \
										NULL); \
								(pThis->gPrivate_position__current + 1)->gIndex = \
										(pThis->gPrivate_node->gPrivate_type ? \
										tNode->gPrivate_numberOfEntries : 0); \
	\
								(pThis->gPrivate_position__current)++; \
							} \
							else \
							{ \
								tIsToSkipUp = false; \
	\
								if(tNode == NULL) \
									{tNode = pThis->gPrivate_node;} \
								else \
								{ \
									tNode = tNode->gPrivate_node__parent; \
									pThis->gPrivate_node = tNode; \
								} \
	\
								break; \
							} \
						} \
						--pThis->gPrivate_position__current; \
	\
						/*if(tNode != NULL) \
						{ \
							tNode = tNode->gPrivate_node__parent; \
							pThis->gPrivate_node = tNode; \
						}*/ \
	\
						/*THIS IS THE REASON 64 PER THE REFERENCE IMPLEMENTATION BECAME 65 HERE*/ \
						if(pThis->gPrivate_position__current == pThis->gPrivate_positions) \
						{ \
							pThis->gPrivate_positions->gIndex = 0; \
	\
							return false; \
						} \
						else if(pThis->gPrivate_node) \
						{ \
							if(pThis->gPrivate_position__current->gIndex > 0) \
							{ \
								(pThis->gPrivate_position__current->gIndex)--; \
	\
								return true; \
							} \
							else \
							{ \
								tIsToSkipUp = true; \
								tNode = pThis->gPrivate_node; \
							} \
						} \
					} \
				) \
			} \
		) \
		( \
			if(pThis->gPrivate_node == NULL) \
			{ \
				if(pThis->gPrivate_elementIndex == 1) \
				{ \
					pThis->gPrivate_elementIndex = 0; \
	\
					pMEMBER_FUNCTIONS_PREFIX ## iterator_resetToBack(pThis); \
	\
					return (pThis->gPrivate_node != NULL); \
				} \
				else \
					{return false;} \
			} \
			else \
			{ \
				if(pThis->gPrivate_elementIndex > 0) \
					{pThis->gPrivate_elementIndex = pThis->gPrivate_elementIndex - 1;} \
				else \
				{ \
					pThis->gPrivate_node = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
							(pThis->gPrivate_node))->gPrivate_leafNode__prev->gPrivate_node); \
					pThis->gPrivate_elementIndex = ((pThis->gPrivate_node != NULL) ? \
							(pThis->gPrivate_node->gPrivate_numberOfEntries - 1) : 0); \
				} \
	\
				return true; \
			} \
		) \
	} \
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_isValid( \
			pTREE_TYPE_NAME ## _Iterator * pThis) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			return (pThis->gPrivate_position__current != pThis->gPrivate_positions); \
		) \
		( \
			return (pThis->gPrivate_node != NULL); \
		) \
	} \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_setToPositionOf( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pELEMENT_TYPE const * pElement, \
			Crx_C_Tree_Edge pEdge) \
	{ \
		CRX_SCOPE_META \
		if(pThis->gPrivate_tree == NULL) \
			{return false;} \
	\
		CRX_SCOPE \
		CRXM__IFELSE(pHAS_INDEX) \
		( \
			unsigned char * tIndex__guide = ((unsigned char *)CRX__ALLOCA(sizeof(pINDEX_TYPE))); \
	\
			pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), pElement); \
	\
			return pMEMBER_FUNCTIONS_PREFIX ## iterator_setToPositionOf__do(pThis, \
					((pINDEX_TYPE *)tIndex__guide), pEdge); \
		) \
		( \
			return pMEMBER_FUNCTIONS_PREFIX ## iterator_setToPositionOf__do(pThis, \
					pElement, pEdge); \
		) \
		CRX_SCOPE_END \
	} \
	CRXM__IFELSE2(pHAS_INDEX, \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## iterator_setToPositionOf__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pINDEX_TYPE const * pIndex__guide, \
			Crx_C_Tree_Edge pEdge), \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## iterator_setToPositionOf__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pELEMENT_TYPE const * pElement, \
			Crx_C_Tree_Edge pEdge)) \
	{ \
		bool vReturn = false; \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * tLastSeenLower_position = \
					pThis->gPrivate_positions; \
			CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
			pTREE_TYPE_NAME ## _Private_Node * tLastSeenLower_node = NULL;, ) \
			CRXM__IFELSE2(CRXM__AND(pHAS_INDEX, pARE_INDICES_IN_INTERNAL_NODES_ONLY), \
			unsigned char * tIndex__guide = ((unsigned char *)CRX__ALLOCA( \
					sizeof(pINDEX_TYPE)));, ) \
	\
			pThis->gPrivate_positions->gIndex = 0; \
	\
			pThis->gPrivate_position__current = pThis->gPrivate_positions + 1; \
			CRXM__IFELSE(pIS_PREEMPTIVE) \
			( \
				pThis->gPrivate_position__current->gNode = \
						pThis->gPrivate_tree->gPrivate_node__root; \
			) \
			( \
				pThis->gPrivate_node = pThis->gPrivate_tree->gPrivate_node__root; \
			) \
			pThis->gPrivate_position__current->gIndex = 0; \
	\
			while(CRXM__IFELSE2(pIS_PREEMPTIVE, pThis->gPrivate_position__current->gNode, \
					pThis->gPrivate_node)) \
			{ \
				int32_t tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 0; \
				size_t tImaginaryIndex = CRXM__IFELSE2(pHAS_INDEX, \
						pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
								pThis->gPrivate_tree, \
								CRXM__IFELSE2(pIS_PREEMPTIVE, \
										pThis->gPrivate_position__current->gNode, \
										pThis->gPrivate_node), \
								pIndex__guide, \
								&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode), \
						pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
								pThis->gPrivate_tree, \
								CRXM__IFELSE2(pIS_PREEMPTIVE, \
										pThis->gPrivate_position__current->gNode, \
										pThis->gPrivate_node), \
								pElement, \
								&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode)); \
	\
				if(tImaginaryIndex > 0 /*>=*/ && \
						tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0) \
				{ \
					pThis->gPrivate_position__current->gIndex = tImaginaryIndex - 1; \
	\
					tLastSeenLower_position = pThis->gPrivate_position__current; \
					CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
					tLastSeenLower_node = pThis->gPrivate_node;, ) \
	\
					CRXM__IFELSE(pHAS_INDEX) \
					( \
						switch(pEdge) \
						{ \
							case CRX__C__TREE__EDGE__LEFT: \
							{ \
								/*NEED TO REWIND TO FIND FIRST*/ \
	\
								while(true) \
								{ \
									if(pMEMBER_FUNCTIONS_PREFIX ## iterator_prev(pThis)) \
									{ \
										pTREE_TYPE_NAME ## _Private_Node * tNode = CRXM__IFELSE2( \
												pIS_PREEMPTIVE, \
												pThis->gPrivate_position__current->gNode, \
												pThis->gPrivate_node); \
										int32_t tOrderOfIndices = -1; \
	\
										tLastSeenLower_position = \
												pThis->gPrivate_position__current; \
										CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
										tLastSeenLower_node = pThis->gPrivate_node;, ) \
	\
										CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
										( \
											if(tNode->gPrivate_type) \
											{ \
												memcpy(tIndex__guide, \
														pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
																tNode, pThis->gPrivate_tree, \
																pThis-> \
																gPrivate_position__current-> \
																gIndex), \
														sizeof(pINDEX_TYPE)); \
											} \
											else \
											{ \
												pCONSTRUCT_INDEX_FROM( \
														((pINDEX_TYPE *)tIndex__guide), \
														pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
																pELEMENT_TYPE, tNode, \
																pThis->gPrivate_tree, \
																pThis-> \
																gPrivate_position__current-> \
																gIndex)); \
											} \
	\
											tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
													((pINDEX_TYPE *)tIndex__guide)); \
										) \
										( \
											tOrderOfIndices = pCOMPARE_INDICES( \
													pIndex__guide, \
													((tNode->gPrivate_type) ? \
													pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
													tNode, pThis->gPrivate_tree, \
													pThis->gPrivate_position__current->gIndex) : \
													pLEAF__GET_INDEX(pTREE_TYPE_NAME, \
													tNode, pThis->gPrivate_tree, \
													pThis->gPrivate_position__current->gIndex))); \
										) \
	\
										if(tOrderOfIndices != 0) \
										{ \
											pMEMBER_FUNCTIONS_PREFIX ## iterator_next(pThis); \
	\
											break; \
										} \
									} \
									else \
									{ \
										pThis->gPrivate_position__current = \
												tLastSeenLower_position; \
	\
										CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE),  \
										pThis->gPrivate_node = tLastSeenLower_node;, ) \
	\
										break; \
									} \
								} \
	\
								break; \
							} \
							case CRX__C__TREE__EDGE__RIGHT: \
							{ \
								/*NEED TO FARWARD TO FIND LAST*/ \
	\
								while(true) \
								{ \
									if(pMEMBER_FUNCTIONS_PREFIX ## iterator_next(pThis)) \
									{ \
										pTREE_TYPE_NAME ## _Private_Node * tNode = CRXM__IFELSE2( \
												pIS_PREEMPTIVE, \
												pThis->gPrivate_position__current->gNode, \
												pThis->gPrivate_node); \
										int32_t tOrderOfIndices = -1; \
	\
										tLastSeenLower_position = \
												pThis->gPrivate_position__current; \
										CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
										tLastSeenLower_node = pThis->gPrivate_node;, ) \
	\
										CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
										( \
											if(tNode->gPrivate_type) \
											{ \
												memcpy(tIndex__guide, \
														pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
																tNode, pThis->gPrivate_tree, \
																pThis-> \
																gPrivate_position__current-> \
																gIndex), \
														sizeof(pINDEX_TYPE)); \
											} \
											else \
											{ \
												pCONSTRUCT_INDEX_FROM( \
														((pINDEX_TYPE *)tIndex__guide), \
														pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
																pELEMENT_TYPE, tNode, \
																pThis->gPrivate_tree, \
																pThis-> \
																gPrivate_position__current-> \
																gIndex)); \
											} \
	\
											tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
													((pINDEX_TYPE *)tIndex__guide)); \
										) \
										( \
											tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
													(tNode->gPrivate_type ? \
															pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
																	tNode, pThis->gPrivate_tree, \
																	pThis-> \
																	gPrivate_position__current-> \
																	gIndex) : \
															pLEAF__GET_INDEX(pTREE_TYPE_NAME, \
																	tNode, pThis->gPrivate_tree, \
																	pThis-> \
																	gPrivate_position__current-> \
																	gIndex))); \
										) \
	\
										if(tOrderOfIndices != 0) \
										{ \
											pMEMBER_FUNCTIONS_PREFIX ## iterator_prev(pThis); \
	\
											break; \
										} \
									} \
									else \
									{ \
										pThis->gPrivate_position__current = \
												tLastSeenLower_position; \
	\
										CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE),  \
										pThis->gPrivate_node = tLastSeenLower_node;, ) \
	\
										break; \
									} \
								} \
	\
								break; \
							} \
							case CRX__C__TREE__EDGE__UNSPECIFIC: \
								{break;} \
							default: \
							{ \
								assert(false); \
								break; \
							} \
						} \
					) \
					( \
						switch(pEdge) \
						{ \
							case CRX__C__TREE__EDGE__LEFT: \
							{ \
								/*NEED TO REWIND TO FIND FIRST*/ \
	\
								while(true) \
								{ \
									if(pMEMBER_FUNCTIONS_PREFIX ## iterator_prev(pThis)) \
									{ \
										pTREE_TYPE_NAME ## _Private_Node * tNode = \
												CRXM__IFELSE2(pIS_PREEMPTIVE, \
												pThis->gPrivate_position__current->gNode, \
												pThis->gPrivate_node); \
										pELEMENT_TYPE * tElement = NULL; \
	\
										tLastSeenLower_position = \
												pThis->gPrivate_position__current; \
										CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
										tLastSeenLower_node = pThis->gPrivate_node;, ) \
	\
										if(tNode->gPrivate_type) \
										{ \
											tElement = pINTERNAL__GET_ELEMENT( \
													pTREE_TYPE_NAME, pELEMENT_TYPE, \
													tNode, pThis->gPrivate_tree, \
													pThis->gPrivate_position__current->gIndex); \
										} \
										else \
										{ \
											tElement = pLEAF__GET_ELEMENT( \
													pTREE_TYPE_NAME, pELEMENT_TYPE, \
													tNode, pThis->gPrivate_tree, \
													pThis->gPrivate_position__current->gIndex); \
										} \
	\
										if(pCOMPARE_ELEMENTS(pElement, tElement) != 0) \
										{ \
											pMEMBER_FUNCTIONS_PREFIX ## iterator_next(pThis); \
	\
											break; \
										} \
									} \
									else \
									{ \
										pThis->gPrivate_position__current = \
												tLastSeenLower_position; \
	\
										CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE),  \
										pThis->gPrivate_node = tLastSeenLower_node;, ) \
	\
										break; \
									} \
								} \
	\
								break; \
							} \
							case CRX__C__TREE__EDGE__RIGHT: \
							{ \
								/*NEED TO FARWARD TO FIND LAST*/ \
	\
								while(true) \
								{ \
									if(pMEMBER_FUNCTIONS_PREFIX ## iterator_next(pThis)) \
									{ \
										pTREE_TYPE_NAME ## _Private_Node * tNode = \
												CRXM__IFELSE2(pIS_PREEMPTIVE, \
												pThis->gPrivate_position__current->gNode, \
												pThis->gPrivate_node); \
										pELEMENT_TYPE * tElement; \
	\
										tLastSeenLower_position = \
												pThis->gPrivate_position__current; \
										CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
										tLastSeenLower_node = pThis->gPrivate_node;, ) \
	\
										if(tNode->gPrivate_type) \
										{ \
											tElement = pINTERNAL__GET_ELEMENT( \
													pTREE_TYPE_NAME, pELEMENT_TYPE, \
													tNode, pThis->gPrivate_tree, \
													pThis->gPrivate_position__current->gIndex); \
										} \
										else \
										{ \
											tElement = pLEAF__GET_ELEMENT( \
													pTREE_TYPE_NAME, pELEMENT_TYPE, \
													tNode, pThis->gPrivate_tree, \
													pThis->gPrivate_position__current->gIndex); \
										} \
	\
										if(pCOMPARE_ELEMENTS(pElement, tElement) != 0) \
										{ \
											pMEMBER_FUNCTIONS_PREFIX ## iterator_prev(pThis); \
	\
											break; \
										} \
									} \
									else \
									{ \
										pThis->gPrivate_position__current = \
												tLastSeenLower_position; \
	\
										CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE),  \
										pThis->gPrivate_node = tLastSeenLower_node;, ) \
	\
										break; \
									} \
								} \
	\
								break; \
							} \
							case CRX__C__TREE__EDGE__UNSPECIFIC: \
								{break;} \
							default: \
							{ \
								assert(false); \
								break; \
							} \
						} \
					) \
	\
					vReturn = true; \
	\
					break; \
				} \
				else \
				{ \
					if(tImaginaryIndex > 0 /*>=*/) \
					{ \
						tLastSeenLower_position = pThis->gPrivate_position__current; \
						CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
						tLastSeenLower_node = pThis->gPrivate_node;, ) \
					} \
	\
					if(CRXM__IFELSE2(pIS_PREEMPTIVE, pThis->gPrivate_position__current->gNode, \
							pThis->gPrivate_node)->gPrivate_type) \
					{ \
						pThis->gPrivate_position__current->gIndex = tImaginaryIndex /*+ 1*/; \
	\
						CRXM__IFELSE(pIS_PREEMPTIVE) \
						( \
							(pThis->gPrivate_position__current + 1)->gNode = \
									*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
									pThis->gPrivate_position__current->gNode, \
									pThis->gPrivate_tree, tImaginaryIndex /*+ 1*/)); \
						) \
						( \
							pThis->gPrivate_node = \
									*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
									pThis->gPrivate_node, \
									pThis->gPrivate_tree, tImaginaryIndex /*+ 1*/)); \
						) \
	\
						(pThis->gPrivate_position__current)++; \
					} \
					else \
					{ \
						if(tImaginaryIndex == 0 /*<*/) \
						{ \
							pThis->gPrivate_position__current = tLastSeenLower_position; \
							CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
							pThis->gPrivate_node = tLastSeenLower_node;, ) \
	\
							if(pThis->gPrivate_position__current != pThis->gPrivate_positions) \
								{(pThis->gPrivate_position__current->gIndex)--;} \
						} \
						else \
							{pThis->gPrivate_position__current->gIndex = tImaginaryIndex - 1;} \
	\
						break; \
					} \
				} \
			} \
		) \
		( \
			pTREE_TYPE_NAME ## _Private_Node * tNode = pThis->gPrivate_tree->gPrivate_node__root; \
			size_t tIndex = 0; \
			CRXM__IFELSE2(CRXM__AND(pHAS_INDEX, pARE_INDICES_IN_INTERNAL_NODES_ONLY), \
			unsigned char * tIndex__guide = ((unsigned char *)CRX__ALLOCA( \
					sizeof(pINDEX_TYPE)));, ) \
	\
			while(tNode != NULL) \
			{ \
				int32_t tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 0; \
				size_t tImaginaryIndex = CRXM__IFELSE2(pHAS_INDEX, \
						pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
								pThis->gPrivate_tree, tNode, pIndex__guide, \
								&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode), \
						pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
								pThis->gPrivate_tree, tNode, pElement, \
								&tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode)); \
	\
				if((tImaginaryIndex > 0 /*>=*/) && \
						(tZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0)) \
				{ \
					if(tNode->gPrivate_type) \
					{ \
						tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, tNode, \
								pThis->gPrivate_tree, tImaginaryIndex /*+ 1*/)); \
					} \
					else \
					{ \
						tIndex = tImaginaryIndex - 1; \
	\
						CRXM__IFELSE(pHAS_INDEX) \
						( \
							switch(pEdge) \
							{ \
								case CRX__C__TREE__EDGE__LEFT: \
								{ \
									/*NEED TO REWIND TO FIND FIRST*/ \
									pTREE_TYPE_NAME ## _Private_Node * tNode2 = tNode; \
									size_t tIndex2 = tIndex; \
									int32_t tOrderOfIndices = -1; \
	\
									if(tIndex2 > 0) \
										{tIndex2 = tIndex2 - 1;} \
									else \
									{ \
										tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
												tNode)->gPrivate_leafNode__prev->gPrivate_node); \
	\
										tIndex2 = ((tNode2 != NULL) ? \
												(tNode2->gPrivate_numberOfEntries - 1) : 0); \
									} \
	\
									if(tNode2 != NULL) \
									{ \
										CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
										( \
											pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
													pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, tNode2, pThis->gPrivate_tree, \
													tIndex2)); \
	\
											tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
													((pINDEX_TYPE *)tIndex__guide)); \
										) \
										( \
											tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
													pLEAF__GET_INDEX(pTREE_TYPE_NAME, tNode2, \
															pThis->gPrivate_tree, tIndex2)); \
										) \
									} \
	\
									while(tOrderOfIndices == 0) \
									{ \
										tNode = tNode2; \
										tIndex = tIndex2; \
	\
										if(tIndex2 > 0) \
											{tIndex2 = tIndex2 - 1;} \
										else \
										{ \
											tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
													tNode)->gPrivate_leafNode__prev->gPrivate_node); \
											tIndex2 = ((tNode2 != NULL) ? \
													(tNode2->gPrivate_numberOfEntries - \
													1) : 0); \
										} \
	\
										if(tNode2 != NULL /*&& (tIndex2 >= 0)*/) \
										{ \
											CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
											( \
												pCONSTRUCT_INDEX_FROM( \
														((pINDEX_TYPE *)tIndex__guide), \
														pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
														pELEMENT_TYPE, tNode2, pThis->gPrivate_tree, \
														tIndex2)); \
	\
												tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
														((pINDEX_TYPE *)tIndex__guide)); \
											) \
											( \
												tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
														pLEAF__GET_INDEX(pTREE_TYPE_NAME, tNode2, \
														pThis->gPrivate_tree, tIndex2)); \
											) \
										} \
										else \
											{break;} \
									} \
	\
									break; \
								} \
								case CRX__C__TREE__EDGE__RIGHT: \
								{ \
									/*NEED TO FARWARD TO FIND LAST*/ \
									pTREE_TYPE_NAME ## _Private_Node * tNode2 = tNode; \
									size_t tIndex2 = tIndex; \
									int32_t tOrderOfIndices = 0; \
	\
									if(tIndex2 < (tNode2->gPrivate_numberOfEntries - 1)) \
										{tIndex2 = tIndex2 + 1;} \
									else \
									{ \
										tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
												tNode)->gPrivate_leafNode__next->gPrivate_node); \
	\
										tIndex2 = 0; \
									} \
	\
									if(tNode2 != NULL) \
									{ \
										CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
										( \
											pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
													pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, tNode2, pThis->gPrivate_tree, \
													tIndex2)); \
	\
											tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
													((pINDEX_TYPE *)tIndex__guide)); \
										) \
										( \
											tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
													pLEAF__GET_INDEX(pTREE_TYPE_NAME, tNode2, \
													pThis->gPrivate_tree, tIndex2)); \
										) \
									} \
	\
									while(tOrderOfIndices == 0) \
									{ \
										tNode = tNode2; \
										tIndex = tIndex2; \
	\
										if(tIndex2 < (tNode2->gPrivate_numberOfEntries - 1)) \
											{tIndex2 = tIndex2 + 1;} \
										else \
										{ \
											tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
													tNode)->gPrivate_leafNode__next->gPrivate_node); \
											tIndex2 = 0; \
										} \
	\
										if(tNode2 != NULL) /*&& (tIndex2 < tNode2->gPrivate_numberOfEntries)*/ \
										{ \
											CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
											( \
												pCONSTRUCT_INDEX_FROM( \
														((pINDEX_TYPE *)tIndex__guide), \
														pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
														pELEMENT_TYPE, tNode2, pThis->gPrivate_tree, \
														tIndex2)); \
	\
												tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
														((pINDEX_TYPE *)tIndex__guide)); \
											) \
											( \
												tOrderOfIndices = pCOMPARE_INDICES(pIndex__guide, \
														pLEAF__GET_INDEX(pTREE_TYPE_NAME, tNode2, \
														pThis->gPrivate_tree, tIndex2)); \
											) \
										} \
										else \
											{break;} \
									} \
	\
									break; \
								} \
								case CRX__C__TREE__EDGE__UNSPECIFIC: \
									{break;} \
								default: \
								{ \
									assert(false); \
									break; \
								} \
							} \
						) \
						( \
							switch(pEdge) \
							{ \
								case CRX__C__TREE__EDGE__LEFT: \
								{ \
									/*NEED TO REWIND TO FIND FIRST*/ \
									pTREE_TYPE_NAME ## _Private_Node * tNode2 = tNode; \
									size_t tIndex2 = tIndex; \
	\
									if(tIndex2 > 0) \
										{tIndex2 = tIndex2 - 1;} \
									else \
									{ \
										tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
												tNode)->gPrivate_leafNode__prev->gPrivate_node); \
	\
										tIndex2 = ((tNode2 != NULL) ? \
												(tNode2->gPrivate_numberOfEntries - 1) : \
												0); \
									} \
	\
									while((tNode2 != NULL) && \
											(pCOMPARE_ELEMENTS(pElement, \
											pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
											pELEMENT_TYPE, tNode2, pThis->gPrivate_tree, \
											tIndex2)) == 0)) \
									{ \
										tNode = tNode2; \
										tIndex = tIndex2; \
	\
										if(tIndex2 > 0) \
											{tIndex2 = tIndex2 - 1;} \
										else \
										{ \
											tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
													tNode)->gPrivate_leafNode__prev->gPrivate_node); \
											tIndex2 = ((tNode2 != NULL) ? \
													(tNode2->gPrivate_numberOfEntries - \
													1) : 0); \
										} \
									} \
	\
									break; \
								} \
								case CRX__C__TREE__EDGE__RIGHT: \
								{ \
									/*NEED TO FARWARD TO FIND LAST*/ \
									pTREE_TYPE_NAME ## _Private_Node * tNode2 = tNode; \
									size_t tIndex2 = tIndex; \
	\
									if(tIndex2 < (tNode2->gPrivate_numberOfEntries - 1)) \
										{tIndex2 = tIndex2 + 1;} \
									else \
									{ \
										tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
												tNode)->gPrivate_leafNode__next->gPrivate_node); \
	\
										tIndex2 = 0; \
									} \
	\
									while((tNode2 != NULL) && \
											(pCOMPARE_ELEMENTS(pElement, \
											pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
											pELEMENT_TYPE, tNode2, pThis->gPrivate_tree, \
											tIndex2)) == 0)) \
									{ \
										tNode = tNode2; \
										tIndex = tIndex2; \
	\
										if(tIndex2 < (tNode2->gPrivate_numberOfEntries - \
												1)) \
											{tIndex2 = tIndex2 + 1;} \
										else \
										{ \
											tNode2 = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
													tNode)->gPrivate_leafNode__next->gPrivate_node); \
											tIndex2 = 0; \
										} \
									} \
	\
									break; \
								} \
								case CRX__C__TREE__EDGE__UNSPECIFIC: \
									{break;} \
								default: \
								{ \
									assert(false); \
									break; \
								} \
							} \
						) \
	\
						break; \
						vReturn = true; \
					} \
				} \
				else \
				{ \
					if(tNode->gPrivate_type) \
					{ \
						tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, tNode, \
								pThis->gPrivate_tree, tImaginaryIndex /*+ 1*/)); \
					} \
					else \
					{ \
						if(tImaginaryIndex > 0 /*>=*/) \
							{tIndex = tImaginaryIndex - 1;} \
						else \
						{ \
							tNode = &(((pTREE_TYPE_NAME ## _Private_LeafNode *)tNode)-> \
									gPrivate_leafNode__prev->gPrivate_node); \
							tIndex = ((tNode != NULL) ? (tNode->gPrivate_numberOfEntries - \
									1) : 0); \
						} \
	\
						break; \
					} \
				} \
			} \
	\
			pThis->gPrivate_node = tNode; \
			pThis->gPrivate_elementIndex = tIndex; \
		) \
	\
		return vReturn; \
	} \
	\
	PUBLIC bool pMEMBER_FUNCTIONS_PREFIX ## iterator_remove(pTREE_TYPE_NAME ## _Iterator * pThis) \
	{ \
		CRX_SCOPE_META \
		if((pThis->gPrivate_tree == NULL) || \
				(pThis->gPrivate_isConstant) || \
				(pThis->gPrivate_tree->gPrivate_node__root == NULL) || \
				CRXM__IFELSE2(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, \
						(pThis->gPrivate_node == NULL), \
						(pThis->gPrivate_position__current == pThis->gPrivate_positions))) \
			{return false;} \
	\
		CRX_SCOPE \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * tPosition = \
					pThis->gPrivate_position__current; \
			pTREE_TYPE_NAME ## _Private_Node * tNode = CRXM__IFELSE2(pIS_PREEMPTIVE, \
					NULL, pThis->gPrivate_node); \
			bool tIsToAdvance = false; \
	\
			CRXM__IFELSE(pIS_PREEMPTIVE) \
			( \
				while((tPosition != pThis->gPrivate_positions) && \
						(tPosition->gNode->gPrivate_numberOfEntries < \
								pThis->gPrivate_tree->gPrviate_countOfMidElementInNode)) \
					{tPosition--;} \
	\
				tNode = tPosition->gNode; \
			) \
			( \
				while((tPosition != pThis->gPrivate_positions) && \
						(tNode->gPrivate_numberOfEntries < \
								pThis->gPrivate_tree->gPrviate_countOfMidElementInNode)) \
				{ \
					tPosition--; \
	\
					tNode = tNode->gPrivate_node__parent; \
				} \
			) \
	\
			if(tNode == NULL) \
			{ \
				tNode = pThis->gPrivate_tree->gPrivate_node__root; \
				tPosition = pThis->gPrivate_positions + 1; \
			} \
	\
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do(pThis, 0, tNode, \
						tPosition, NULL, NULL, &tIsToAdvance); \
			) \
			( \
				pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do(pThis, 0, tNode, \
						tPosition, NULL, &tIsToAdvance); \
			) \
	\
			if(tIsToAdvance) \
				{pMEMBER_FUNCTIONS_PREFIX ## iterator_next(pThis);} \
			else \
			{ \
				if(pThis->gPrivate_position__current == pThis->gPrivate_positions) \
					{pThis->gPrivate_positions->gIndex = 1;} \
			} \
		) \
		( \
			/*
				WARNING: THESE HAVE DIFFERENT SEMANTICS DEPENDING ON WHETHER THE ALGORITHM IS \
						PRE EMTPIVE. A FORMAL VIOLATION. IF PRE EMPTIVE, THE FOLLOWING ARRAYS \
						CARRY A FULL TRACE, OTHERWISE THEY CARRY A TRACE STARTING THE FIRST \
						IMPORTANT NODE FOR THE ALGORITHM TO ADDRESS. IN BOTH CASES, THE \
						ARRAYS BEGIN WITH A NODE NULL, AND INDEX 0 TO MATCH \
						this->gPrivate_positions BEHAVIOR. \
			*/ \
			pTREE_TYPE_NAME ## _Private_Node * tNodes[64]; \
			size_t tIndices[64]; \
			CRXM__IFELSE2(pHAS_INDEX, \
			unsigned char * tIndex__guide = \
					((unsigned char *)CRX__ALLOCA(sizeof(pINDEX_TYPE)));, ) \
	\
			CRXM__IFELSE(pHAS_INDEX) \
			( \
				CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
				( \
					pCONSTRUCT_INDEX_FROM(((pINDEX_TYPE *)tIndex__guide), \
							pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pThis->gPrivate_node, \
									pThis->gPrivate_tree, pThis->gPrivate_elementIndex)); \
				) \
				( \
					memcpy(tIndex__guide, ((unsigned char *)pLEAF__GET_INDEX(pTREE_TYPE_NAME, \
							pThis->gPrivate_node, pThis->gPrivate_tree, \
							pThis->gPrivate_elementIndex)), sizeof(pINDEX_TYPE)); \
				) \
			)() \
	\
			CRXM__IFELSE(pIS_PREEMPTIVE) \
			( \
				size_t tLength = 1; \
				size_t tIndex = tLength; \
	\
				/*THE SECOND PART OF THE CHECK BELOW, WHICH IS TO DETERMINE WHETHER THE ENTRY \
						HAS A COPY, OR A RELATED ENTRY, ELSEWHERE, IS BASED ON THE ASSUMPTION 
						DISCUSSED BELOW.*/ \
				if((pThis->gPrivate_node->gPrivate_numberOfEntries < \
						pThis->gPrivate_tree->gPrviate_countOfMidElementInNode) || \
						CRXM__IFELSE2(pIS_TO_USE_DELEGATION, \
						((pThis->gPrivate_elementIndex == 0) && \
						(((pTREE_TYPE_NAME ## _Private_LeafNode *)(pThis->gPrivate_node))-> \
								gPrivate_leafNode__prev != NULL)), false)) \
				{ \
					tLength = pMEMBER_FUNCTIONS_PREFIX ## private_getTraceOfLeafNode( \
							pThis->gPrivate_tree, pThis->gPrivate_node, \
							&(tNodes[0]), &(tIndices[0])); \
					tIndex = tLength; \
				} \
				else \
				{ \
					tNodes[0] = NULL; \
					tIndices[0] = 0; \
				} \
	\
				assert(tLength > 0); \
	\
				tNodes[tIndex] = pThis->gPrivate_node; \
				tIndices[tIndex] = pThis->gPrivate_elementIndex; \
	\
				CRXM__IFELSE(pIS_TO_USE_DELEGATION) \
				( \
					/*
						IF AN ELEMENT HAS A COPY ELSEWHERE, IT WOULD BE, WHEN TRAVERSING UP, IN \
						THE NODE WHERE THE INDEX OF THE CHILD NODE THAT IS PART OF THE PATH IS \
						NOT ZERO. AT THAT NODE, THE COPY WOULD BE AT THAT NON ZERO INDEX MINUS \
						ONE. AND IF WE ARE THE LEFT MOST NODE, THE FIRST ELEMENT THERE COULD NOT \
						POSSIBLY HAVE A COPY ELSEWHERE. \
						IF THE ABOVE IS INCORRECT, THE FOLLOWING IS INCORRECT. \
					*/ \
					if((pThis->gPrivate_elementIndex == 0) && \
							(((pTREE_TYPE_NAME ## _Private_LeafNode *)(pThis->gPrivate_node))-> \
									gPrivate_leafNode__prev != NULL)) \
					{ \
						while((tIndex > 0) && (tIndices[tIndex - 1] == 0)) \
							{tIndex--;} \
	\
						assert(tIndex != 1); \
	\
						if(tIndex > 0) \
							{tIndex--;} \
					} \
				)() \
	\
				while((tIndex > 0) && (tNodes[tIndex]->gPrivate_numberOfEntries < \
						pThis->gPrivate_tree->gPrviate_countOfMidElementInNode)) \
					{tIndex--;} \
	\
				if(tIndex == 0) \
					{tIndex = 1;} \
	\
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
							pThis, 0, tNodes[tIndex], &(tIndices[0]), tIndex, \
							((pINDEX_TYPE *)tIndex__guide), \
							pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pThis->gPrivate_node, pThis->gPrivate_tree, \
									pThis->gPrivate_elementIndex), \
							NULL); \
				) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
							pThis, 0, tNodes[tIndex], &(tIndices[0]), tIndex, \
							pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pThis->gPrivate_node, pThis->gPrivate_tree, \
									pThis->gPrivate_elementIndex), \
							NULL); \
				) \
			) \
			( \
				pTREE_TYPE_NAME ## _Private_Node * tNodes2[64] /*= ?*/; \
				size_t tIndices2[64] /*= ?*/; \
				size_t tIndex = 0; \
	\
				tNodes2[0] = pThis->gPrivate_node; \
				tIndices2[0] = pThis->gPrivate_elementIndex; \
	\
				CRXM__IFELSE(pIS_TO_USE_DELEGATION) \
				( \
					/*
						IF AN ELEMENT HAS A COPY ELSEWHERE, IT WOULD BE, WHEN TRAVERSING UP, IN \
						THE NODE WHERE THE INDEX OF THE CHILD NODE THAT IS PART OF THE PATH IS \
						NOT ZERO. AT THAT NODE, THE COPY WOULD BE AT THAT NON ZERO INDEX MINUS \
						ONE. AND IF WE ARE THE LEFT MOST NODE, THE FIRST ELEMENT THERE COULD NOT \
						POSSIBLY HAVE A COPY ELSEWHERE. \
						IF THE ABOVE IS INCORRECT, THE FOLLOWING IS INCORRECT. \
					*/ \
					if((pThis->gPrivate_elementIndex == 0) && \
							(((pTREE_TYPE_NAME ## _Private_LeafNode *)(pThis->gPrivate_node))-> \
									gPrivate_leafNode__prev != NULL)) \
					{ \
						while(tNodes2[tIndex]->gPrivate_node__parent != NULL) \
						{ \
							size_t tChildNodeIndex = \
									pMEMBER_FUNCTIONS_PREFIX ## private_findChildNodeIndexInParent( \
									pThis->gPrivate_tree, tNodes2[tIndex]); \
	\
							assert(tChildNodeIndex != ((size_t)(-1))); \
	\
							tNodes2[tIndex + 1] = tNodes2[tIndex]->gPrivate_node__parent; \
							tIndices2[tIndex + 1] = tChildNodeIndex; \
							tIndex++; \
	\
							if(tChildNodeIndex != 0) \
								{break;} \
						} \
	\
						/*TO MATCH THE ASSERT ABOVE, NO MORE*/ \
						assert(tNodes2[tIndex] != NULL); \
					} \
				)() \
	\
				if(tNodes2[tIndex]->gPrivate_node__parent != NULL) \
				{ \
					while(tNodes2[tIndex]->gPrivate_numberOfEntries < \
							pThis->gPrivate_tree->gPrviate_countOfMidElementInNode) \
					{ \
						size_t tChildNodeIndex = pMEMBER_FUNCTIONS_PREFIX ## private_findChildNodeIndexInParent( \
								pThis->gPrivate_tree, tNodes2[tIndex]); \
	\
						assert(tChildNodeIndex != ((size_t)(-1))); \
	\
						tNodes2[tIndex + 1] = tNodes2[tIndex]->gPrivate_node__parent; \
						tIndices2[tIndex + 1] = tChildNodeIndex; \
						tIndex++; \
	\
						if(tNodes2[tIndex]->gPrivate_node__parent == NULL) \
							{break;} \
					} \
				} \
	\
				/*TO BE CONSISTANT. HOWEVER, tNodes[1] STILL DOES NOT NECESSARILY POINT TO ROOT*/ \
				tNodes[0] = NULL; \
				tIndices[0] = 0; \
	\
				CRX_FOR(size_t tI = 0, tI <= tIndex, tI++) \
				{ \
					tNodes[tI + 1] = tNodes2[tIndex - tI]; \
					tIndices[tI + 1] = tIndices2[tIndex - tI]; \
				} \
				CRX_ENDFOR \
	\
				CRXM__IFELSE(pHAS_INDEX) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do(pThis, 0, \
							tNodes[1], &(tIndices[0]), 1, ((pINDEX_TYPE *)tIndex__guide), \
							pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pThis->gPrivate_node, pThis->gPrivate_tree, \
									pThis->gPrivate_elementIndex), NULL); \
				) \
				( \
					pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do(pThis, 0, \
							tNodes[1], &(tIndices[0]), 1, \
							pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pThis->gPrivate_node, pThis->gPrivate_tree, \
									pThis->gPrivate_elementIndex), NULL); \
				) \
			) \
	\
			if(pThis->gPrivate_elementIndex == \
					pThis->gPrivate_node->gPrivate_numberOfEntries) \
			{ \
				pThis->gPrivate_node = &(((pTREE_TYPE_NAME ## _Private_LeafNode *) \
						(pThis->gPrivate_node))->gPrivate_leafNode__next->gPrivate_node); \
				pThis->gPrivate_elementIndex = ((pThis->gPrivate_node != NULL) ? 0 : 1); \
			} \
		) \
	\
		pMEMBER_FUNCTIONS_PREFIX ## private_decrementNumberOfElements(pThis->gPrivate_tree); \
	\
		if((pThis->gPrivate_tree->gPrivate_node__root->gPrivate_numberOfEntries == 0) && \
				(pThis->gPrivate_tree->gPrivate_node__root->gPrivate_type)) \
		{ \
			pMEMBER_FUNCTIONS_PREFIX ## private_unsafePopRootNode(pThis->gPrivate_tree); \
			pMEMBER_FUNCTIONS_PREFIX ## private_decrementNumberOfNodes(pThis->gPrivate_tree); \
		} \
	\
		return true; \
	\
		CRX_SCOPE_END \
	} \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	CRXM__IFELSE2(pHAS_INDEX, \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPosition__current, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE * pElement, \
			bool * CRX_NOT_NULL pIsToAdvance), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPosition__current, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE * * pElement, \
			bool * CRX_NOT_NULL pIsToAdvance)), \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPosition__current, \
			pELEMENT_TYPE * pElement, bool * CRX_NOT_NULL pIsToAdvance), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, \
			pTREE_TYPE_NAME ## _Iterator_Private_Position * pPosition__current, \
			pELEMENT_TYPE * * pElement, bool * CRX_NOT_NULL pIsToAdvance))), \
	CRXM__IFELSE2(pHAS_INDEX, \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, size_t * pIndices, size_t pIndexInIndices, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE const * pElement, \
			pINDEX_TYPE *  pIndex__out), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, size_t * pIndices, size_t pIndexInIndices, \
			pINDEX_TYPE * pIndex__guide, pELEMENT_TYPE const * pElement, \
			pINDEX_TYPE * pIndex__out)), \
	CRXM__IFELSE2(CRXM__NOT(pIS_PERSISTANT), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, size_t * pIndices, size_t pIndexInIndices, \
			pELEMENT_TYPE const * pElement, \
			pELEMENT_TYPE * pElement__out), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
			pTREE_TYPE_NAME ## _Iterator * pThis, uint32_t pMode, \
			pTREE_TYPE_NAME ## _Private_Node * pNode, size_t * pIndices, size_t pIndexInIndices, \
			pELEMENT_TYPE const * pElement, \
			pELEMENT_TYPE * * pElement__out)))) \
	{ \
		/*if(pNode == NULL) \
			{return *pKey;} \
		else*/ \
	\
		size_t vImaginaryIndex; \
		int32_t vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 0; \
	\
		/*if(pMode) \
		{ /* pMode can only be 0, 1 or 2 * / \
			vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = \
					((pNode->gPrivate_type == 0) ? 0 : ((pMode == 1) ? 1 : -1)); \
			vImaginaryIndex = ((pMode == 1) ? (pNode->gPrivate_numberOfEntries /*- 1* /) : 0/*-1* /); \
		}*/ \
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			if(pMode == 1) \
			{ \
				if(pNode->gPrivate_type) \
					{vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 1;} \
	\
				vImaginaryIndex = pNode->gPrivate_numberOfEntries /*- 1*/; \
			} \
			else if(pMode == 2) \
			{ \
				if(pNode->gPrivate_type) \
				{ \
					vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = -1; \
					vImaginaryIndex = 0 /*-1*/; \
				} \
				else \
					{vImaginaryIndex = 1 /*0*/;} \
			} \
			else /*pMode == 0*/ \
			{ \
				CRXM__IFELSE2(pIS_PREEMPTIVE, \
				assert(pNode == pPosition__current->gNode);, ) \
	\
				if(CRX__ARE_POINTERS_TO_SAME_OBJECT(pPosition__current, \
						pThis->gPrivate_position__current, false)) \
				{ \
					vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 0; \
					vImaginaryIndex = pPosition__current->gIndex + 1; \
				} \
				else \
				{ \
					assert(pNode->gPrivate_type != 0); \
	\
					/*NOTE THAT THE FOLLOWING EVALUATION OF \
							vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode IS NOT \
							NECESSARILY CORRECT WHEN \
							(pPosition__current->gIndex != \
									pNode->gPrivate_numberOfEntries), \
							BUT IT SHOULD NOT BE A PROBLEM.
					*/ \
					vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = \
							((pPosition__current->gIndex == \
							pNode->gPrivate_numberOfEntries) ? 1 : -1); \
					vImaginaryIndex = pPosition__current->gIndex /*- 1*/; \
				} \
			} \
		) \
		( \
			/* CRXM__IFELSE(pHAS_INDEX) \
			( \
				vImaginaryIndex = \
						pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
						pThis->gPrivate_tree, pNode, \
						pIndex__guide, \
						&vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode); \
			) \
			( \
				vImaginaryIndex = \
						pMEMBER_FUNCTIONS_PREFIX ## private_getSuitableImagineryIndexFor( \
						pThis->gPrivate_tree, pNode, \
						CRXM__IFELSE2(pIS_PERSISTANT, *pElement, pElement), \
						&vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode); \
			) */ \
	\
			/*UNLIKE THE ABOVE CODE, THE FOLLOWING ASSUMES THAT THE ELEMENT FROM THE LEAVES \
					THAT WAS COPIED TO THE INTERNAL NODES REMAINS AT THE RIGHT MOST EDGE OF \
					THE LEAF THAT IT IS IN NO MATTER HOW MUCH SPLITTING HAPPENS OR THE COPY \
					MOVES THE TREE RELATIVE TO THE LEAVES.*/ \
			if(pMode == 1) \
			{ \
				/*SHOULD NOT HAPPEN*/ \
				assert(false); \
				if(pNode->gPrivate_type) \
					{vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 1;} \
	\
				vImaginaryIndex = pNode->gPrivate_numberOfEntries /*- 1*/; \
			} \
			else if(pMode == 2) \
			{ \
				if(pNode->gPrivate_type) \
				{ \
					vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = -1; \
					vImaginaryIndex = 0 /*-1*/; \
				} \
				else \
					{vImaginaryIndex = 1 /*0*/;} \
			} \
			else \
			{ \
				if(CRX__ARE_POINTERS_TO_SAME_OBJECT(pNode, \
						pThis->gPrivate_node, false)) \
				{ \
					vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 0; \
					vImaginaryIndex = pIndices[pIndexInIndices] + 1; \
				} \
				else \
				{ \
					CRX_SCOPE_META \
					assert(pNode->gPrivate_type != 0); \
	\
					CRX_SCOPE \
					int32_t tResult = 1; /*ARBITRARY. WE ONLY CARE IF RESULT IS 0.*/ \
	\
					if(pIndices[pIndexInIndices] > 0) \
					{ \
						CRXM__IFELSE(pHAS_INDEX) \
						( \
							tResult = pCOMPARE_INDICES(pIndex__guide, \
									pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, \
											pThis->gPrivate_tree, \
											pIndices[pIndexInIndices] - 1)); \
						) \
						( \
							tResult = pCOMPARE_ELEMENTS(pElement, \
									pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
											pNode, pThis->gPrivate_tree, \
											pIndices[pIndexInIndices] - 1)); \
						) \
					} \
	\
					if(tResult == 0) \
						{vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = 0;} \
					else \
					{ \
						/*NOTE THAT THE FOLLOWING EVALUATION OF 
								vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode IS NOT
								NECESSARILY CORRECT WHEN \
								(pIndices[pIndexInIndices] != \
										pNode->gPrivate_numberOfEntries), \
								BUT IT SHOULD NOT BE A PROBLEM.
						*/ \
						vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode = \
								((pIndices[pIndexInIndices] == \
								pNode->gPrivate_numberOfEntries) ? \
								1 : -1); \
					} \
	\
					vImaginaryIndex = pIndices[pIndexInIndices] /*- 1*/; \
					CRX_SCOPE_END \
				} \
			} \
		) \
	\
		if(pNode->gPrivate_type) \
		{ \
			bool tIsDone = false; \
			size_t tIndexOfNextNode = 0; \
	\
			if((vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0) && \
					CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), true, \
					(pMode == 0))) \
			{ \
				/*EVEN WHEN ELEMENT DATA IS NOT IN LEAVES ONLY, pMode MUST ALSO BE 0 IF WE ARE \
						HERE. THIS IS BECAUSE WE ARE STICKING TO THE FIRST FOUND ENTRY IN THE \
						INTERNAL NODES IN THAT CASE. \
						NOTE THAT THIS WAS NECESSARY WHEN THE ALGORITHM CONTINUED TO DO A \
						BINARY SEARCH IN THE CASE WHEN MODE WAS NOT ZERO AND ELEMENT DATA WAS \
						IN LEAVES. LATER I CHANED THAT, BUT KEEPING THE CODE ABOVE IN THE IF
						CONDITION, AND THE ASSERTION BELOW, FOR THE TIME BEING.
				*/ \
				CRX_SCOPE_META \
				assert(pMode == 0); \
	\
				CRX_SCOPE \
				size_t tNumberOfKeysInLeftNode = 0; \
				size_t tNumberOfKeysInRightNode = (*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
						pNode, pThis->gPrivate_tree, \
						vImaginaryIndex /*+ 1*/)))->gPrivate_numberOfEntries; \
				int32_t tBranchToTake = -2; /*-2: non,  -1: left,  0: merge and try again,  \
											1: right*/ \
	\
				CRXM__IFELSE(CRXM__AND(pIS_ELEMENT_DATA_IN_LEAVES_ONLY, pIS_PREEMPTIVE)) \
				( \
					if(tNumberOfKeysInRightNode < \
							pThis->gPrivate_tree->gPrviate_countOfMidElementInNode) \
					{ \
						tNumberOfKeysInLeftNode = (*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
								pNode, pThis->gPrivate_tree, \
								vImaginaryIndex - 1)))->gPrivate_numberOfEntries; \
	\
						if(tNumberOfKeysInLeftNode >= \
								pThis->gPrivate_tree->gPrviate_countOfMidElementInNode) \
						{ \
							pMEMBER_FUNCTIONS_PREFIX ## private_rotateRight( \
									pThis->gPrivate_tree, \
									*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
											pThis->gPrivate_tree, vImaginaryIndex - 1)), \
									vImaginaryIndex - 1, pNode, \
									*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
											pThis->gPrivate_tree, vImaginaryIndex /*+ 1*/))); \
	\
							pIndices[pIndexInIndices + 1] = pIndices[pIndexInIndices + 1] + 1; \
	\
							if((*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, \
									pNode, pThis->gPrivate_tree, \
									vImaginaryIndex /*+ 1*/)))->gPrivate_type == 0) \
							{ \
								assert(CRX__ARE_POINTERS_TO_SAME_OBJECT(*(pINTERNAL__GET_NODE( \
										pTREE_TYPE_NAME, pNode, pThis->gPrivate_tree, \
										vImaginaryIndex /*+ 1*/)), pThis->gPrivate_node, \
										false)); \
	\
								(pThis->gPrivate_elementIndex)++; \
							} \
	\
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
										pThis, 0, pNode, pIndices, pIndexInIndices, \
										pIndex__guide, pElement, NULL); \
							) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
										pThis, 0, pNode, pIndices, pIndexInIndices, \
										pElement, NULL); \
							) \
	\
							tIsDone = true; \
						} \
					} \
				)() \
	\
				/*THE FOLLOWING CHECK FOR tIsDone IS ONLY REQUIRED WHEN DATA IS IN THE 
						LEAVES ONLY, BUT TO KEEP THINGS SIMPLE THE CHECK IS ALWAYS DONE.
				*/ \
				if(!tIsDone) \
				{ \
					if(tNumberOfKeysInRightNode >= \
							pThis->gPrivate_tree->gPrviate_countOfMidElementInNode) \
						{tBranchToTake = 1;} \
					else \
					{ \
						CRXM__IFELSE(pIS_PREEMPTIVE) \
						( \
							CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
							( \
								tNumberOfKeysInLeftNode = (*(pINTERNAL__GET_NODE( \
										pTREE_TYPE_NAME, pNode, pThis->gPrivate_tree, \
										vImaginaryIndex - 1)))-> \
										gPrivate_numberOfEntries; \
	\
								if(tNumberOfKeysInLeftNode >= \
										pThis->gPrivate_tree->gPrviate_countOfMidElementInNode) \
									{tBranchToTake = -1;} \
								else \
									{tBranchToTake = 0;} \
							) \
							( \
								assert((tNumberOfKeysInLeftNode > 0) && \
										(tNumberOfKeysInLeftNode < \
												pThis->gPrivate_tree-> \
												gPrviate_countOfMidElementInNode)); \
	\
								tBranchToTake = 0; \
							) \
						) \
						( \
							CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
							( \
								tBranchToTake = -1; \
							) \
							( \
								tBranchToTake = 1; \
							) \
						) \
					} \
	\
					if(tBranchToTake != 0) \
					{ \
						CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
						( \
							CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
							pFUNC_ELEMENT_DESTRUCTOR(pINTERNAL__GET_ELEMENT( \
									pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
									pThis->gPrivate_tree, vImaginaryIndex - 1));, ) \
	\
							CRXM__IFELSE2(pIS_PERSISTANT, \
							free(pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, \
									pELEMENT_TYPE, pNode, pThis->gPrivate_tree, \
									vImaginaryIndex - 1));, ) \
						) \
						( \
							/*NOTICE: EFFECTIVELY WE ARE TREATING TWO EQUAL INDICES AS IF THEY \
									ARE BYTE WISE EQUAL. THIS IS CONTRARY TO ALMOST EVERY \
									WHERE, IF NOT EVERY WHERE, ELSE IN THE CODE. IF OTHER \
									WORDS, WHEN THE TREE HAS AN INDEX WE DO NOT ATTEMPT TO \
									CHECK IF IT IS EXACTLY THE INDEX THAT IS CREATED FROM THE \
									ELEMENT THAT WE SHALL EVENTUALLY REMOVE FROM A LEAF. \
									INSTEAD, WE REASON THAT WHATEVER THAT INDEX IS IT MUST BE \
									EQUAL UNDER THE INDEX ORDERING TO THE ONE FOUND HERE, BUT \
									THIS EFFECTIVELY ASSUMES BYTE WISE EQUALITY ALSO.*/ \
	\
							CRXM__IFELSE(CRXM__NOT(pHAS_INDEX)) \
							( \
								CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
								( \
									CRXM__IFELSE2(CRXM__AND(pFUNC_ELEMENT_DESTRUCTOR, \
											pIS_TO_USE_DELEGATION), \
									pFUNC_ELEMENT_DESTRUCTOR(pINTERNAL__GET_ELEMENT( \
											pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
											pThis->gPrivate_tree, vImaginaryIndex - 1));, ) \
								) \
								( \
									CRXM__IFELSE2(pIS_TO_USE_DELEGATION, \
									*(pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
											pELEMENT_TYPE, pNode, pThis->gPrivate_tree, \
											vImaginaryIndex - 1)) = NULL;, ) \
								) \
							)() \
						) \
					} \
	\
					if(tBranchToTake == 1) \
					{ \
						CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
						( \
							/*vKey = __KB_KEY(pGUIDE_TYPE, pNode)[vImaginaryIndex - 1];*/ \
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
										pThis, 2, \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
												pThis->gPrivate_tree, \
												vImaginaryIndex /*+ 1*/)), \
										NULL, \
										pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, \
												pThis->gPrivate_tree, \
												vImaginaryIndex - 1), \
										pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
												pELEMENT_TYPE, pNode, \
												pThis->gPrivate_tree, \
												vImaginaryIndex - 1), \
										pIsToAdvance); \
							) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
										pThis, 2, \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
												pThis->gPrivate_tree, \
												vImaginaryIndex /*+ 1*/)), \
										NULL, \
										pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
												pELEMENT_TYPE, pNode, \
												pThis->gPrivate_tree, \
												vImaginaryIndex - 1), \
										pIsToAdvance); \
							) \
	\
							/*return vKey;*/ \
						) \
						( \
							/*IT IS NOT IMPORTANT THAT THE VERY SAME ELEMENT THAT WE THE 
									INDEX FROM TO STORE IN THE INTERNAL NODE BE THE ONE
									FOUND. HENCE, WHEN pHAS_INDEX, NO SEARCHING FOR THE 
									EXACT ENTRY IS DONE.*/ \
	\
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
										pThis, 2, \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
												pThis->gPrivate_tree, \
												vImaginaryIndex /*+ 1*/)), \
										pIndices, pIndexInIndices + 1, \
										pIndex__guide, pElement, \
										CRXM__IFELSE2(pIS_TO_USE_DELEGATION, \
										pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
												pNode, pThis->gPrivate_tree, \
												vImaginaryIndex - 1), NULL)); \
							) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
										pThis, 2, \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
												pThis->gPrivate_tree, \
												vImaginaryIndex /*+ 1*/)), \
										pIndices, pIndexInIndices + 1, \
										pElement, \
										CRXM__IFELSE2(pIS_TO_USE_DELEGATION, \
										pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
												pELEMENT_TYPE, pNode, pThis->gPrivate_tree, \
												vImaginaryIndex - 1), NULL)); \
							) \
						) \
						/*vKey = __KB_KEY(pGUIDE_TYPE, pNode)[vImaginaryIndex - 1];*/ \
	\
						/*return vKey;*/ \
						CRXM__IFELSE(pIS_PREEMPTIVE) \
						( \
							tIsDone = true; \
						) \
						( \
							tIndexOfNextNode = vImaginaryIndex /*+ 1*/; \
						) \
					} \
					else if(tBranchToTake == -1) \
					{ \
						CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
						( \
							if(tNumberOfKeysInLeftNode == 0) \
							{ \
								tNumberOfKeysInLeftNode = (*(pINTERNAL__GET_NODE( \
										pTREE_TYPE_NAME, pNode, pThis->gPrivate_tree, \
										vImaginaryIndex - 1)))-> \
										gPrivate_numberOfEntries; \
							} \
	\
							CRXM__IFELSE(pHAS_INDEX) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
										pThis, 1, \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
												pThis->gPrivate_tree, vImaginaryIndex - 1)), \
										NULL, \
										pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, pNode, \
												pThis->gPrivate_tree, \
												vImaginaryIndex - 1), \
										pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
												pELEMENT_TYPE, pNode, \
												pThis->gPrivate_tree, \
												vImaginaryIndex - 1), \
										pIsToAdvance); \
							) \
							( \
								pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
										pThis, 1, \
										*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
												pThis->gPrivate_tree, vImaginaryIndex - 1)), \
										NULL, \
										pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, \
												pELEMENT_TYPE, pNode, \
												pThis->gPrivate_tree, vImaginaryIndex - 1), \
										pIsToAdvance); \
							) \
	\
							CRXM__IFELSE(pIS_PREEMPTIVE) \
							( \
								tIsDone = true; \
							) \
							( \
								tIndexOfNextNode = vImaginaryIndex - 1; \
							) \
	\
							assert(*pIsToAdvance == false); \
							*pIsToAdvance = true; \
						) \
						( \
							assert(false); \
						) \
					} \
					else \
					{ \
						CRXM__IFELSE(pIS_PREEMPTIVE) \
						( \
							assert(tBranchToTake == 0); \
	\
							/*THE FOLLOWING SHOULD ALWAYS BE TRUE IF I AM NOT WRONG, BUT \
									STICKING TO REFERENCE FOR NOW*/ \
							if((tNumberOfKeysInLeftNode == \
											pThis->gPrivate_tree-> \
											gPrviate_countOfMidElementInNode - 1) && \
									(tNumberOfKeysInRightNode == \
											pThis->gPrivate_tree-> \
											gPrviate_countOfMidElementInNode - 1)) \
							{ \
								pTREE_TYPE_NAME ## _Private_Node * tNode__left = \
										pMEMBER_FUNCTIONS_PREFIX ## mergeTwoNodesAndGetRemainingNode( \
										pThis->gPrivate_tree, pNode, vImaginaryIndex - 1); \
	\
								/*return pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
										pMode, pTree, tNode__left, pKey)*/ \
								CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
								( \
									/*THE FOLLOWING WOULD BE TRUE HERE: \
											pPosition__current == \
													pThis->gPrivate_position__current \
									*/ \
									(pPosition__current + 1)->gNode = tNode__left; \
									(pPosition__current + 1)->gIndex = \
											pThis->gPrivate_tree-> \
													gPrviate_countOfMidElementInNode - 1; \
	\
									(pThis->gPrivate_position__current)++; \
	\
									CRXM__IFELSE(pHAS_INDEX) \
									( \
										pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
												pThis, 0 /*pMode*/, tNode__left, \
												pPosition__current + 1, pIndex__guide, \
												pElement, pIsToAdvance); \
									) \
									( \
										pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
												pThis, 0 /*pMode*/, tNode__left, \
												pPosition__current + 1, pElement, pIsToAdvance); \
									) \
								) \
								( \
									pIndices[pIndexInIndices] = pIndices[pIndexInIndices] - 1; \
	\
									if(tNode__left->gPrivate_type) \
									{ \
										pIndices[pIndexInIndices + 1] = \
												pIndices[pIndexInIndices + 1] + \
												pThis->gPrivate_tree-> \
														gPrviate_countOfMidElementInNode; \
									} \
									else \
									{ \
										pIndices[pIndexInIndices + 1] = \
												pIndices[pIndexInIndices + 1] + \
												pThis->gPrivate_tree-> \
														gPrviate_countOfMidElementInNode - 1; \
	\
										pThis->gPrivate_node = tNode__left; \
										pThis->gPrivate_elementIndex = \
												pThis->gPrivate_elementIndex + \
												pThis->gPrivate_tree-> \
														gPrviate_countOfMidElementInNode - 1; \
									} \
	\
									CRXM__IFELSE(pHAS_INDEX) \
									( \
										pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
												pThis, 0 /*pMode*/, tNode__left, \
												pIndices, pIndexInIndices + 1, \
												pIndex__guide, pElement, pIndex__out); \
									) \
									( \
										pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
												pThis, 0 /*pMode*/, tNode__left, \
												pIndices, pIndexInIndices + 1, \
												pElement, pElement__out); \
									) \
								) \
	\
								tIsDone = true; \
							} \
							else \
								{assert(false);} \
						)() \
					} \
				} \
				CRX_SCOPE_END \
			} \
			else \
			{ \
				CRXM__IFELSE(CRXM__NOT(pIS_PREEMPTIVE)) \
				( \
					CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
					( \
						CRXM__IFELSE(pHAS_INDEX) \
						( \
							pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
									pThis, pMode, \
									*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
											pThis->gPrivate_tree, vImaginaryIndex /*+ 1*/)), \
									((pMode == 0) ? (pPosition__current + 1) : NULL), \
									pIndex__guide, pElement, pIsToAdvance); \
						) \
						( \
							pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
									pThis, pMode, \
									*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
											pThis->gPrivate_tree, vImaginaryIndex /*+ 1*/)), \
									((pMode == 0) ? (pPosition__current + 1) : NULL), \
									pElement, pIsToAdvance); \
						) \
					) \
					( \
						CRXM__IFELSE(pHAS_INDEX) \
						( \
							pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
									pThis, pMode, \
									*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
											pThis->gPrivate_tree, vImaginaryIndex /*+ 1*/)), \
									pIndices, pIndexInIndices + 1, \
									pIndex__guide, pElement, pIndex__out); \
						) \
						( \
							pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
									pThis, pMode, \
									*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
											pThis->gPrivate_tree, vImaginaryIndex /*+ 1*/)), \
									pIndices, pIndexInIndices + 1, pElement, pElement__out); \
						) \
					) \
				)() \
	\
				tIndexOfNextNode = vImaginaryIndex /*+ 1*/; \
			} \
	\
			if(!tIsDone) \
			{ \
				/*TO EASE ANALYSIS, 
					- REMEMBER THAT tNode BELOW IS ALWAYS THE NODE TO THE RIGHT \
							OF THE 'FOUND' ENTRY POSITION. THE ONLY EXCEPTION IS WHEN THE \
							ALGORITHM IS NOT PRE EMPTIVE, AND THE ELEMENT HAS ALREADY BEEN \
							FOUND ABOVE, AND ENTRIES ARE NOT STORED IN THE LEAVES ONLY AND THE \
							ALGORITHM ABOVE CHOOSE TO TAKE THE LEFT BRANCH TO HOIST AN ELEMENT \
							BACK UP. \
					- IF pIS_PREEMPTIVE AND (pMode == 0) AND \
							(vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0) \
							WE SHOULD NOT BE HERE AT ALL. \
					- IF PRIMARY ENTRIES ARE NOT IN THE LEAVES ONLY, AND \
							(vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == 0) \
							IT IS GUARANTEED THAT WE ARE AT THE END OF THE TRACE THAT IS IN \
							THE ITERATOR. IN OTHER WORDS, THE INDEX IN THE TRACE AT THAT \
							POINT, MEANING Iterator::Position::gIndex, IS THE INDEX OF THE \
							ELEMENT, AND NOT THE INDEX OF THE NEXT CHILD NODE AS IT IS \
							OTHERWISE. IF PRIMARY ENTRIES ARE IN THE LEAVES ONLY, THEN \
							REGARDLESS OF THE VALUE OF \
							vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode THE INDEX IN \
							THE TRACE THAT IS IN THE ITERATOR AT THAT POINT, MEANING \
							Iterator::Position::gIndex, IS THE INDEX OF THE NEXT NODE. \
				*/ \
	\
				pTREE_TYPE_NAME ## _Private_Node * tNode; \
	\
				tNode = *(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, pThis->gPrivate_tree, \
						tIndexOfNextNode)); \
	\
				/*WE HAVE TO USE '<=' INSTEAD OF '==' BECAUSE WE COULD BE FIXING UNDER FILLED 
						NODES AFTER THE FACT, MEANING THE ALGORITHM IS NOT PRE EMPTIVE.*/ \
				if(tNode->gPrivate_numberOfEntries <= \
						pThis->gPrivate_tree->gPrviate_countOfMidElementInNode - 1) \
				{ \
					assert(tNode->gPrivate_numberOfEntries >= \
							pThis->gPrivate_tree->gPrviate_countOfMidElementInNode - 2); \
	\
					/*NOTE THAT 'PREVIOUS' AND 'NEXT' AND SIMILAR ARE RELATIVE TO THE \
							KEY AT "tIndexOfNextNode - 1" WHICH IS THE KEY "FOUND" BY 
							private_getSuitableImagineryIndexFor() IN THE PREEMPTIVE CASE. \
							IN THE NON PREEMPTIVE CASE, tIndexOfNextNode IS EITHER THE
							INDEX OF THE BRANCH ALREADY TAKEN TO CONTINUE THE SEARCH, OR
							THE INDEX OF THE BRANCH TAKEN TO HOIST AN ELEMENT BACK UP TO WHERE 
							THE KEY WAS ALREADY FOUND. WHERE THE KEY WAS FOUND OR "FOUND"
							MIGHT BE TO THE RIGHT OR LEFT OF tIndexOfNextNode. \
					*/ \
					if((tIndexOfNextNode > 0) && \
							((*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
									pThis->gPrivate_tree, tIndexOfNextNode - 1)))-> \
											gPrivate_numberOfEntries >= \
									pThis->gPrivate_tree->gPrviate_countOfMidElementInNode)) \
					{ \
						/*ROTATE PREVIOUS CHILD NODE'S LAST KEY AND KEY AND NEXT \
								CHILD NODE'S FIRST KEY RIGHT */ \
						pMEMBER_FUNCTIONS_PREFIX ## private_rotateRight(pThis->gPrivate_tree, \
								(*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
										pThis->gPrivate_tree, tIndexOfNextNode - 1))), \
								tIndexOfNextNode - 1, pNode, tNode); \
	\
						CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
						( \
							/* THE FOLLOWING CHECK IS TO AVOID READING AND WRITING PAST \
									THE FURTHEST POSITION IN THE ITERATOR CURRENTLY. */ \
							if(pMode == 0) \
							{ \
								/* CHECKING WHICH BRANCH, RIGHT OR LEFT, WAS TAKEN WHEN NOT \
										pIS_PREEMPTIVE AND (pMode == 0) AND \
										(vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode \
												== 0) \
										MEANING WHEN HOISTING HAPPENED AND THE ALGORITHM IS \
										NOT PREEMPTIVE. REMEMBER, ONLY WITH HOISTING DO WE \
										CONSIDER TAKING THE 'LEFT' SIDE. OTHERWISE WE ARE \
										ALWAYS TAKING THE 'RIGHT' SIDE. \
								*/ \
								CRXM__IFELSE(pIS_PREEMPTIVE) \
								( \
									((pPosition__current + 1)->gIndex)++; \
								) \
								( \
									if(vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode != \
											0) \
										{((pPosition__current + 1)->gIndex)++;} \
									else \
									{ \
										if(tIndexOfNextNode == vImaginaryIndex) \
										{ \
											(pPosition__current->gIndex)++; \
											(pPosition__current + 1)->gIndex = 0; \
	\
											(pThis->gPrivate_position__current)++; \
											pThis->gPrivate_node = tNode; \
										} \
									} \
								) \
							} \
						) \
						( \
							pIndices[pIndexInIndices + 1] = pIndices[pIndexInIndices + 1] + 1; \
	\
							if(tNode->gPrivate_type == 0) \
							{ \
								pThis->gPrivate_elementIndex = \
										pThis->gPrivate_elementIndex + 1; \
							} \
						) \
					} \
					else if((tIndexOfNextNode < pNode->gPrivate_numberOfEntries) && \
							((*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
									pThis->gPrivate_tree, tIndexOfNextNode + 1)))-> \
									gPrivate_numberOfEntries >= \
									pThis->gPrivate_tree->gPrviate_countOfMidElementInNode)) \
					{ \
						/*ROTATE NEXT CHILD NODE'S LAST KEY AND PARENT NODE'S NEXT KEY AND \
								NEXT NEXT CHILD NODE'S FIRST KEY LEFT*/ \
						pMEMBER_FUNCTIONS_PREFIX ## private_rotateLeft(pThis->gPrivate_tree, \
								(*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
										pThis->gPrivate_tree, tIndexOfNextNode + 1))), \
								tIndexOfNextNode + 1, pNode, tNode); \
	\
						CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
						( \
							/*
							THE FOLLOWING CHECK IS TO AVOID READING AND WRITING PAST \
							THE FURTHEST POSITION IN THE ITERATOR CURRENTLY. \
							\
							THE FOLLOWING SHOULD NOT HAPPEN. IN OTHER WORDS WE SHOULD NOT \
							END UP HAVING WENT THROUGH THE LEFT NODE, BECAUSE IF THE ENTRY \
							WAS FOUND, AND BECAUSE THE ALGORITHM IS NOT PREEMPTIVE, THEN IF WE \
							ALREADY FINISHED HOISTING AND THROUGH THE LEFT NODE, THEN WE CAN \
							BE SURE THAT THE RIGHT NODE CAN NOT HAVE ENOUGH ENTRIES TO PASS \
							TO THE LEFT NODE BECAUSE THE ALGORITHM ABOVE THAT DECIDED TO HOIST \
							THROUGH THE LEFT NODE CHECKS THE RIGHT NODE FIRST. */ \
							if(pMode == 0) \
							{ \
								CRXM__IFELSE(CRXM__NOT(pIS_PREEMPTIVE)) \
								( \
									if(vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == \
											0) \
									{ \
										if(tIndexOfNextNode == (vImaginaryIndex - 1)) \
										{ \
											(pPosition__current + 1)->gIndex = tNode-> \
													gPrivate_numberOfEntries - 1; \
	\
											(pThis->gPrivate_position__current)++; \
											pThis->gPrivate_node = tNode; \
										} \
									} \
									else \
									{ \
										/*REMEMBER: IF WE DID NOT END IN THIS ELSE BRANCH THEN \
												ZeroIfFoundOrResultOfComparisonWithLargestKeyInNode \
												IS 0, AND THEREFORE pMode COULD NOT POSSIBLY \
												BE 0 WHEN WE GET TO THE LEAF, AND HENCE \
												*pIsToAdvance COULD NOT HAVE BEEN SET.*/ \
										if((tNode->gPrivate_type == 0) && \
												*pIsToAdvance) \
											{*pIsToAdvance = false;} \
									} \
								)() \
							} \
						)() \
					} \
					else if((tIndexOfNextNode > 0) && \
							((*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
									pThis->gPrivate_tree, tIndexOfNextNode - 1)))-> \
											gPrivate_numberOfEntries == \
							pThis->gPrivate_tree->gPrviate_countOfMidElementInNode - 1)) \
					{ \
						CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
								CRXM__NOT(pIS_PREEMPTIVE)), \
						bool tWasNextNodeTheCurrentIteratorNode = \
								CRX__ARE_POINTERS_TO_SAME_OBJECT(tNode, pThis->gPrivate_node, \
								false);, ) \
	\
						/*MERGE PREVIOUS CHILD NODE, KEY, AND NEXT CHILD NODE*/ \
						tNode = pMEMBER_FUNCTIONS_PREFIX ## mergeTwoNodesAndGetRemainingNode( \
								pThis->gPrivate_tree, pNode, tIndexOfNextNode - 1); \
	\
						CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
						( \
							if(pMode == 0) \
							{ \
								CRXM__IFELSE(pIS_PREEMPTIVE) \
								( \
									assert(pPosition__current->gIndex > 0); \
	\
									(pPosition__current->gIndex)--; \
									(pPosition__current + 1)->gNode = tNode; \
									(pPosition__current + 1)->gIndex = \
											(pPosition__current + 1)->gIndex + \
											pThis->gPrivate_tree-> \
											gPrviate_countOfMidElementInNode; \
								) \
								( \
									if(vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode != 0) \
									{ \
										assert(pPosition__current->gIndex > 0); \
	\
										(pPosition__current->gIndex)--; \
										(pPosition__current + 1)->gIndex = \
												(pPosition__current + 1)->gIndex + \
												pThis->gPrivate_tree-> \
												gPrviate_countOfMidElementInNode; \
	\
										if(tWasNextNodeTheCurrentIteratorNode) \
											{pThis->gPrivate_node = tNode;} \
									} \
									else \
									{ \
										if(tIndexOfNextNode == vImaginaryIndex) \
										{ \
											(pPosition__current + 1)->gIndex = \
													pThis->gPrivate_tree-> \
													gPrviate_countOfMidElementInNode; \
											(pThis->gPrivate_position__current)++; \
											pThis->gPrivate_node = tNode; \
										} \
									} \
								) \
							} \
						) \
						( \
							(pIndices[pIndexInIndices])--; \
	\
							if(tNode->gPrivate_type) \
							{ \
								pIndices[pIndexInIndices + 1] = \
										pIndices[pIndexInIndices + 1] + \
										pThis->gPrivate_tree->gPrviate_countOfMidElementInNode; \
							} \
							else \
							{ \
								pIndices[pIndexInIndices + 1] = \
										pIndices[pIndexInIndices + 1] + pThis-> \
										gPrivate_tree->gPrviate_countOfMidElementInNode - 1; \
	\
								pThis->gPrivate_node = tNode; \
								pThis->gPrivate_elementIndex = \
										pThis->gPrivate_elementIndex + \
										pThis->gPrivate_tree-> \
												gPrviate_countOfMidElementInNode - 1; \
							} \
						) \
	\
						tIndexOfNextNode = tIndexOfNextNode - 1; \
					} \
					else if((tIndexOfNextNode < pNode->gPrivate_numberOfEntries) && \
							((*(pINTERNAL__GET_NODE(pTREE_TYPE_NAME, pNode, \
									pThis->gPrivate_tree, tIndexOfNextNode + 1)))-> \
									gPrivate_numberOfEntries == \
									pThis->gPrivate_tree->gPrviate_countOfMidElementInNode - 1)) \
					{ \
						CRXM__IFELSE2(CRXM__AND(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
								CRXM__NOT(pIS_PREEMPTIVE)), \
						size_t tOldNumberOfEntries = \
								tNode->gPrivate_numberOfEntries;, ) \
	\
						/*MERGE NEXT CHILD NODE, NEXT KEY, AND NEXT NEXT CHILD NODE*/ \
						tNode = pMEMBER_FUNCTIONS_PREFIX ## mergeTwoNodesAndGetRemainingNode( \
								pThis->gPrivate_tree, pNode, tIndexOfNextNode); \
	\
						CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
						( \
							if(pMode == 0) \
							{ \
								CRXM__IFELSE(CRXM__NOT(pIS_PREEMPTIVE)) \
								( \
									if(vZeroIfFoundOrResultOfComparisonWithLargestKeyInNode == \
											0) \
									{ \
										if(tIndexOfNextNode == (vImaginaryIndex - 1)) \
										{ \
											/*REMEMBER THAT THE FOLLOWING IS NOT NECESSARILY \
													TRUE IN THE NON PREMPTIVE CASE. \
													(tNode->gPrivate_numberOfEntries == \
															pThis->gPrivate_tree-> \
															gPrviate_countOfMidElementInNode - \
															1) \
											*/ \
											(pPosition__current + 1)->gIndex = \
													tOldNumberOfEntries; \
											(pThis->gPrivate_position__current)++; \
											pThis->gPrivate_node = tNode; \
	\
											/*BECAUSE HOISTING HAPPENED FROM THE LEFT SIDE.*/ \
											*pIsToAdvance = true; \
										} \
									} \
									else \
									{ \
										/*REMEMBER: IF WE DID NOT END IN THIS ELSE BRANCH THEN \
												ZeroIfFoundOrResultOfComparisonWithLargestKeyInNode \
												IS 0, AND THEREFORE pMode COULD NOT POSSIBLY \
												BE 0 WHEN WE GET TO THE LEAF, AND HENCE \
												*pIsToAdvance COULD NOT HAVE BEEN SET.*/ \
										if((tNode->gPrivate_type == 0) && \
												*pIsToAdvance) \
											{*pIsToAdvance = false;} \
									} \
								)() \
							} \
						)() \
					} \
				} \
	\
				/* \
					NOTE THAT THE CODE ABOVE TAKES CARE OF THE IREGULAR SITUATION OF A NODE \
					HAVING NO KEYS, MAKING gPrivate_numberOfEntries == 0, WHILE STILL \
					HAVING ONE NODE. IN THE PREEMPTIVE CASE, THIS HAPPENS WHEN THERE IS ONE \
					LEAF REMAINIG, AND THAT WOULD MEAN ONE INTERNAL NODE REMAINING, AND THAT \
					WOULD BE THE ROOT NODE. THAT INTERNAL NODE WOULD HAVE A SINGLE CHILD NODE, \
					THE LEAF, AND NO KEYS. IN THE NON PRE EMPTIVE CASE, THIS HAPPENS BECAUSE \
					WE ONLY CHECK THE NODES ON THE WAY BACK UP TO MAKE SURE THAT THEY ARE NOT \
					TOO EMPTY, AND 'N', SEE NOTES ABOVE, COULD BE 2, WHICH MEANS N - 1, THE \
					MINIMAL ALLOWED LENGTH OF A NODE COULD BE 1, WHICH MEANS THAT IF A MERGER 
					HAPPENS ON THE WAY DOWN THE LENGTH COULD BECOME 0, AND THE CODE ABOVE \
					WOULD OBSERVE '0' THAT ON THE WAY UP. \
				*/ \
				/*return pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do(pMode, pTree, \
						tNode, pKey); */ \
				CRXM__IFELSE(pIS_PREEMPTIVE) \
				( \
					CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
					( \
						CRXM__IFELSE(pHAS_INDEX) \
						( \
							pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
									pThis, pMode, tNode, pPosition__current + 1, \
									pIndex__guide, pElement, pIsToAdvance); \
						) \
						( \
							pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
									pThis, pMode, tNode, pPosition__current + 1, pElement, \
									pIsToAdvance); \
						) \
					) \
					( \
						CRXM__IFELSE(pHAS_INDEX) \
						( \
							pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
									pThis, pMode, tNode, pIndices, pIndexInIndices + 1, \
									pIndex__guide, pElement, pIndex__out); \
						) \
						( \
							pMEMBER_FUNCTIONS_PREFIX ## iterator_private_remove__do( \
									pThis, pMode, tNode, pIndices, pIndexInIndices + 1, \
									pElement, pElement__out); \
						) \
					) \
				)() \
			} \
		} \
		else \
		{ \
			/*REMEMBER: IF WE ARE HERE, WE DEFINATELY 'FOUND' WHAT WE ARE SEARCHING FOR.*/ \
			CRXM__IFELSE2(pIS_TO_USE_RINGS, \
			bool tIsToRotateRight = ((pNode->gPrivate_numberOfEntries >> 1) > \
					(vImaginaryIndex - 1));, ) \
	\
			/*vKey = __KB_KEY(pGUIDE_TYPE, pNode)[vImaginaryIndex - 1];*/ \
			CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
			( \
				if(pMode != 0) \
				{ \
					CRXM__IFELSE(pHAS_INDEX) \
					( \
						CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
						( \
							CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT(sizeof(pINDEX_TYPE), \
									pFUNC_INDEX_MOVE_CONSTRUCTOR, \
									pFUNC_INDEX_MOVE_DESTRUCTOR, pIndex__guide, \
									pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, \
									pThis->gPrivate_tree, vImaginaryIndex - 1)); \
						) \
						( \
							pCONSTRUCT_INDEX_FROM(pIndex__guide, \
									pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pNode, pThis->gPrivate_tree, vImaginaryIndex - 1)); \
						) \
					)() \
	\
					CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT( \
							sizeof(CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
									pELEMENT_TYPE)), \
							CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
									pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
							CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
									pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
							pElement, \
							pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
									pNode, pThis->gPrivate_tree, vImaginaryIndex - 1)); \
				} \
				else \
				{ \
					CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
					pFUNC_ELEMENT_DESTRUCTOR(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
							pELEMENT_TYPE, pNode, pThis->gPrivate_tree, \
							vImaginaryIndex - 1));, ) \
	\
					CRXM__IFELSE2(pIS_PERSISTANT, \
					free(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
							pThis->gPrivate_tree, vImaginaryIndex - 1));, ) \
				} \
	\
				CRXM__IFELSE(CRXM__AND(pHAS_INDEX, \
						CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY))) \
				( \
					CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
							pINDEX_TYPE, \
							pFUNC_INDEX_MOVE_CONSTRUCTOR, \
							pFUNC_INDEX_MOVE_DESTRUCTOR, \
							2 * pThis->gPrivate_tree->gPrviate_countOfMidElementInNode, \
							pNode, \
							pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis->gPrivate_tree, 0), \
							pNode->gPrivate_numberOfEntries, \
							vImaginaryIndex - 1, 1, tIsToRotateRight) \
				)() \
	\
				CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
						CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
								pELEMENT_TYPE), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						2 * pThis->gPrivate_tree->gPrviate_countOfMidElementInNode, \
						pNode, \
						pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
								pThis->gPrivate_tree, 0), \
						pNode->gPrivate_numberOfEntries, \
						vImaginaryIndex - 1, 1, tIsToRotateRight) \
	\
				CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_REMOVAL_OF_SPACE(pIS_TO_USE_RINGS, \
						2 * pThis->gPrivate_tree->gPrviate_countOfMidElementInNode, pNode, 1, \
						tIsToRotateRight); \
	\
				if(pMode == 0) \
				{ \
					CRXM__IFELSE(pIS_PREEMPTIVE) \
					( \
						if(vImaginaryIndex == \
								(pNode->gPrivate_numberOfEntries /*- 1*/)) \
							{*pIsToAdvance = true;} \
					) \
					( \
						if((pNode->gPrivate_numberOfEntries == 0) || \
								(vImaginaryIndex == \
										(pNode->gPrivate_numberOfEntries /*- 1*/))) \
							{*pIsToAdvance = true;} \
					) \
				} \
			) \
			( \
				CRXM__IFELSE2(pFUNC_ELEMENT_DESTRUCTOR, \
				pFUNC_ELEMENT_DESTRUCTOR(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
						pELEMENT_TYPE, pNode, pThis->gPrivate_tree, \
						vImaginaryIndex - 1));, ) \
	\
				CRXM__IFELSE2(pIS_PERSISTANT, \
				free(pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pNode, \
						pThis->gPrivate_tree, vImaginaryIndex - 1));, ) \
	\
				CRXM__IFELSE(CRXM__AND(pHAS_INDEX, \
						CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY))) \
				( \
					CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
							pINDEX_TYPE, \
							pFUNC_INDEX_MOVE_CONSTRUCTOR, pFUNC_INDEX_MOVE_DESTRUCTOR, \
							2 * pThis->gPrivate_tree->gPrviate_countOfMidElementInNode, \
							pNode, \
							pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, pThis->gPrivate_tree, 0), \
							pNode->gPrivate_numberOfEntries, \
							vImaginaryIndex - 1, 1, tIsToRotateRight) \
				)() \
	\
				CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_TO_USE_RINGS, \
						CRXM__IFELSE2(pIS_PERSISTANT, pELEMENT_TYPE *, \
								pELEMENT_TYPE), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_CONSTRUCTOR), \
						CRXM__IFELSE2(pIS_PERSISTANT, CRXM__FALSE, \
								pFUNC_ELEMENT_MOVE_DESTRUCTOR), \
						2 * pThis->gPrivate_tree->gPrviate_countOfMidElementInNode, \
						pNode, \
						pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
								pNode, pThis->gPrivate_tree, 0), \
						pNode->gPrivate_numberOfEntries, \
						vImaginaryIndex - 1, 1, tIsToRotateRight) \
	\
				CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_REMOVAL_OF_SPACE(pIS_TO_USE_RINGS, \
						2 * pThis->gPrivate_tree->gPrviate_countOfMidElementInNode, \
						pNode, 1, tIsToRotateRight); \
	\
				CRXM__IFELSE(pIS_TO_USE_DELEGATION) \
				( \
					if(pMode != 0) \
					{ \
						/*WHEN USING DELEGATION, HOISTING IS REUIQRED, AND THEREFORE \
								SUCH TREES MUST HAVE N >= 3 AS TO KEEP THE FOLLOWING \
								ASSERTION TRUE. REMEMBER THAT IF N IS 2, AND THE \
								ALGORITHM IS NOT PRE EMPTIVE, pNode COULD NOW BE EMPTY \
								AFTER THE REMOVAL ABOVE, AND HENCE IT WOULD HAVE \
								NOTHING LEFT FOR HOISTING. \
						*/ \
						assert(pNode->gPrivate_numberOfEntries > 1); \
						/*WARNING: REMEMBER, THE LENGTH IS NOT YET UPDATED AT THIS POINT,
								HENCE THE '- 1'.*/ \
						if(pMode == 1) \
							{vImaginaryIndex = pNode->gPrivate_numberOfEntries - 1 /*2*/;} \
						else /*pMode == 2*/ \
							{vImaginaryIndex = 1 /*0*/;} \
	\
						CRXM__IFELSE(pHAS_INDEX) \
						( \
							CRXM__IFELSE(CRXM__NOT(pARE_INDICES_IN_INTERNAL_NODES_ONLY)) \
							( \
								memcpy(pIndex__out, \
										pLEAF__GET_INDEX(pTREE_TYPE_NAME, pNode, \
												pThis->gPrivate_tree, vImaginaryIndex - 1), \
										sizeof(pINDEX_TYPE)); \
							) \
							( \
								pCONSTRUCT_INDEX_FROM(pIndex__out, \
										pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
												pELEMENT_TYPE, pNode, pThis->gPrivate_tree, \
												vImaginaryIndex - 1)); \
							) \
						) \
						( \
							CRXM__IFELSE(CRXM__NOT(pIS_PERSISTANT)) \
							( \
								CRXM__IFELSE(pFUNC_ELEMENT_COPY_CONSTRUCTOR) \
								( \
									pFUNC_ELEMENT_COPY_CONSTRUCTOR(pElement__out, \
											pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, pNode, \
													pThis->gPrivate_tree, \
													vImaginaryIndex - 1)); \
								) \
								( \
									memcpy(pElement__out, \
											pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
													pELEMENT_TYPE, pNode, \
													pThis->gPrivate_tree, \
													vImaginaryIndex - 1), \
											sizeof(pELEMENT_TYPE)); \
								) \
							) \
							( \
								*pElement__out = pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, \
										pELEMENT_TYPE, pNode, pThis->gPrivate_tree, \
										vImaginaryIndex - 1); \
							) \
						) \
					} \
				)() \
			) \
	\
			--(pNode->gPrivate_numberOfEntries); \
	\
			/*return vKey;*/ \
		} \
	} \
	\
	PUBLIC pELEMENT_TYPE * pMEMBER_FUNCTIONS_PREFIX ## iterator_get( \
			pTREE_TYPE_NAME ## _Iterator const * pThis) \
	{ \
		if(pThis->gPrivate_isConstant) \
			{return NULL;} \
	\
		return pMEMBER_FUNCTIONS_PREFIX ## iterator_private_doGet(pThis); \
	} \
	PUBLIC pELEMENT_TYPE const * pMEMBER_FUNCTIONS_PREFIX ## iterator_constantGet( \
			pTREE_TYPE_NAME ## _Iterator const * pThis) \
		{return pMEMBER_FUNCTIONS_PREFIX ## iterator_private_doGet(pThis);} \
	PRIVATE pELEMENT_TYPE * pMEMBER_FUNCTIONS_PREFIX ## iterator_private_doGet( \
			pTREE_TYPE_NAME ## _Iterator const * pThis) \
	{ \
		if(pThis->gPrivate_tree == NULL) \
			{return NULL;} \
	\
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			if(pThis->gPrivate_position__current == pThis->gPrivate_positions) \
				{return NULL;} \
			else \
			{ \
				if(CRXM__IFELSE2(pIS_PREEMPTIVE, pThis->gPrivate_position__current->gNode, \
						pThis->gPrivate_node)->gPrivate_type) \
				{ \
					return pINTERNAL__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
							CRXM__IFELSE2(pIS_PREEMPTIVE, pThis->gPrivate_position__current->gNode, \
							pThis->gPrivate_node), pThis->gPrivate_tree, \
							pThis->gPrivate_position__current->gIndex); \
				} \
				else \
				{ \
					return pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, \
							CRXM__IFELSE2(pIS_PREEMPTIVE, pThis->gPrivate_position__current->gNode, \
							pThis->gPrivate_node), pThis->gPrivate_tree, \
							pThis->gPrivate_position__current->gIndex); \
				} \
			} \
		) \
		( \
			if(pThis->gPrivate_node == NULL) \
				{return NULL;} \
			else \
			{ \
				return pLEAF__GET_ELEMENT(pTREE_TYPE_NAME, pELEMENT_TYPE, pThis->gPrivate_node, \
						pThis->gPrivate_tree, pThis->gPrivate_elementIndex); \
			} \
		) \
	} \
	\
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPush( \
			pTREE_TYPE_NAME ## _Iterator * pThis, pTREE_TYPE_NAME ## _Private_Node * pNode, \
			size_t pIndex) \
	{ \
		if(pThis->gPrivate_positions == NULL) \
			{return false;} \
	\
		pThis->gPrivate_position__current++; \
	\
		CRXM__IFELSE(pIS_PREEMPTIVE) \
		( \
			pThis->gPrivate_position__current->gNode = pNode; \
		) \
		( \
			assert(pNode->gPrivate_node__parent == pThis->gPrivate_node); \
	\
			pThis->gPrivate_node = pNode; \
		) \
		pThis->gPrivate_position__current->gIndex = pIndex; \
	\
		return true; \
	}, ) \
	CRXM__IFELSE2(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY), \
	PRIVATE void pMEMBER_FUNCTIONS_PREFIX ## iterator_private_depthPop( \
			pTREE_TYPE_NAME ## _Iterator * pThis) \
	{ \
		if((pThis->gPrivate_positions != NULL) && \
				(pThis->gPrivate_position__current != pThis->gPrivate_positions)) \
		{ \
			pThis->gPrivate_position__current--; \
			CRXM__IFELSE2(CRXM__NOT(pIS_PREEMPTIVE), \
			pThis->gPrivate_node = pThis->gPrivate_node->gPrivate_node__parent;, ) \
		} \
	}, ) \
	\
	CRXM__IFELSE2(pHAS_INDEX, \
	PRIVATE bool pMEMBER_FUNCTIONS_PREFIX ## iterator_private_isInInternalNode( \
			pTREE_TYPE_NAME ## _Iterator * pThis) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			assert(pThis->gPrivate_position__current != pThis->gPrivate_positions); \
	\
			return (CRXM__IFELSE2(pIS_PREEMPTIVE, pThis->gPrivate_position__current->gNode, \
						pThis->gPrivate_node)->gPrivate_type != 0); \
		) \
		( \
			assert(pThis->gPrivate_node != NULL); \
	\
			return false; \
		) \
	}, ) \
	CRXM__IFELSE2(pHAS_INDEX, \
	PRIVATE pINDEX_TYPE * pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getIndex( \
			pTREE_TYPE_NAME ## _Iterator * pThis) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			if(pThis->gPrivate_position__current == pThis->gPrivate_positions) \
				{return NULL;} \
			else \
			{ \
				if(CRXM__IFELSE2(pIS_PREEMPTIVE, pThis->gPrivate_position__current->gNode, \
						pThis->gPrivate_node)->gPrivate_type) \
				{ \
					return pINTERNAL__GET_INDEX(pTREE_TYPE_NAME, \
							CRXM__IFELSE2(pIS_PREEMPTIVE, \
							pThis->gPrivate_position__current->gNode, pThis->gPrivate_node), \
							pThis->gPrivate_tree, pThis->gPrivate_position__current->gIndex); \
				} \
				else \
				{ \
					CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
					( \
						return NULL; \
					) \
					( \
						return pLEAF__GET_INDEX(pTREE_TYPE_NAME, \
								CRXM__IFELSE2(pIS_PREEMPTIVE, \
								pThis->gPrivate_position__current->gNode, pThis->gPrivate_node), \
								pThis->gPrivate_tree, pThis->gPrivate_position__current->gIndex); \
					) \
				} \
			} \
		) \
		( \
			if(pThis->gPrivate_node == NULL) \
				{return NULL;} \
			else \
			{ \
				CRXM__IFELSE(pARE_INDICES_IN_INTERNAL_NODES_ONLY) \
				( \
					return NULL; \
				) \
				( \
					return pLEAF__GET_INDEX(pTREE_TYPE_NAME, pThis->gPrivate_node, \
							pThis->gPrivate_tree, pThis->gPrivate_elementIndex); \
				) \
			} \
		) \
	}, ) \
	CRXM__IFELSE2(pHAS_INDEX, \
	CRXM__IFELSE2(pIS_PERSISTANT, \
	PRIVATE pELEMENT_TYPE * * pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getEntry( \
			pTREE_TYPE_NAME ## _Iterator * pThis), \
	PRIVATE pELEMENT_TYPE * pMEMBER_FUNCTIONS_PREFIX ## iterator_private_getEntry( \
			pTREE_TYPE_NAME ## _Iterator * pThis)) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_ELEMENT_DATA_IN_LEAVES_ONLY)) \
		( \
			if(pThis->gPrivate_position__current == pThis->gPrivate_positions) \
				{return NULL;} \
			else \
			{ \
				if(CRXM__IFELSE2(pIS_PREEMPTIVE, pThis->gPrivate_position__current->gNode, \
						pThis->gPrivate_node)->gPrivate_type) \
				{ \
					return pINTERNAL__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
							CRXM__IFELSE2(pIS_PREEMPTIVE, pThis->gPrivate_position__current->gNode, \
							pThis->gPrivate_node), pThis->gPrivate_tree, \
							pThis->gPrivate_position__current->gIndex); \
				} \
				else \
				{ \
					return pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
							CRXM__IFELSE2(pIS_PREEMPTIVE, pThis->gPrivate_position__current->gNode, \
							pThis->gPrivate_node), pThis->gPrivate_tree, \
							pThis->gPrivate_position__current->gIndex); \
				} \
			} \
		) \
		( \
			if(pThis->gPrivate_node == NULL) \
				{return NULL;} \
			else \
			{ \
				return pLEAF__GET_ELEMENT_ENTRY(pTREE_TYPE_NAME, pELEMENT_TYPE, \
						pThis->gPrivate_node, pThis->gPrivate_tree, pThis->gPrivate_elementIndex); \
			} \
		) \
	}, )
//#END_DEFINE

/*
	MEANT TO TRANSFER THE CONTENT OF THE SEPERATE BUFFERS IN THE NODES, WHERE EACH CALL IS TO 
	TRANSFER ONE BUFFER'S CONTENT. THE TARGET SPACE MUST ALREADY BE EMPTY.
	
	BASED ON CRX__C__RING__ECHO__COPY_FROM_RING_RANGE.
	
	WARNING: pCAPACITY_WHEN_RING MUST BE THE VALUE APPROPRIATE FOR THE RING MODE.
*/
#define CRX__C__TREE__PRIVATE__TRANSFER(pIS_RING, pTYPE, pFUNC_TYPE_MOVE_CONSTRUCTOR, \
		pFUNC_TYPE_MOVE_DESTRUCTOR, pCAPACITY_WHEN_RING, pTARGET, pTARGET__NODE, pTARGET__INDEX, \
		pSRC, pSRC__NODE, pSRC__INDEX, pCOUNT) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_RING)) \
		( \
			CRXM__IFELSE(CRXM__OR(pFUNC_TYPE_MOVE_CONSTRUCTOR, pFUNC_TYPE_MOVE_DESTRUCTOR)) \
			( \
				CRXM__IFELSE(pFUNC_TYPE_MOVE_CONSTRUCTOR) \
				( \
					CRX_FOR(size_t tI = 0, tI < pCOUNT, tI++) \
					{ \
						pFUNC_TYPE_MOVE_CONSTRUCTOR(pTARGET + pTARGET__INDEX + tI, \
								pSRC + pSRC__INDEX + tI); \
\
						CRXM__IFELSE2(pFUNC_TYPE_MOVE_DESTRUCTOR, \
						pFUNC_TYPE_MOVE_DESTRUCTOR(pSRC + pSRC__INDEX + tI);, ) \
					} \
					CRX_ENDFOR \
				) \
				( \
					CRX_FOR(size_t tI = 0, tI < pCOUNT, tI++) \
					{ \
						memcpy(pTARGET + pTARGET__INDEX + tI, \
								pSRC + pSRC__INDEX + tI, sizeof(pTYPE)); \
\
						CRXM__IFELSE2(pFUNC_TYPE_MOVE_DESTRUCTOR, \
						pFUNC_TYPE_MOVE_DESTRUCTOR(pSRC + pSRC__INDEX + tI);, ) \
					} \
					CRX_ENDFOR \
				) \
			) \
			( \
				memcpy(pTARGET + pTARGET__INDEX, pSRC + pSRC__INDEX, \
						sizeof(pTYPE) * pCOUNT); \
			) \
		) \
		( \
			pTYPE * tTarget = pTARGET - pTARGET__NODE->gPrivate_startIndex; \
			pTYPE * tSrc = pSRC - pSRC__NODE->gPrivate_startIndex; \
\
			CRXM__IFELSE(CRXM__OR(pFUNC_TYPE_MOVE_CONSTRUCTOR, pFUNC_TYPE_MOVE_DESTRUCTOR)) \
			( \
				CRXM__IFELSE(pFUNC_TYPE_MOVE_CONSTRUCTOR) \
				( \
					CRX_FOR(size_t tI = 0, tI < pCOUNT, tI++) \
					{ \
						pFUNC_TYPE_MOVE_CONSTRUCTOR(tTarget + \
										((pTARGET__NODE->gPrivate_startIndex + tI + \
										pTARGET__INDEX) & (pCAPACITY_WHEN_RING - 1)), \
								tSrc + ((pSRC__NODE->gPrivate_startIndex + tI + pSRC__INDEX) & \
										(pCAPACITY_WHEN_RING - 1))); \
\
						CRXM__IFELSE2(pFUNC_TYPE_MOVE_DESTRUCTOR, \
						pFUNC_TYPE_MOVE_DESTRUCTOR(tSrc + ((pSRC__NODE->gPrivate_startIndex + tI + \
								pSRC__INDEX) & (pCAPACITY_WHEN_RING - 1)));, ) \
					} \
					CRX_ENDFOR \
				) \
				( \
					CRX_FOR(size_t tI = 0, tI < pCOUNT, tI++) \
					{ \
						memcpy(tTarget + ((pTARGET__NODE->gPrivate_startIndex + tI + \
										pTARGET__INDEX) & (pCAPACITY_WHEN_RING - 1)), \
								tSrc + ((pSRC__NODE->gPrivate_startIndex + tI + pSRC__INDEX) & \
										(pCAPACITY_WHEN_RING - 1)), sizeof(pTYPE)); \
\
						CRXM__IFELSE2(pFUNC_TYPE_MOVE_DESTRUCTOR, \
						pFUNC_TYPE_MOVE_DESTRUCTOR(tSrc + ((pSRC__NODE->gPrivate_startIndex + tI + \
								pSRC__INDEX) & (pCAPACITY_WHEN_RING - 1)));, ) \
					} \
					CRX_ENDFOR \
				) \
			) \
			( \
				size_t tTargetStartIndex = ((pTARGET__NODE->gPrivate_startIndex + \
						pTARGET__INDEX) & (pCAPACITY_WHEN_RING - 1)); \
				size_t tTargetSegmentLength = ((tTargetStartIndex >= \
								pTARGET__NODE->gPrivate_startIndex) ? \
						((((pTARGET__NODE->gPrivate_startIndex + pTARGET__INDEX + pCOUNT - 1) & \
								(pCAPACITY_WHEN_RING - 1)) >= tTargetStartIndex) ? pCOUNT : \
								(pCAPACITY_WHEN_RING - tTargetStartIndex)) : \
						pCOUNT); \
				size_t tSourceStartIndex = ((pSRC__NODE->gPrivate_startIndex + pSRC__INDEX) & \
						(pCAPACITY_WHEN_RING - 1)); \
				size_t tSourceSegmentLength = ((tSourceStartIndex >= pSRC__NODE->gPrivate_startIndex) ? \
						((((pSRC__NODE->gPrivate_startIndex + pSRC__INDEX + pCOUNT - 1) & \
								(pCAPACITY_WHEN_RING - 1)) >= tSourceStartIndex) ? pCOUNT : \
								(pCAPACITY_WHEN_RING - tSourceStartIndex)) : \
						pCOUNT); \
\
				if(tTargetSegmentLength <= tSourceSegmentLength) \
				{ \
					memcpy(tTarget + tTargetStartIndex, tSrc + tSourceStartIndex, \
							tTargetSegmentLength * sizeof(pTYPE)); \
\
					if(tTargetSegmentLength < pCOUNT) \
					{ \
						assert(((pTARGET__NODE->gPrivate_startIndex + pTARGET__INDEX + \
								tTargetSegmentLength) & (pCAPACITY_WHEN_RING - 1)) == 0); \
\
						memcpy(tTarget, tSrc + tSourceStartIndex + tTargetSegmentLength, \
								(tSourceSegmentLength - tTargetSegmentLength) * sizeof(pTYPE)); \
\
						if(tSourceSegmentLength < pCOUNT) \
						{ \
							assert(((pSRC__NODE->gPrivate_startIndex + tSourceStartIndex + \
									tSourceSegmentLength) & (pCAPACITY_WHEN_RING - 1)) == 0); \
\
							memcpy(tTarget + tSourceSegmentLength - tTargetSegmentLength, tSrc, \
									(pCOUNT - tSourceSegmentLength) * sizeof(pTYPE)); \
						} \
					} \
				} \
				else \
				{ \
					memcpy(tTarget + tTargetStartIndex, tSrc + tSourceStartIndex, \
							tSourceSegmentLength * sizeof(pTYPE)); \
\
					assert(((pSRC__NODE->gPrivate_startIndex + pSRC__INDEX + tSourceSegmentLength) & \
							(pCAPACITY_WHEN_RING - 1)) == 0); \
\
					memcpy(tTarget + tTargetStartIndex + tSourceSegmentLength, tSrc, \
							(tTargetSegmentLength - tSourceSegmentLength) * sizeof(pTYPE)); \
\
					if(tTargetSegmentLength < pCOUNT) \
					{ \
						assert(((pTARGET__NODE->gPrivate_startIndex + pTARGET__INDEX + tTargetSegmentLength) & \
								(pCAPACITY_WHEN_RING - 1)) == 0); \
\
						memcpy(tTarget, tSrc + tTargetSegmentLength - tSourceSegmentLength, \
								(pCOUNT - tTargetSegmentLength) * sizeof(pTYPE)); \
					} \
				} \
			) \
		) \
	}
	
/*
	MEANT TO COPY THE CONTENT OF THE SEPERATE BUFFERS IN THE NODES, WHERE EACH CALL IS TO COPY 
	ONE BUFFER'S CONTENT. THE TARGET SPACE MUST ALREADY BE EMPTY.

	BASED ON CRX__C__RING__ECHO__COPY_FROM_RING_RANGE.

	WARNING: pCAPACITY MUST BE THE VALUE APPROPRIATE FOR THE RING MODE.
*/
#define CRX__C__TREE__PRIVATE__COPY(pIS_RING, pTYPE, pFUNC_TYPE_COPY_CONSTRUCTOR, \
		pCAPACITY_WHEN_RING, pTARGET, pTARGET__NODE, pTARGET__INDEX, \
		pSRC, pSRC__NODE, pSRC__INDEX, pCOUNT) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_RING)) \
		( \
			CRXM__IFELSE(pFUNC_TYPE_COPY_CONSTRUCTOR) \
			( \
				CRX_FOR(size_t tI = 0, tI < pCOUNT, tI++) \
				{ \
					pFUNC_TYPE_COPY_CONSTRUCTOR(pTARGET + pTARGET__INDEX + tI, \
							pSRC + pSRC__INDEX + tI); \
				} \
				CRX_ENDFOR \
			) \
			( \
				memcpy(pTARGET + pTARGET__INDEX, pSRC + pSRC__INDEX, \
						sizeof(pTYPE) * pCOUNT); \
			) \
		) \
		( \
			pTYPE * tTarget = pTARGET - pTARGET__NODE->gPrivate_startIndex; \
			pTYPE * tSrc = pSRC - pSRC__NODE->gPrivate_startIndex; \
\
			CRXM__IFELSE(pFUNC_TYPE_COPY_CONSTRUCTOR) \
			( \
				CRX_FOR(size_t tI = 0, tI < pCOUNT, tI++) \
				{ \
					pFUNC_TYPE_COPY_CONSTRUCTOR(tTarget + \
									((pTARGET__NODE->gPrivate_startIndex + tI + \
									pTARGET__INDEX) & (pCAPACITY_WHEN_RING - 1)), \
							tSrc + ((pSRC__NODE->gPrivate_startIndex + tI + pSRC__INDEX) & \
									(pCAPACITY_WHEN_RING - 1))); \
				} \
				CRX_ENDFOR \
			) \
			( \
				size_t tTargetStartIndex = ((pTARGET__NODE->gPrivate_startIndex + \
						pTARGET__INDEX) & (pCAPACITY_WHEN_RING - 1)); \
				size_t tTargetSegmentLength = ((tTargetStartIndex >= \
								pTARGET__NODE->gPrivate_startIndex) ? \
						((((pTARGET__NODE->gPrivate_startIndex + pTARGET__INDEX + pCOUNT - 1) & \
								(pCAPACITY_WHEN_RING - 1)) >= tTargetStartIndex) ? pCOUNT : \
								(pCAPACITY_WHEN_RING - tTargetStartIndex)) : \
						pCOUNT); \
				size_t tSourceStartIndex = ((pSRC__NODE->gPrivate_startIndex + pSRC__INDEX) & \
						(pCAPACITY_WHEN_RING - 1)); \
				size_t tSourceSegmentLength = ((tSourceStartIndex >= pSRC__NODE->gPrivate_startIndex) ? \
						((((pSRC__NODE->gPrivate_startIndex + pSRC__INDEX + pCOUNT - 1) & \
								(pCAPACITY_WHEN_RING - 1)) >= tSourceStartIndex) ? pCOUNT : \
								(pCAPACITY_WHEN_RING - tSourceStartIndex)) : \
						pCOUNT); \
\
				if(tTargetSegmentLength <= tSourceSegmentLength) \
				{ \
					memcpy(tTarget + tTargetStartIndex, tSrc + tSourceStartIndex, \
							tTargetSegmentLength * sizeof(pTYPE)); \
\
					if(tTargetSegmentLength < pCOUNT) \
					{ \
						assert(((pTARGET__NODE->gPrivate_startIndex + pTARGET__INDEX + \
								tTargetSegmentLength) & (pCAPACITY_WHEN_RING - 1)) == 0); \
\
						memcpy(tTarget, tSrc + tSourceStartIndex + tTargetSegmentLength, \
								(tSourceSegmentLength - tTargetSegmentLength) * sizeof(pTYPE)); \
\
						if(tSourceSegmentLength < pCOUNT) \
						{ \
							assert(((pSRC__NODE->gPrivate_startIndex + tSourceStartIndex + \
									tSourceSegmentLength) & (pCAPACITY_WHEN_RING - 1)) == 0); \
\
							memcpy(tTarget + tSourceSegmentLength - tTargetSegmentLength, tSrc, \
									(pCOUNT - tSourceSegmentLength) * sizeof(pTYPE)); \
						} \
					} \
				} \
				else \
				{ \
					memcpy(tTarget + tTargetStartIndex, tSrc + tSourceStartIndex, \
							tSourceSegmentLength * sizeof(pTYPE)); \
\
					assert(((pSRC__NODE->gPrivate_startIndex + pSRC__INDEX + tSourceSegmentLength) & \
							(pCAPACITY_WHEN_RING - 1)) == 0); \
\
					memcpy(tTarget + tTargetStartIndex + tSourceSegmentLength, tSrc, \
							(tTargetSegmentLength - tSourceSegmentLength) * sizeof(pTYPE)); \
\
					if(tTargetSegmentLength < pCOUNT) \
					{ \
						assert(((pTARGET__NODE->gPrivate_startIndex + pTARGET__INDEX + tTargetSegmentLength) & \
								(pCAPACITY_WHEN_RING - 1)) == 0); \
\
						memcpy(tTarget, tSrc + tTargetSegmentLength - tSourceSegmentLength, \
								(pCOUNT - tTargetSegmentLength) * sizeof(pTYPE)); \
					} \
				} \
			) \
		) \
	}
	
	
/*
	WARNING: pCAPACITY_WHEN_RING MUST BE THE VALUE APPROPRIATE FOR THE RING MODE.
	WARNING: THIS DOES NOT UPDATE THE STARTING INDEX. 
			CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_INSERTION_OF_SPACE() MUST BE CALLED 
			LATER TO DO SO.
	
	THIS FUNCTION IS A COPY OF A SIMILAR FUNCTION FROM THE RING CLASS, THE OLD IMPLEMENTATION
	OF CRX__C__Ring__ECHO_INSERT_SPACE_AT(), AND LIKE THAT IMPLEMENTATION, THIS FUNCTION DOES NOT 
	ATTEMPT TO REDUCE THE RANGE OF CALCULATIONS OVER size_t, MAKING THE MAXIMUM CAPACITY ALLOWED TO 
	BE 1/3 OF size_t, UNLIKE THE RING WHERE IT IS 1/2 UNDER THE NEW IMPLEMENTATION OF
	CRX__C__Ring__ECHO_INSERT_SPACE_AT(). IN OUR CASE, WE WOULD BE ELEMINATING THE FIRST TWO BITS 
	FROM uint32_t GIVING A MAXIMUM CAPACITY PER NODE OF 2^30. THIS IS ALSO THE REASON BEHIND THE 
	SIMPLIFIED IMPLEMENTATION IN 
	CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_INSERTION_OF_SPACE() AND WHY WE CAN AVOID 
	pFUNC_TYPE_MOVE_CONSTRUCTOR AND pFUNC_TYPE_MOVE_DESTRUCTOR IN THAT FUNCTION.
	
	TO KEEP THE ROTATION CONSISTANT BETWEEN ALL BUFFERS WITHIN THE SAME NODE FOR THE SAME HIGH
	LEVEL OPERATION, IT IS UP TO THE USER TO DECIDE WHICH DIRECTION THE ROTATION HAPPENS TO CREATE
	THE SPACE. HOWEVER, IF pINDEX IS ZERO, pIS_TO_ROTATE_RIGHT_IF_RING MUST BE false. THIS IS TO
	KEEP THE ALGORITHM CLOSE TO THE ONE FROM THE RING CLASS. BY DEFINITION, A LEFT ROTATION
	CHANGES THE START INDEX, WHILE THE RIGHT ROTATION DOES NOT.
*/
#define CRX__C__TREE__PRIVATE__INSERT_SPACE_AT(pIS_RING, pTYPE, \
		pFUNC_TYPE_MOVE_CONSTRUCTOR, pFUNC_TYPE_MOVE_DESTRUCTOR, pCAPACITY_WHEN_RING, \
		pIS_TO_ROTATE_RIGHT_IF_RING, pNODE, pBUFFER, pLENGTH, pINDEX, pWIDTH) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_RING)) \
		( \
			CRXM__IFELSE(CRXM__OR(pFUNC_TYPE_MOVE_CONSTRUCTOR, pFUNC_TYPE_MOVE_DESTRUCTOR)) \
			( \
				CRXM__IFELSE(pFUNC_TYPE_MOVE_CONSTRUCTOR) \
				( \
					CRX_FOR(size_t tI = pLENGTH - 1, tI >= pINDEX, tI--) \
					{ \
						pFUNC_TYPE_MOVE_CONSTRUCTOR(pBUFFER + pINDEX + tI + pWIDTH, \
								pBUFFER + pINDEX + tI); \
\
						CRXM__IFELSE2(pFUNC_TYPE_MOVE_DESTRUCTOR, \
						pFUNC_TYPE_MOVE_DESTRUCTOR(pBUFFER + pINDEX + tI);, ) \
					} \
					CRX_ENDFOR \
				) \
				( \
					CRX_FOR(size_t tI = pLENGTH - 1, tI >= pINDEX, tI--) \
					{ \
						memcpy(pBUFFER + pINDEX + tI + pWIDTH, \
								pBUFFER + pINDEX + tI, sizeof(pTYPE)); \
\
						CRXM__IFELSE2(pFUNC_TYPE_MOVE_DESTRUCTOR, \
						pFUNC_TYPE_MOVE_DESTRUCTOR(pBUFFER + pINDEX + tI);, ) \
					} \
					CRX_ENDFOR \
				) \
			) \
			( \
				memmove(pBUFFER + pINDEX + pWIDTH, pBUFFER + pINDEX, \
						(pLENGTH - pINDEX) * sizeof(pTYPE)); \
			) \
		) \
		( \
			pTYPE * tBuffer = pBUFFER - pNODE->gPrivate_startIndex; \
			size_t tLength = pLENGTH; \
\
			if(pINDEX == 0) \
			{ \
				assert(!pIS_TO_ROTATE_RIGHT_IF_RING); \
\
				/*if(pNODE->gPrivate_startIndex > pWIDTH) \
					{pNODE->gPrivate_startIndex = ((pSIZE_T)(pNODE->gPrivate_startIndex - pWIDTH));} \
				else \
					{pNODE->gPrivate_startIndex = ((pSIZE_T)(pCAPACITY_WHEN_RING - (pWIDTH - pNODE->gPrivate_startIndex)));}*/ \
			} \
			else if((pINDEX == tLength) && pIS_TO_ROTATE_RIGHT_IF_RING) \
				{} \
			else \
			{ \
				size_t tInsertIndex = (pNODE->gPrivate_startIndex + pINDEX) & (pCAPACITY_WHEN_RING - 1); \
\
				assert(tInsertIndex != pNODE->gPrivate_startIndex); \
\
				CRXM__IFELSE(CRXM__OR(pFUNC_TYPE_MOVE_CONSTRUCTOR, pFUNC_TYPE_MOVE_DESTRUCTOR)) \
				( \
					CRXM__IFELSE(pFUNC_TYPE_MOVE_CONSTRUCTOR) \
					( \
						/*if((tLength >> 1) < pINDEX)*/ \
						if(pIS_TO_ROTATE_RIGHT_IF_RING) \
						{ \
							CRX_FOR(size_t tI = tLength - 1, tI >= pINDEX, tI--) \
							{ \
								pFUNC_TYPE_MOVE_CONSTRUCTOR( \
										tBuffer + ((pNODE->gPrivate_startIndex + tI + pWIDTH) & (pCAPACITY_WHEN_RING - 1)), \
										tBuffer + ((pNODE->gPrivate_startIndex + tI) & (pCAPACITY_WHEN_RING - 1))); \
\
								CRXM__IFELSE2(pFUNC_TYPE_MOVE_DESTRUCTOR, \
								pFUNC_TYPE_MOVE_DESTRUCTOR(tBuffer + \
										((pNODE->gPrivate_startIndex + tI) & (pCAPACITY_WHEN_RING - 1)));, ) \
							} \
							CRX_ENDFOR \
						} \
						else \
						{ \
							CRX_FOR(size_t tI = 0, tI < pINDEX, tI++) \
							{ \
								pFUNC_TYPE_MOVE_CONSTRUCTOR( \
										tBuffer + ((pNODE->gPrivate_startIndex + tI + \
												pCAPACITY_WHEN_RING - pWIDTH) & \
												(pCAPACITY_WHEN_RING - 1)), \
										tBuffer + ((pNODE->gPrivate_startIndex + tI) & \
												(pCAPACITY_WHEN_RING - 1))); \
\
								CRXM__IFELSE2(pFUNC_TYPE_MOVE_DESTRUCTOR, \
								pFUNC_TYPE_MOVE_DESTRUCTOR(tBuffer + \
										((pNODE->gPrivate_startIndex + tI) & \
										(pCAPACITY_WHEN_RING - 1)));, ) \
							} \
							CRX_ENDFOR \
\
							/*pNODE->gPrivate_startIndex = (pNODE->gPrivate_startIndex + pCAPACITY_WHEN_RING - \
									pWIDTH) & (pCAPACITY_WHEN_RING - 1);*/ \
						} \
					) \
					( \
						/*THIS CODE IS NOT OPTIMAL.*/ \
						/*if((tLength >> 1) < pINDEX)*/ \
						if(pIS_TO_ROTATE_RIGHT_IF_RING) \
						{ \
							CRX_FOR(size_t tI = tLength - 1, tI >= pINDEX, tI--) \
							{ \
								memmove(tBuffer + ((pNODE->gPrivate_startIndex + tI + pWIDTH) & \
												(pCAPACITY_WHEN_RING - 1)), \
										tBuffer + ((pNODE->gPrivate_startIndex + tI) & \
												(pCAPACITY_WHEN_RING - 1)), \
										sizeof(pTYPE)); \
\
								pFUNC_TYPE_MOVE_DESTRUCTOR(tBuffer + \
										((pNODE->gPrivate_startIndex + tI) & (pCAPACITY_WHEN_RING - 1))); \
							} \
							CRX_ENDFOR \
						} \
						else \
						{ \
							CRX_FOR(size_t tI = 0, tI < pINDEX, tI++) \
							{ \
								memmove(tBuffer + ((pNODE->gPrivate_startIndex + tI + \
												pCAPACITY_WHEN_RING - pWIDTH) & \
												(pCAPACITY_WHEN_RING - 1)), \
										tBuffer + ((pNODE->gPrivate_startIndex + tI) & \
												(pCAPACITY_WHEN_RING - 1)), \
										sizeof(pTYPE)); \
\
								pFUNC_ELEMENT_MOVE_DESTRUCTOR(tBuffer + \
										((pNODE->gPrivate_startIndex + tI) & \
										(pCAPACITY_WHEN_RING - 1))); \
							} \
							CRX_ENDFOR \
\
							/*pNODE->gPrivate_startIndex = (pNODE->gPrivate_startIndex + pCAPACITY_WHEN_RING - \
									pWIDTH) & (pCAPACITY_WHEN_RING - 1);*/ \
						} \
					) \
				) \
				( \
					/*if((tLength >> 1) >= pINDEX)*/ \
					if(!pIS_TO_ROTATE_RIGHT_IF_RING) \
					{ \
						if(pNODE->gPrivate_startIndex >= pWIDTH) \
						{ \
							if(pNODE->gPrivate_startIndex + 1 <= tInsertIndex) \
							{ \
								memmove(tBuffer + pNODE->gPrivate_startIndex - pWIDTH, \
										tBuffer + pNODE->gPrivate_startIndex, \
										(tInsertIndex - pNODE->gPrivate_startIndex) * \
												sizeof(pTYPE)); \
							} \
							else \
							{ \
								memmove(tBuffer + pNODE->gPrivate_startIndex - pWIDTH, \
										tBuffer + pNODE->gPrivate_startIndex, \
										(pCAPACITY_WHEN_RING - pNODE->gPrivate_startIndex) * sizeof(pTYPE)); \
\
								if(tInsertIndex <= pWIDTH) \
								{ \
									memmove(tBuffer + pCAPACITY_WHEN_RING - pWIDTH, \
											tBuffer, tInsertIndex * sizeof(pTYPE)); \
								} \
								else \
								{ \
									memmove(tBuffer + pCAPACITY_WHEN_RING - pWIDTH, \
											tBuffer, pWIDTH * sizeof(pTYPE)); \
									memmove(tBuffer, \
											tBuffer + pWIDTH, \
											(tInsertIndex - pWIDTH) * sizeof(pTYPE)); \
								} \
							} \
\
							/*pNODE->gPrivate_startIndex = \
									((pSIZE_T)(pNODE->gPrivate_startIndex - pWIDTH));*/ \
						} \
						else \
						{ \
							if(pWIDTH < tInsertIndex) \
							{ \
								memmove(tBuffer + pCAPACITY_WHEN_RING - (pWIDTH - pNODE->gPrivate_startIndex), \
										tBuffer + pNODE->gPrivate_startIndex, \
										(pWIDTH - pNODE->gPrivate_startIndex) * sizeof(pTYPE)); \
								memmove(tBuffer, tBuffer + pWIDTH, \
										(tInsertIndex - pWIDTH) * sizeof(pTYPE)); \
							} \
							else \
							{ \
								memmove(tBuffer + pCAPACITY_WHEN_RING - \
												(pWIDTH - pNODE->gPrivate_startIndex), \
										tBuffer + pNODE->gPrivate_startIndex, \
										(tInsertIndex - pNODE->gPrivate_startIndex) * \
												sizeof(pTYPE)); \
							} \
							/*pNODE->gPrivate_startIndex = ((pSIZE_T)(pCAPACITY_WHEN_RING - (pWIDTH - pNODE->gPrivate_startIndex)));*/ \
						} \
					} \
					else \
					{ \
						size_t tEndIndex = (pNODE->gPrivate_startIndex + tLength - 1) & (pCAPACITY_WHEN_RING - 1); \
\
						if(pCAPACITY_WHEN_RING - 1 - tEndIndex >= pWIDTH) \
						{ \
							if(tEndIndex + 1 >= tInsertIndex) \
							{ \
								memmove(tBuffer + tInsertIndex + pWIDTH, \
										tBuffer + tInsertIndex, \
										(tEndIndex  + 1 - tInsertIndex) * sizeof(pTYPE)); \
							} \
							else \
							{ \
								memmove(tBuffer + pWIDTH, tBuffer, (tEndIndex + 1) * \
										sizeof(pTYPE)); \
\
								if(pCAPACITY_WHEN_RING - tInsertIndex <= pWIDTH) \
								{ \
									memmove(tBuffer + pWIDTH - (pCAPACITY_WHEN_RING - tInsertIndex), \
											tBuffer + tInsertIndex, \
											(pCAPACITY_WHEN_RING - tInsertIndex) * sizeof(pTYPE)); \
								} \
								else \
								{ \
									memmove(tBuffer, tBuffer + pCAPACITY_WHEN_RING - pWIDTH, \
											pWIDTH * sizeof(pTYPE)); \
									memmove(tBuffer + tInsertIndex + pWIDTH, \
											tBuffer + tInsertIndex, \
											(pCAPACITY_WHEN_RING - pWIDTH - tInsertIndex) * sizeof(pTYPE)); \
								} \
							} \
						} \
						else \
						{ \
							if(pCAPACITY_WHEN_RING - pWIDTH > tInsertIndex) \
							{ \
								memmove(tBuffer, tBuffer + pCAPACITY_WHEN_RING - pWIDTH, \
										(tEndIndex + pWIDTH + 1 - pCAPACITY_WHEN_RING) * sizeof(pTYPE)); \
								memmove(tBuffer + tInsertIndex + pWIDTH, tBuffer + tInsertIndex, \
										(pCAPACITY_WHEN_RING - pWIDTH - tInsertIndex) * sizeof(pTYPE)); \
							} \
							else \
							{ \
								memmove(tBuffer, tBuffer + tInsertIndex, \
										(tEndIndex + 1 - tInsertIndex) * sizeof(pTYPE)); \
							} \
						} \
					} \
				) \
			} \
		) \
	}

/*
	NOTE: pINDEX SHOULD BE THE INDEX OF INSERTION OF THE KEY
	NOTE: MAKE SURE TO USE THE SAME VALUE FOR THE PARAMETERS AS YOU USED FOR THE CORRESPONDING
			CALLS TO CRX__C__TREE__PRIVATE__INSERT_SPACE_AT(). HOWEVER FOR pINDEX, USE THE LOWEST 
			INDEX USED IN THE CORRESPONDING CALLS, MEANING THE INDEX USED WHEN INSERTING SPACE IN 
			THE ELEMENTS' BUFFER.
*/
#define CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_INSERTION_OF_SPACE(pIS_RING, pCAPACITY, \
		pIS_TO_ROTATE_RIGHT_IF_RING, pNODE, pINDEX, pWIDTH) \
	{ \
		CRXM__IFELSE(pIS_RING) \
		( \
			if(pINDEX == 0) \
			{ \
				assert(!pIS_TO_ROTATE_RIGHT_IF_RING); \
\
				if(pNODE->gPrivate_startIndex >= pWIDTH) \
					{pNODE->gPrivate_startIndex = pNODE->gPrivate_startIndex - pWIDTH;} \
				else \
					{pNODE->gPrivate_startIndex = pCAPACITY - (pWIDTH - pNODE->gPrivate_startIndex);} \
			} \
			else \
			{ \
				/*if((tLength >> 1) >= pINDEX)*/ \
				if(!pIS_TO_ROTATE_RIGHT_IF_RING) \
				{ \
					/*SEE NOTES OF CRX__C__TREE__PRIVATE__INSERT_SPACE_AT()*/ \
					pNODE->gPrivate_startIndex = (pNODE->gPrivate_startIndex + pCAPACITY - \
							pWIDTH) & (pCAPACITY - 1); \
				} \
			} \
		)() \
	}

//TO BE DELETED.
#define CRX__C__TREE__PRIVATE__REMOVE_FIRST_N(pIS_RING, pTYPE, \
		pFUNC_TYPE_MOVE_CONSTRUCTOR, pFUNC_TYPE_MOVE_DESTRUCTOR, \
		pCAPACITY, pNODE, pBUFFER, pLENGTH, pWIDTH) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_RING)) \
		( \
			CRXM__IFELSE(CRXM__OR(pFUNC_TYPE_MOVE_CONSTRUCTOR, pFUNC_TYPE_MOVE_DESTRUCTOR)) \
			( \
				CRXM__IFELSE(pFUNC_TYPE_MOVE_CONSTRUCTOR) \
				( \
					CRX_FOR(size_t tI = pWIDTH, tI < pLENGTH, tI++) \
					{ \
						pFUNC_TYPE_MOVE_CONSTRUCTOR(pBUFFER + tI - pWIDTH, pBUFFER + tI); \
\
						CRXM__IFELSE2(pFUNC_TYPE_MOVE_DESTRUCTOR, \
						pFUNC_TYPE_MOVE_DESTRUCTOR(pBUFFER + tI);, ) \
					} \
					CRX_ENDFOR \
				) \
				( \
					CRX_FOR(size_t tI = pWIDTH, tI < pLENGTH, tI++) \
					{ \
						memmove(pBUFFER + tI - pWIDTH, pBUFFER + tI, sizeof(pTYPE)); \
\
						pFUNC_TYPE_MOVE_DESTRUCTOR(pBUFFER + tI); \
					} \
					CRX_ENDFOR \
				) \
			) \
			( \
				memmove(pBUFFER, pBUFFER + pWIDTH, (pLENGTH - pWIDTH) * sizeof(pTYPE)); \
			) \
		) \
		( \
			if(pThis->gPrivate_startIndex == pCAPACITY - 1) \
				{pThis->gPrivate_startIndex = 0;} \
			else \
				{pThis->gPrivate_startIndex = pThis->gPrivate_startIndex + 1;} \
		) \
	}

/*
	WARNING: pCAPACITY_WHEN_RING MUST BE THE VALUE APPROPRIATE FOR THE RING MODE.
	WARNING: THIS DOES NOT UPDATE THE STARTING INDEX. 
			CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_REMOVAL_OF_SPACE() MUST BE CALLED 
			LATER TO DO SO.

	THE FOLLOWING IS MEANT TO REMOVE EMPTY SPACE FROM THE INDIVIDUAL BUFFERS IN A NODE.
	THIS FUNCTION IS ALMOST A COPY OF removeElements() FROM THE RING CLASS, EXCEPT THAT IT ASSUMES
	THE SPACE TO BE REMOVED IS ALREADT EMPTY.
*/
#define CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM(pIS_RING, pTYPE, \
		pFUNC_TYPE_MOVE_CONSTRUCTOR, pFUNC_TYPE_MOVE_DESTRUCTOR, pCAPACITY_WHEN_RING, pNODE, \
		pBUFFER, pLENGTH, pINDEX, pWIDTH, pIS_TO_ROTATE_RIGHT_IF_RING) \
	{ \
		CRXM__IFELSE(CRXM__NOT(pIS_RING)) \
		( \
			memmove(pBUFFER + pINDEX, pBUFFER + pINDEX + pWIDTH, \
					(pLENGTH - (pINDEX) - (pWIDTH)) * sizeof(pTYPE)); \
		) \
		( \
			pTYPE * tBuffer = pBUFFER - pNODE->gPrivate_startIndex; \
\
			CRXM__IFELSE(CRXM__OR(pFUNC_TYPE_MOVE_CONSTRUCTOR, pFUNC_TYPE_MOVE_DESTRUCTOR)) \
			( \
				CRXM__IFELSE(pFUNC_TYPE_MOVE_CONSTRUCTOR) \
				( \
					if(pIS_TO_ROTATE_RIGHT_IF_RING) \
					{ \
						CRX_FOR(size_t tI = 0, tI < pINDEX, tI++) \
						{ \
							pFUNC_TYPE_MOVE_CONSTRUCTOR(tBuffer + \
											((pNODE->gPrivate_startIndex + pINDEX + pWIDTH - 1 - tI) & \
											(pCAPACITY_WHEN_RING - 1)), \
									tBuffer + ((pNODE->gPrivate_startIndex + pINDEX - 1 - tI) & \
											(pCAPACITY_WHEN_RING - 1))); \
\
							CRXM__IFELSE2(pFUNC_TYPE_MOVE_DESTRUCTOR, \
									pFUNC_TYPE_MOVE_DESTRUCTOR(tBuffer + \
									((pNODE->gPrivate_startIndex + pINDEX - 1 - tI) & (pCAPACITY_WHEN_RING - 1)));, ) \
						} \
						CRX_ENDFOR \
\
						/*pNODE->gPrivate_startIndex = ((pSIZE_T)((pNODE->gPrivate_startIndex + pWIDTH) & (pCAPACITY_WHEN_RING - 1)));*/ \
					} \
					else \
					{ \
						CRX_FOR(size_t tI = 0, tI < pLENGTH - (pWIDTH) - (pINDEX), tI++) \
						{ \
							pFUNC_TYPE_MOVE_CONSTRUCTOR(tBuffer + \
											((pNODE->gPrivate_startIndex + tI + pINDEX) & (pCAPACITY_WHEN_RING - 1)), \
									tBuffer + ((pNODE->gPrivate_startIndex + tI + pINDEX + pWIDTH) & \
											(pCAPACITY_WHEN_RING - 1))); \
\
							CRXM__IFELSE2(pFUNC_TYPE_MOVE_DESTRUCTOR, \
									pFUNC_TYPE_MOVE_DESTRUCTOR(tBuffer + \
									((pNODE->gPrivate_startIndex + tI + pINDEX + pWIDTH) & (pCAPACITY_WHEN_RING - 1)));, ) \
						} \
						CRX_ENDFOR \
					} \
				) \
				( \
					if(pIS_TO_ROTATE_RIGHT_IF_RING) \
					{ \
						CRX_FOR(size_t tI = 0, tI < pINDEX, tI++) \
						{ \
							memmove(tBuffer + ((pNODE->gPrivate_startIndex + pINDEX + pWIDTH - 1 - tI) & \
											(pCAPACITY_WHEN_RING - 1)), \
									tBuffer + ((pNODE->gPrivate_startIndex + pINDEX - 1 - tI) & \
											(pCAPACITY_WHEN_RING - 1)), \
									sizeof(pTYPE)); \
\
							pFUNC_TYPE_MOVE_DESTRUCTOR(tBuffer + \
									((pNODE->gPrivate_startIndex + pINDEX - 1 - tI) & (pCAPACITY_WHEN_RING - 1))); \
						} \
						CRX_ENDFOR \
\
						/*pNODE->gPrivate_startIndex = ((pSIZE_T)((pNODE->gPrivate_startIndex + pWIDTH) & (pCAPACITY_WHEN_RING - 1)));*/ \
					} \
					else \
					{ \
						CRX_FOR(size_t tI = 0, tI < pLENGTH - (pWIDTH) - (pINDEX), tI++) \
						{ \
							memmove(tBuffer + ((pNODE->gPrivate_startIndex + tI + pINDEX) & (pCAPACITY_WHEN_RING - 1)), \
									tBuffer + ((pNODE->gPrivate_startIndex + tI + pINDEX + pWIDTH) & (pCAPACITY_WHEN_RING - 1)), \
									sizeof(pTYPE)); \
\
							pFUNC_TYPE_MOVE_DESTRUCTOR(tBuffer + \
									((pNODE->gPrivate_startIndex + tI + pINDEX + pWIDTH) & (pCAPACITY_WHEN_RING - 1))); \
						} \
						CRX_ENDFOR \
					} \
				) \
			) \
			( \
				if(pIS_TO_ROTATE_RIGHT_IF_RING) \
				{ \
					if(pINDEX > 0) \
					{ \
						CRX__C__TREE__PRIVATE__ECHO__RAW_ROTATE_RIGHT(sizeof(pTYPE), tBuffer, \
								pNODE->gPrivate_startIndex, ((pNODE->gPrivate_startIndex + pINDEX - 1) & (pCAPACITY_WHEN_RING - 1)), \
								pCAPACITY_WHEN_RING, (pWIDTH), CRXM__FALSE) \
					} \
\
					/*pNODE->gPrivate_startIndex = ((pSIZE_T)((pNODE->gPrivate_startIndex + pWIDTH) & (pCAPACITY_WHEN_RING - 1)));*/ \
				} \
				else \
				{ \
					if(pINDEX + pWIDTH < pLENGTH) \
					{ \
						CRX__C__TREE__PRIVATE__ECHO__RAW_ROTATE_LEFT(sizeof(pTYPE), tBuffer, \
								((pNODE->gPrivate_startIndex + pINDEX + pWIDTH) & (pCAPACITY_WHEN_RING - 1)), \
								((pNODE->gPrivate_startIndex + pLENGTH - 1) & (pCAPACITY_WHEN_RING - 1)), \
								pCAPACITY_WHEN_RING, (pWIDTH), CRXM__FALSE); \
					} \
				} \
			) \
		) \
\
		/*pThis->gPrivate_length = ((pSIZE_T)(pThis->gPrivate_length - (pWIDTH)));*/ \
	} \

/*
	NOTE: MAKE SURE TO USE THE SAME VALUE FOR THE PARAMETERS AS YOU USED FOR THE CORRESPONDING
			CALLS TO CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM().
*/
#define CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_REMOVAL_OF_SPACE(pIS_RING, \
		pCAPACITY_WHEN_RING, pNODE, pWIDTH, pIS_TO_ROTATE_RIGHT_IF_RING) \
	{ \
		CRXM__IFELSE(pIS_RING) \
		( \
			if(pIS_TO_ROTATE_RIGHT_IF_RING) \
			{ \
				pNODE->gPrivate_startIndex = ((pNODE->gPrivate_startIndex + pWIDTH) & \
						(pCAPACITY_WHEN_RING - 1)); \
			} \
		)() \
	} 
	
/*
	WARNING: THE FOLLOWING ASSUMES THAT THE REMAINING SPACE IS LARGER THAN pWIDTH. THIS MEANS THAT
			IT IS ASSUMED THAT THE TAIL WILL NEVER HIT THE ORIGINAL LOCATION OF THE HEAD AFTER 
			ROTATION.

	THE EXISTANCE OF THE FOLLOWING IS A FORMAL LIE, BUT KEEPING TO KEEP THE CODE SIMILAR TO THE CODE
	OF THE RING CLASS. THE FOLLOWING IS BASED ON CRX__C__RING__ECHO__RAW_ROTATE_RIGHT()
*/
#define CRX__C__TREE__PRIVATE__ECHO__RAW_ROTATE_RIGHT(pSIZE_OF_TYPE, pELEMENTS, \
		pRAW_START_INDEX, pRAW_END_INDEX, pCAPACITY, pWIDTH, pNEW_RAW_END_INDEX) \
	{ \
		assert(pWIDTH > 0); \
\
		size_t tStartIndex = pRAW_START_INDEX; \
		size_t tEndIndex = pRAW_END_INDEX; \
		size_t tEmptySpaceBeforeEnd; \
\
		if(tEndIndex < tStartIndex) \
			{tEmptySpaceBeforeEnd = 0;} \
		else \
			{tEmptySpaceBeforeEnd = pCAPACITY - tEndIndex - 1;} \
\
		if(tEndIndex < tStartIndex) \
		{ \
			memmove(pELEMENTS + pWIDTH, pELEMENTS, \
					/*tEndIndex * pSIZE_OF_TYPE*/ \
					(tEndIndex + 1) * pSIZE_OF_TYPE); \
		} \
\
		if(pWIDTH <= tEmptySpaceBeforeEnd) \
		{ \
			memmove(pELEMENTS + tStartIndex + pWIDTH, pELEMENTS + tStartIndex, \
					(tEndIndex + 1 - tStartIndex) * pSIZE_OF_TYPE); \
\
			CRXM__IFELSE2(pNEW_RAW_END_INDEX, \
			pNEW_RAW_END_INDEX = tEndIndex + pWIDTH;, ) \
		} \
		else \
		{ \
			if(pWIDTH < pCAPACITY - tStartIndex) \
			{ \
				memcpy(pELEMENTS, pELEMENTS + pCAPACITY - (pWIDTH - tEmptySpaceBeforeEnd), \
							(pWIDTH - tEmptySpaceBeforeEnd) * pSIZE_OF_TYPE); \
\
				memmove(pELEMENTS + tStartIndex + pWIDTH, pELEMENTS + tStartIndex, \
						(pCAPACITY - tStartIndex  - pWIDTH) * pSIZE_OF_TYPE); \
\
				CRXM__IFELSE2(pNEW_RAW_END_INDEX, \
				pNEW_RAW_END_INDEX = pWIDTH - tEmptySpaceBeforeEnd - 1;, ) \
			} \
			else \
			{ \
				memcpy(pELEMENTS + pWIDTH - (pCAPACITY - tStartIndex), pELEMENTS + tStartIndex, \
						(pCAPACITY - tEmptySpaceBeforeEnd - tStartIndex) * pSIZE_OF_TYPE); \
\
				CRXM__IFELSE2(pNEW_RAW_END_INDEX, \
				pNEW_RAW_END_INDEX = pWIDTH - tEmptySpaceBeforeEnd - 1;, ) \
			} \
		} \
	}
//#END_DEFINE

/*
	WARNING: THE FOLLOWING ASSUMES THAT THE REMAINING SPACE IS LARGER THAN pWIDTH. THIS MEANS THAT
			IT IS ASSUMED THAT THE HEAD WILL NEVER HIT THE ORIGINAL LOCATION OF THE TAIL AFTER 
			ROTATION.

	THE EXISTANCE OF THE FOLLOWING IS A FORMAL LIE, BUT KEEPING TO KEEP THE CODE SIMILAR TO THE CODE
	OF THE RING CLASS. THE FOLLOWING IS BASED ON CRX__C__RING__ECHO__RAW_ROTATE_LEFT()
*/
#define CRX__C__TREE__PRIVATE__ECHO__RAW_ROTATE_LEFT(pSIZE_OF_TYPE, pELEMENTS, \
		pRAW_START_INDEX, pRAW_END_INDEX, pCAPACITY, pWIDTH, pNEW_RAW_START_INDEX) \
	{ \
		assert(pWIDTH > 0); \
\
		size_t tStartIndex = pRAW_START_INDEX; \
		size_t tEndIndex = pRAW_END_INDEX; \
		size_t tIndexOfFirstElementFromLeftSide; \
\
		if(tStartIndex > tEndIndex) \
			{tIndexOfFirstElementFromLeftSide = 0;} \
		else \
			{tIndexOfFirstElementFromLeftSide = tStartIndex;} \
\
		if(tStartIndex > tEndIndex) \
		{ \
			memmove(pELEMENTS + tStartIndex - pWIDTH, pELEMENTS + tStartIndex, \
					(pCAPACITY - tStartIndex) * pSIZE_OF_TYPE); \
		} \
\
		if(pWIDTH <= tIndexOfFirstElementFromLeftSide) \
		{ \
			memcpy(pELEMENTS + tStartIndex - pWIDTH, pELEMENTS + tStartIndex, \
					/*(tStartIndex + 1 - tStartIndex) * pSIZE_OF_TYPE*/ \
					(tEndIndex + 1 - tStartIndex) * pSIZE_OF_TYPE); \
\
			CRXM__IFELSE2(pNEW_RAW_START_INDEX, \
			pNEW_RAW_START_INDEX = tStartIndex - pWIDTH;, ) \
		} \
		else \
		{ \
			if(pWIDTH <= tEndIndex) \
			{ \
				memcpy(pELEMENTS + pCAPACITY + tIndexOfFirstElementFromLeftSide - pWIDTH, \
						pELEMENTS + tIndexOfFirstElementFromLeftSide, \
						(pWIDTH - tIndexOfFirstElementFromLeftSide) * pSIZE_OF_TYPE); \
\
				memcpy(pELEMENTS, pELEMENTS + pWIDTH, \
						(tEndIndex + 1 - pWIDTH) * pSIZE_OF_TYPE); \
\
				CRXM__IFELSE2(pNEW_RAW_START_INDEX, \
				pNEW_RAW_START_INDEX = pCAPACITY - (pWIDTH - tIndexOfFirstElementFromLeftSide);, ) \
			} \
			else \
			{ \
				memcpy(pELEMENTS + pCAPACITY + tIndexOfFirstElementFromLeftSide - pWIDTH, \
						pELEMENTS + tIndexOfFirstElementFromLeftSide, \
						(tEndIndex + 1 - tIndexOfFirstElementFromLeftSide) * pSIZE_OF_TYPE); \
\
				CRXM__IFELSE2(pNEW_RAW_START_INDEX, \
				pNEW_RAW_START_INDEX = pCAPACITY - (pWIDTH - tIndexOfFirstElementFromLeftSide);, ) \
			} \
		} \
	}
//#END_DEFINE
	
#define CRX__C__TREE__PRIVATE__TRANSFER_CONSTRUCT(pSIZE_OF_TYPE, pFUNC_TYPE_MOVE_CONSTRUCTOR, \
		pFUNC_TYPE_MOVE_DESTRUCTOR, pOBJECT, pOBJECT___2) \
	{ \
		CRXM__IFELSE(CRXM__OR(pFUNC_TYPE_MOVE_CONSTRUCTOR, pFUNC_TYPE_MOVE_DESTRUCTOR)) \
		( \
			CRXM__IFELSE(pFUNC_TYPE_MOVE_CONSTRUCTOR) \
			( \
				pFUNC_TYPE_MOVE_CONSTRUCTOR(pOBJECT, pOBJECT___2); \
			) \
			( \
				memcpy(pOBJECT, pOBJECT___2, pSIZE_OF_TYPE); \
			) \
\
			CRXM__IFELSE2(pFUNC_TYPE_MOVE_DESTRUCTOR, \
			pFUNC_TYPE_MOVE_DESTRUCTOR(pOBJECT___2);, ) \
		) \
		( \
			memcpy(pOBJECT, pOBJECT___2, pSIZE_OF_TYPE); \
		) \
	}

/*#define CRX__TREE__PRIVATE__ROUND_TO_TWO(pN) (((pN) + 1) >> 1 << 1)*/
#define CRX__TREE__PRIVATE__ROUND_TO_FOUR(pN) (((pN) + 3) >> 2 << 2)
#define CRX__TREE__PRIVATE__ROUND_TO_EIGHT(pN) (((pN) + 7) >> 3 << 3)
#define CRX__TREE__PRIVATE__ROUND_TO_SIXTEEN(pN) (((pN) + 15) >> 4 << 4)

#if(CRX__ARCHITECTURE__SIZE != CRX__ARCHITECTURE__SIZE__UNKNOWN)
	#if(CRX__ARCHITECTURE__SIZE <= 32)
		#define CRX__TREE__PRIVATE__ROUND_TO_POINTER_ALIGNMENT(pN) \
				CRX__TREE__PRIVATE__ROUND_TO_FOUR(pN)
		#define CRX__TREE__PRIVATE__ROUND_TO_GENERAL_ALIGNMENT(pN) \
				CRX__TREE__PRIVATE__ROUND_TO_EIGHT(pN)
		#define CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_POINTER 3
		#define CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_GENERAL_ALIGNMENT 7
	#else
		#define CRX__TREE__PRIVATE__ROUND_TO_POINTER_ALIGNMENT(pN) \
				CRX__TREE__PRIVATE__ROUND_TO_EIGHT(pN)
		#define CRX__TREE__PRIVATE__ROUND_TO_GENERAL_ALIGNMENT(pN) \
				CRX__TREE__PRIVATE__ROUND_TO_SIXTEEN(pN)
		#define CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_POINTER 7
		#define CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_GENERAL_ALIGNMENT 15
	#endif
#else
	#define CRX__TREE__PRIVATE__ROUND_TO_POINTER_ALIGNMENT(pN) \
			CRX__TREE__PRIVATE__ROUND_TO_EIGHT(pN)
	#define CRX__TREE__PRIVATE__ROUND_TO_GENERAL_ALIGNMENT(pN) \
			CRX__TREE__PRIVATE__ROUND_TO_SIXTEEN(pN)
	#define CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_POINTER 7
	#define CRX__TREE__PRIVATE__MAXIMUM_PADDING_BECAUSE_OF_GENERAL_ALIGNMENT 15
#endif



#define CRX__C__TREE__PRIVATE__IS_BIT_SET(pUINT32__FLAGS, pN) \
		(((pUINT32__FLAGS) & (1 << (pN))) ? true : false)
#define CRX__C__TREE__PRIVATE__ECHO_ARE_INDICES_IN_INTERNAL_NODES_ONLY \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_info, 0)
#define CRX__C__TREE__PRIVATE__ECHO_IS_ELEMENT_DATA_IN_LEAVES_ONLY \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_info, 1)
#define CRX__C__TREE__PRIVATE__ECHO_IS_ELEMENT_DATA_IN_LEAVES_ONLY2(pTREE) \
		CRX__C__TREE__PRIVATE__IS_BIT_SET((pTREE)->gPrivate_info, 1)
#define CRX__C__TREE__PRIVATE__ECHO_IS_ELEMENT_DATA_IN_LEAVES_ONLY3(pIFNO) \
		CRX__C__TREE__PRIVATE__IS_BIT_SET((pIFNO), 1)
#define CRX__C__TREE__PRIVATE__ECHO_IS_TO_USE_DELEGATION \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_info, 2)
#define CRX__C__TREE__PRIVATE__ECHO_IS_TO_USE_DELEGATION3(pIFNO) \
		CRX__C__TREE__PRIVATE__IS_BIT_SET((pIFNO), 2)
#define CRX__C__TREE__PRIVATE__ECHO_IS_PERSISTANT \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_info, 3)
#define CRX__C__TREE__PRIVATE__ECHO_IS_PERSISTANT3(pIFNO) \
		CRX__C__TREE__PRIVATE__IS_BIT_SET((pIFNO), 3)
#define CRX__C__TREE__PRIVATE__ECHO_IS_CONSERVATIVE_IN_GROWTH \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_info, 4)
#define CRX__C__TREE__PRIVATE__ECHO_IS_PREEMPTIVE \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_info, 5)
#define CRX__C__TREE__PRIVATE__ECHO_IS_TO_USE_RINGS \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_info, 6)
#define CRX__C__TREE__PRIVATE__ECHO_HAS_INDEX \
		(pThis->gPrivate_typeBluePrint__index != NULL)
		
#define CRX__C__TREE__FLAG__INDICES_IN_INTERNAL_NODES_ONLY 	1
#define CRX__C__TREE__FLAG__ELEMENT_DATA_IN_LEAVES_ONLY		2
#define CRX__C__TREE__FLAG__USES_DELEGATION					4
#define CRX__C__TREE__FLAG__PERSISTANT						8
#define CRX__C__TREE__FLAG__CONSERVATIVE_IN_GROWTH			16
#define CRX__C__TREE__FLAG__PREEMPTIVE						32
#define CRX__C__TREE__FLAG__USES_RINGS						64


#define CRX__C__TREE__ITERATOR__PRIVATE__ECHO_ARE_INDICES_IN_INTERNAL_NODES_ONLY \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_tree->gPrivate_info, 0)
#define CRX__C__TREE__ITERATOR__PRIVATE__ECHO_IS_ELEMENT_DATA_IN_LEAVES_ONLY \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_tree->gPrivate_info, 1)
#define CRX__C__TREE__ITERATOR__PRIVATE__ECHO_IS_ELEMENT_DATA_IN_LEAVES_ONLY2(pITERATOR) \
		CRX__C__TREE__PRIVATE__IS_BIT_SET((pITERATOR)->gPrivate_tree->gPrivate_info, 1)
#define CRX__C__TREE__ITERATOR__PRIVATE__ECHO_IS_TO_USE_DELEGATION \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_tree->gPrivate_info, 2)
#define CRX__C__TREE__ITERATOR__PRIVATE__ECHO_IS_PERSISTANT \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_tree->gPrivate_info, 3)
/*#define CRX__C__TREE__ITERATOR__PRIVATE__ECHO_IS_CONSERVATIVE_IN_GROWTH \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_tree->gPrivate_info, 4)*/
#define CRX__C__TREE__ITERATOR__PRIVATE__ECHO_IS_PREEMPTIVE \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_tree->gPrivate_info, 5)
#define CRX__C__TREE__ITERATOR__PRIVATE__ECHO_IS_TO_USE_RINGS \
		CRX__C__TREE__PRIVATE__IS_BIT_SET(pThis->gPrivate_tree->gPrivate_info, 6)
#define CRX__C__TREE__ITERATOR__PRIVATE__ECHO_HAS_INDEX \
		(pThis->gPrivate_tree->gPrivate_typeBluePrint__index != NULL)

typedef struct Crx_C_Tree_Private_Node Crx_C_Tree_Private_Node;
typedef struct Crx_C_Tree_Iterator Crx_C_Tree_Iterator;
typedef void(* Crx_C_Tree_ConstructIndexFrom)(void * CRX_NOT_NULL pIndex, 
		void const * CRX_NOT_NULL pElement);
typedef struct Crx_C_Tree
{
	CRX_FRIEND_CLASS(Crx_C_Tree_Private_Node)

	Crx_C_TypeBluePrint const * CRX_NOT_MINE gPrivate_typeBluePrint__element;
	Crx_C_TypeBluePrint const * CRX_NOT_MINE gPrivate_typeBluePrint__index;
	uint32_t gPrivate_info; /*	bit 00: ARE_INDICES_IN_INTERNAL_NODES_ONLY
								bit 01: IS_ELEMENT_DATA_IN_LEAVES_ONLY
								bit 02: IS_TO_USE_DELEGATION
								bit 03: IS_PERSISTANT
								bit 04: IS_CONSERVATIVE_IN_GROWTH
								bit 05: IS_PREEMPTIVE
								bit 06: IS_TO_USE_RINGS */
	Crx_C_TypeBluePrint_GetOrderOfObjects gPrivate_getOrderOfElements;
	Crx_C_TypeBluePrint_GetOrderOfObjects gPrivate_getOrderOfIndices;
	Crx_C_Tree_ConstructIndexFrom gPrivate_constructIndexFrom;
	Crx_C_Tree_Private_Node * gPrivate_node__root;
	size_t gPrivate_internalNode_byteOffsetToChildNodes;
	size_t gPrivate_internalNode_byteOffsetToElementData;
	size_t gPrivate_leafNode_byteOffsetToElementData;
	size_t gPrivate_internalNode_byteLength;
	size_t gPrivate_leafNode_byteLength;
	size_t gPrviate_countOfMidElementInNode;
	size_t gPrivate_numberOfElements;
	size_t gPrivate_numberOfNodes;
} Crx_C_Tree;

/*WITHOUT INDEX, PRIMARY ENTRIES EVERYWHERE
	
	ALLOWED FLAGS:
			CRX__C__TREE__FLAG__PERSISTANT
			CRX__C__TREE__FLAG__CONSERVATIVE_IN_GROWTH
			CRX__C__TREE__FLAG__PREEMPTIVE
			CRX__C__TREE__FLAG__USES_RINGS
*/
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		size_t pCountOfMidElementInNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct2(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		size_t pDesiredNumberOfElementsPerNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct3(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		size_t pDesiredByteSizeOfNode, bool pIsToBaseOnLeafNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct4(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		size_t pDesiredByteSizeOfHotRegionInNode);

/*WITHOUT INDEX, PRIMARY ENTRIES IN LEAVES ONLY. ELEMENT MUST BE COPYABLE

	ALLOWED FLAGS
			CRX__C__TREE__FLAG__USES_DELEGATION
			CRX__C__TREE__FLAG__PERSISTANT
			CRX__C__TREE__FLAG__CONSERVATIVE_IN_GROWTH
			CRX__C__TREE__FLAG__PREEMPTIVE
			CRX__C__TREE__FLAG__USES_RINGS
*/
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct5(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		size_t pCountOfMidElementInNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct6(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		size_t pDesiredNumberOfElementsPerNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct7(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		size_t pDesiredByteSizeOfNode, bool pIsToBaseOnLeafNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct8(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		size_t pDesiredByteSizeOfHotRegionInNode);

/*WITHOUT INDEX, PRIMARY ENTRIES IN LEAVES ONLY. ELEMENT MUST BE NON COPYABLE

	ALLOWED FLAGS
			CRX__C__TREE__FLAG__CONSERVATIVE_IN_GROWTH
			CRX__C__TREE__FLAG__PREEMPTIVE
			CRX__C__TREE__FLAG__USES_RINGS
*/
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct9(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		size_t pCountOfMidElementInNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct10(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		size_t pDesiredNumberOfElementsPerNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct11(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		size_t pDesiredByteSizeOfNode, bool pIsToBaseOnLeafNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct12(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		size_t pDesiredByteSizeOfHotRegionInNode);

/*WITH INDEX

	ALLOWED FLAGS
			CRX__C__TREE__FLAG__INDICES_IN_INTERNAL_NODES_ONLY
			CRX__C__TREE__FLAG__ELEMENT_DATA_IN_LEAVES_ONLY
			CRX__C__TREE__FLAG__USES_DELEGATION
			CRX__C__TREE__FLAG__PERSISTANT
			CRX__C__TREE__FLAG__CONSERVATIVE_IN_GROWTH
			CRX__C__TREE__FLAG__PREEMPTIVE
			CRX__C__TREE__FLAG__USES_RINGS
*/
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct13(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__index, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfIndices,
		Crx_C_Tree_ConstructIndexFrom CRX_NOT_NULL pFunc_constructIndexFrom,		
		size_t pCountOfMidElementInNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct14(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__index, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfIndices, 
		Crx_C_Tree_ConstructIndexFrom CRX_NOT_NULL pFunc_constructIndexFrom,
		size_t pDesiredNumberOfElementsPerNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct15(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__index, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfIndices, 
		Crx_C_Tree_ConstructIndexFrom CRX_NOT_NULL pFunc_constructIndexFrom,
		size_t pDesiredByteSizeOfNode, bool pIsToBaseOnLeafNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_construct16(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__index, uint32_t pOptions, 
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfIndices, 
		Crx_C_Tree_ConstructIndexFrom CRX_NOT_NULL pFunc_constructIndexFrom,
		size_t pDesiredByteSizeOfHotRegionInNode);


CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_private_construct(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element,
		Crx_C_TypeBluePrint const * pTypeBluePrint__index, 
		uint32_t pOptions,
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		Crx_C_TypeBluePrint_GetOrderOfObjects pFunc_getOrderOfIndices,
		Crx_C_Tree_ConstructIndexFrom pFunc_constructIndexFrom,
		size_t pCountOfMidElementInNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_private_construct2(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element,
		Crx_C_TypeBluePrint const * pTypeBluePrint__index,
		uint32_t pOptions,
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		Crx_C_TypeBluePrint_GetOrderOfObjects pFunc_getOrderOfIndices,
		Crx_C_Tree_ConstructIndexFrom pFunc_constructIndexFrom,
		size_t pDesiredNumberOfElementsPerNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_private_construct3(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element,
		Crx_C_TypeBluePrint const * pTypeBluePrint__index,
		uint32_t pOptions,
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		Crx_C_TypeBluePrint_GetOrderOfObjects pFunc_getOrderOfIndices,
		Crx_C_Tree_ConstructIndexFrom pFunc_constructIndexFrom,
		size_t pDesiredByteSizeOfNode, bool pIsToBaseOnLeafNode);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_private_construct4(Crx_C_Tree * pThis,
		Crx_C_TypeBluePrint const * CRX_NOT_NULL pTypeBluePrint__element,
		Crx_C_TypeBluePrint const * pTypeBluePrint__index,
		uint32_t pOptions,
		Crx_C_TypeBluePrint_GetOrderOfObjects CRX_NOT_NULL pFunc_getOrderOfElements,
		Crx_C_TypeBluePrint_GetOrderOfObjects pFunc_getOrderOfIndices,
		Crx_C_Tree_ConstructIndexFrom pFunc_constructIndexFrom,
		size_t pDesiredByteSizeOfHotRegionInNode);

CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_copyConstruct(Crx_C_Tree * pThis,
		Crx_C_Tree const * CRX_NOT_NULL pTree);
CRX__LIB__PRIVATE_C_FUNCTION() bool crx_c_tree_private_copyConstruct__finishBuildingNode(
		Crx_C_Tree * pThis, Crx_C_Tree const * CRX_NOT_NULL pTree,
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode__target,
		Crx_C_Tree_Private_Node const * pNode__source,
		unsigned char * pElement__lastSeenNonFirstChildInTarget /*unsigned char * * */);

CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_destruct(Crx_C_Tree * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_free(Crx_C_Tree * pThis);

CRX__C__TYPE_BLUE_PRINT__GENERIC__DECLARE_GET_BLUE_PRINT(
			Crx_C_Tree, crx_c_tree_,
			CRXM__TRUE, CRXM__TRUE,
			CRXM__TRUE, CRXM__TRUE,
			CRXM__FALSE, CRXM__FALSE);

CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_deleteNode(Crx_C_Tree * pThis,
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode);

CRX__LIB__PRIVATE_C_FUNCTION() size_t crx_c_tree_private_getSuitableImagineryIndexFor(
		Crx_C_Tree * pThis, Crx_C_Tree_Private_Node const * CRX_NOT_NULL pNode,
		void const * pElement,
		void const * pIndex__guide,
		int32_t * pZeroIfFoundOrResultOfComparisonWithLargestKeyInNode);

CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_transferPushFromNodeToNode(
		Crx_C_Tree * pThis, Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode,
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode__target,
		bool pIsToIncludeBegginingChildNode, size_t pStartingIndex);

CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_transferAllIntoNode(
		Crx_C_Tree * pThis, void * pIndex__guide,
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode__child,
		void * pElement,
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode,
		size_t pIndex, bool pIsToIncludeBegginingChildNode);

CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_removeFirstNEntriesFrom(
		Crx_C_Tree * pThis, Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode,
		size_t pWidth);

CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_rotateRight(Crx_C_Tree * pThis,
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode, size_t pIndexOfNodeInParent,
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode__parent,
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode__rightSibling);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_rotateLeft(Crx_C_Tree * pThis,
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode, size_t pIndexOfNodeInParent,
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode__parent,
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode__leftSibling);

/*REMEMBER: IN THE PRE EMPTIVE CASE, THIS MUST NOT MODIFY *pIndicesOfNodesInParents, MEANING
		pIndexOfNodeInParent*/
CRX__LIB__PRIVATE_C_FUNCTION() uint32_t crx_c_tree_private_resolveFullNode(Crx_C_Tree * pThis,
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode,
		Crx_C_Tree_Private_Node * pNode__parent,
		size_t * CRX_NOT_NULL pIndicesOfNodesInParents /*pIndexOfNodeInParent*/);

CRX__LIB__PRIVATE_C_FUNCTION() bool crx_c_tree_private_transferAndInsertElementEntry(
		Crx_C_Tree * pThis, void * CRX_NOT_NULL pElement);
CRX__LIB__PRIVATE_C_FUNCTION() bool crx_c_tree_private_transferAndInsertElementEntry__do(
		Crx_C_Tree * pThis, Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode,
		size_t * pIndexOfNodeInParent,
		void * pIndex__guide,
		void * CRX_NOT_NULL pElement);

CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_tree_tryMoveAndInsertElement(Crx_C_Tree * pThis,
		void * CRX_NOT_NULL pElement);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_tree_insertElement(Crx_C_Tree * pThis,
		void * CRX_NOT_NULL pElement);

CRX__LIB__PRIVATE_C_FUNCTION() Crx_C_Tree_Private_Node * 
		crx_c_tree_mergeTwoNodesAndGetRemainingNode(Crx_C_Tree * pThis, 
		Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode, size_t pIndex);

CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_tree_removeElement(Crx_C_Tree * pThis,
		void const * CRX_NOT_NULL pElement);
CRX__LIB__PRIVATE_C_FUNCTION() bool crx_c_tree_private_removeElement__do(
		Crx_C_Tree * pThis, uint32_t pMode, Crx_C_Tree_Private_Node * pNode,
		void * pIndex__guide, void * pElement,
		Crx_C_Tree_Iterator * pIterator,
		void * pIndex__out, void * pElement__out);
CRX__LIB__PRIVATE_C_FUNCTION() uint32_t crx_c_tree_private_removeElement__do__findExactEntry(
		Crx_C_Tree * pThis, void * pIndex__guide, void const * pElement,
		Crx_C_Tree_Iterator const * pIterator,
		Crx_C_Tree_Iterator * pIterator__return);

CRX__LIB__PRIVATE_C_FUNCTION() size_t crx_c_tree_private_findChildNodeIndexInParent(
		Crx_C_Tree * pThis, Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode);

CRX__LIB__PRIVATE_C_FUNCTION() size_t crx_c_tree_private_getTraceOfLeafNode(
		Crx_C_Tree * pThis, Crx_C_Tree_Private_Node * CRX_NOT_NULL pNode,
		Crx_C_Tree_Private_Node * * CRX_NOT_NULL pNodes,
		size_t * CRX_NOT_NULL pIndices);

CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_decrementNumberOfElements(
		Crx_C_Tree * pThis);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_decrementNumberOfNodes(
		Crx_C_Tree * pThis);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_unsafePopRootNode(
		Crx_C_Tree * pThis);

/*
MEANT TO TRANSFER THE CONTENT OF THE SEPERATE BUFFERS IN THE NODES, WHERE EACH CALL IS TO 
TRANSFER ONE BUFFER'S CONTENT. THE TARGET SPACE MUST ALREADY BE EMPTY.

BASED ON CRX__C__RING__ECHO__COPY_FROM_RING_RANGE.

WARNING: pCAPACITY_WHEN_RING MUST BE THE VALUE APPROPRIATE FOR THE RING MODE.
*/
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_transfer(Crx_C_Tree * pThis, 
		size_t pByteSizeOfType, Crx_C_TypeBluePrint_MoveConstruct pFunc_moveConstruct,
		Crx_C_TypeBluePrint_MoveDestruct pFunc_moveDestruct,
		unsigned char * pTarget, Crx_C_Tree_Private_Node * pTarget_node, size_t pTarget_index, 
		unsigned char * pSrc, Crx_C_Tree_Private_Node * pSrc_node, size_t pSrc_index, 
		size_t pCount);
/*
MEANT TO COPY THE CONTENT OF THE SEPERATE BUFFERS IN THE NODES, WHERE EACH CALL IS TO COPY 
ONE BUFFER'S CONTENT. THE TARGET SPACE MUST ALREADY BE EMPTY.

BASED ON CRX__C__RING__ECHO__COPY_FROM_RING_RANGE.

WARNING: pCAPACITY MUST BE THE VALUE APPROPRIATE FOR THE RING MODE.
*/
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_copy(Crx_C_Tree * pThis,
		size_t pByteSizeOfType, Crx_C_TypeBluePrint_CopyConstruct pFunc_copyConstruct,
		unsigned char * pTarget, Crx_C_Tree_Private_Node * pTarget_node, size_t pTarget_index, 
		unsigned char * pSrc, Crx_C_Tree_Private_Node const * pSrc_node, size_t pSrc_index, 
		size_t pCount);

/*
WARNING: pCAPACITY_WHEN_RING MUST BE THE VALUE APPROPRIATE FOR THE RING MODE.
WARNING: THIS DOES NOT UPDATE THE STARTING INDEX. 
		CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_INSERTION_OF_SPACE() MUST BE CALLED 
		LATER TO DO SO.

THIS FUNCTION IS A COPY OF A SIMILAR FUNCTION FROM THE RING CLASS, THE OLD IMPLEMENTATION
OF CRX__C__Ring__ECHO_INSERT_SPACE_AT(), AND LIKE THAT IMPLEMENTATION, THIS FUNCTION DOES NOT 
ATTEMPT TO REDUCE THE RANGE OF CALCULATIONS OVER size_t, MAKING THE MAXIMUM CAPACITY ALLOWED TO 
BE 1/3 OF size_t, UNLIKE THE RING WHERE IT IS 1/2 UNDER THE NEW IMPLEMENTATION OF
CRX__C__Ring__ECHO_INSERT_SPACE_AT(). IN OUR CASE, WE WOULD BE ELEMINATING THE FIRST TWO BITS 
FROM uint32_t GIVING A MAXIMUM CAPACITY PER NODE OF 2^30. THIS IS ALSO THE REASON BEHIND THE 
SIMPLIFIED IMPLEMENTATION IN 
CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_INSERTION_OF_SPACE() AND WHY WE CAN AVOID 
pFUNC_TYPE_MOVE_CONSTRUCTOR AND pFUNC_TYPE_MOVE_DESTRUCTOR IN THAT FUNCTION.

TO KEEP THE ROTATION CONSISTANT BETWEEN ALL BUFFERS WITHIN THE SAME NODE FOR THE SAME HIGH
LEVEL OPERATION, IT IS UP TO THE USER TO DECIDE WHICH DIRECTION THE ROTATION HAPPENS TO CREATE
THE SPACE. HOWEVER, IF pINDEX IS ZERO, pIS_TO_ROTATE_RIGHT_IF_RING MUST BE false. THIS IS TO
KEEP THE ALGORITHM CLOSE TO THE ONE FROM THE RING CLASS. BY DEFINITION, A LEFT ROTATION
CHANGES THE START INDEX, WHILE THE RIGHT ROTATION DOES NOT.
*/
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_insertSpaceAt(Crx_C_Tree * pThis,
		size_t pByteSizeOfType, Crx_C_TypeBluePrint_MoveConstruct pFunc_moveConstruct,
		Crx_C_TypeBluePrint_MoveDestruct pFunc_moveDestruct, bool pIsToRotateRightIfRing,
		Crx_C_Tree_Private_Node * pNode, unsigned char * pBuffer, size_t pLength, size_t pIndex,
		size_t pWidth);
/*
NOTE: pINDEX SHOULD BE THE INDEX OF INSERTION OF THE KEY
NOTE: MAKE SURE TO USE THE SAME VALUE FOR THE PARAMETERS AS YOU USED FOR THE CORRESPONDING
		CALLS TO CRX__C__TREE__PRIVATE__INSERT_SPACE_AT(). HOWEVER FOR pINDEX, USE THE LOWEST 
		INDEX USED IN THE CORRESPONDING CALLS, MEANING THE INDEX USED WHEN INSERTING SPACE IN 
		THE ELEMENTS' BUFFER.
*/
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_updateStartIndexAfterInsertionOfSpace(
		Crx_C_Tree * pThis, bool pIsToRotateRightIfRing, Crx_C_Tree_Private_Node * pNode,
		size_t pIndex, size_t pWidth);

/*
WARNING: pCAPACITY_WHEN_RING MUST BE THE VALUE APPROPRIATE FOR THE RING MODE.
WARNING: THIS DOES NOT UPDATE THE STARTING INDEX. 
		CRX__C__TREE__PRIVATE__UPDATE_START_INDEX_AFTER_REMOVAL_OF_SPACE() MUST BE CALLED 
		LATER TO DO SO.

THE FOLLOWING IS MEANT TO REMOVE EMPTY SPACE FROM THE INDIVIDUAL BUFFERS IN A NODE.
THIS FUNCTION IS ALMOST A COPY OF removeElements() FROM THE RING CLASS, EXCEPT THAT IT ASSUMES
THE SPACE TO BE REMOVED IS ALREADT EMPTY.
*/
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_removeSpaceFrom(
		Crx_C_Tree * pThis, size_t pByteSizeOfType, 
		Crx_C_TypeBluePrint_MoveConstruct pFunc_moveConstruct,
		Crx_C_TypeBluePrint_MoveDestruct pFunc_moveDestruct, 
		Crx_C_Tree_Private_Node * pNode, unsigned char * pBuffer,
		size_t pLength, size_t pIndex, size_t pWidth,
		bool pIsToRotateRightIfRing);
/*
NOTE: MAKE SURE TO USE THE SAME VALUE FOR THE PARAMETERS AS YOU USED FOR THE CORRESPONDING
		CALLS TO CRX__C__TREE__PRIVATE__REMOVE_SPACE_FROM().
*/
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_updateStartIndexAfterRemovalOfSpace(
		Crx_C_Tree * pThis, Crx_C_Tree_Private_Node * pNode, size_t pWidth,
		bool pIsToRotateRightIfRing);

/*
WARNING: THE FOLLOWING ASSUMES THAT THE REMAINING SPACE IS LARGER THAN pWIDTH. THIS MEANS THAT
		IT IS ASSUMED THAT THE TAIL WILL NEVER HIT THE ORIGINAL LOCATION OF THE HEAD AFTER 
		ROTATION.

THE EXISTANCE OF THE FOLLOWING IS A FORMAL LIE, BUT KEEPING TO KEEP THE CODE SIMILAR TO THE CODE
OF THE RING CLASS. THE FOLLOWING IS BASED ON CRX__C__RING__ECHO__RAW_ROTATE_RIGHT()
*/
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_rawRotateRight(Crx_C_Tree * pThis,
		size_t pByteSizeOfType, unsigned char * pElements, size_t pRawStartIndex, 
		size_t pRawEndIndex, size_t pWidth);
/*
WARNING: THE FOLLOWING ASSUMES THAT THE REMAINING SPACE IS LARGER THAN pWIDTH. THIS MEANS THAT
		IT IS ASSUMED THAT THE HEAD WILL NEVER HIT THE ORIGINAL LOCATION OF THE TAIL AFTER 
		ROTATION.

THE EXISTANCE OF THE FOLLOWING IS A FORMAL LIE, BUT KEEPING TO KEEP THE CODE SIMILAR TO THE CODE
OF THE RING CLASS. THE FOLLOWING IS BASED ON CRX__C__RING__ECHO__RAW_ROTATE_LEFT()
*/
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_rawRotateLeft(Crx_C_Tree * pThis,
		size_t pByteSizeOfType, unsigned char * pElements, size_t pRawStartIndex, 
		size_t pRawEndIndex, size_t pWidth);
		
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_private_transferConstruct(Crx_C_Tree * pThis,
		size_t pByteSizeOfType, Crx_C_TypeBluePrint_MoveConstruct pFunc_moveConstruct,
		Crx_C_TypeBluePrint_MoveDestruct pFunc_moveDestruct, 
		void * pObject, void * pObject__2);

CRX__LIB__PRIVATE_C_FUNCTION() unsigned char * crx_c_tree_private_getElementEntry(
		Crx_C_Tree const * pThis, Crx_C_Tree_Private_Node const * CRX_NOT_NULL pNode, size_t pIndex);
CRX__LIB__PRIVATE_C_FUNCTION() unsigned char * crx_c_tree_private_getElement(
		Crx_C_Tree const * pThis, Crx_C_Tree_Private_Node const * CRX_NOT_NULL pNode, size_t pIndex);
CRX__LIB__PRIVATE_C_FUNCTION() Crx_C_Tree_Private_Node * * crx_c_tree_private_getChildNode(
		Crx_C_Tree const * pThis, Crx_C_Tree_Private_Node const * CRX_NOT_NULL pNode, size_t pIndex);
CRX__LIB__PRIVATE_C_FUNCTION() unsigned char * crx_c_tree_private_getIndexFrom(
		Crx_C_Tree const * pThis, Crx_C_Tree_Private_Node const * CRX_NOT_NULL pNode, size_t pIndex);



typedef struct Crx_C_Tree_Private_Node
{
	CRX_FRIEND_CLASS(Crx_C_Tree)

	bool gPrivate_type; /*0: LEAF.  1: INTERNAL*/
	size_t gPrivate_numberOfEntries; /*= N*/
	Crx_C_Tree_Private_Node * gPrivate_node__parent;
	size_t gPrivate_startIndex;
} Crx_C_Tree_Private_Node;


typedef struct Crx_C_Tree_Private_InternalNode
{
	CRX_FRIEND_CLASS(Crx_C_Tree)

	Crx_C_Tree_Private_Node gPrivate_node;
	union
	{
		/*Crx_C_Tree_Private_MaximallyAlignedType _ufdgd;*/
		/* \
			!pHAS_INDEX: \
						|<-- (X) ELEMENT ENTRIES -->||<-- (X + 1) Node * -->| \
			pHAS_INDEX, !pIS_ELEMENT_DATA_IN_LEAVES_ONLY: \
						|<-- (X) INDICES -->||<-- (X + 1) Node * -->||<-- (X) ELEMENT ENTRIES -->| \
			pHAS_INDEX, pIS_ELEMENT_DATA_IN_LEAVES_ONLY: \
						|<-- (X) INDICES -->||<-- (X + 1) Node * -->| \
		*/
		unsigned char uBytes[1];
		unsigned char uElements[1];
		unsigned char * uElements__2[1];
		unsigned char uIndices[1];
	} gPrivate_buffer;
} Crx_C_Tree_Private_InternalNode;


typedef struct Crx_C_Tree_Private_LeafNode Crx_C_Tree_Private_LeafNode;

typedef struct Crx_C_Tree_Private_LeafNode
{
	CRX_FRIEND_CLASS(Crx_C_Tree)

	Crx_C_Tree_Private_Node gPrivate_node;
	Crx_C_Tree_Private_LeafNode * gPrivate_leafNode__next;
	Crx_C_Tree_Private_LeafNode * gPrivate_leafNode__prev;
	union
	{
		/*Crx_C_Tree_Private_MaximallyAlignedType _ufdgd;*/
		/* \
			!pHAS_INDEX || pARE_INDICES_IN_INTERNAL_NODES_ONLY, \
							|<-- (X) ELEMENT ENTRIES -->| \
			pHAS_INDEX, !pARE_INDICES_IN_INTERNAL_NODES_ONLY: \
							|<-- (X) INDICES -->||<-- (X) ELEMENT ENTRIES -->| \
		*/
		unsigned char uBytes[1];
		unsigned char uElements[1];
		unsigned char * uElements__2[1];
		unsigned char uIndices[1];
	} gPrivate_buffer;
} Crx_C_Tree_Private_LeafNode;


typedef struct Crx_C_Tree_Iterator_Private_Position
		Crx_C_Tree_Iterator_Private_Position;
typedef struct Crx_C_Tree_Iterator
{
	CRX_FRIEND_CLASS(Crx_C_Tree)

	bool gPrivate_isConstant;
	bool gPrivate_isPositionsMine;
	Crx_C_Tree * CRX_NOT_MINE gPrivate_tree;
	Crx_C_Tree_Private_Node * CRX_NOT_MINE gPrivate_node;
	size_t gPrivate_elementIndex;
	Crx_C_Tree_Iterator_Private_Position * gPrivate_positions;
	Crx_C_Tree_Iterator_Private_Position * CRX_NOT_MINE gPrivate_position__current;
} Crx_C_Tree_Iterator;

CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_iterator_construct(
		Crx_C_Tree_Iterator * pThis, Crx_C_Tree * pTree);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_iterator_construct2(
		Crx_C_Tree_Iterator * pThis, Crx_C_Tree const * pTree);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_iterator_private_construct3(
		Crx_C_Tree_Iterator * pThis,
		Crx_C_Tree_Iterator_Private_Position * pPositions,
		Crx_C_Tree const * pTree);
CRX__LIB__PRIVATE_C_FUNCTION() void _crx_c_tree_iterator_construct(
		Crx_C_Tree_Iterator * pThis,
		Crx_C_Tree_Iterator_Private_Position * pPositions,
		bool pIsConstant, Crx_C_Tree * pTree);

CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_iterator_copyConstruct(
		Crx_C_Tree_Iterator * pThis,
		Crx_C_Tree_Iterator const * CRX_NOT_NULL pIterator);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_iterator_private_copyConstructFrom(
		Crx_C_Tree_Iterator * pThis,
		Crx_C_Tree_Iterator_Private_Position * pPositions,
		Crx_C_Tree_Iterator const * CRX_NOT_NULL pIterator);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_iterator_private_copyConstructUsing(
		Crx_C_Tree_Iterator * pThis,
		Crx_C_Tree_Iterator_Private_Position * pPositions,
		Crx_C_Tree_Iterator const * CRX_NOT_NULL pIterator);

CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_Tree_Iterator * crx_c_tree_iterator_new(
		Crx_C_Tree * pTree);
CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_Tree_Iterator * crx_c_tree_iterator_new2(
		Crx_C_Tree const * pTree);
CRX__LIB__PRIVATE_C_FUNCTION() Crx_C_Tree_Iterator * crx_c_tree_iterator_private_new3(
		Crx_C_Tree_Iterator_Private_Position * pPositions,
		Crx_C_Tree const * pTree);
CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_Tree_Iterator * crx_c_tree_iterator_moveNew(
		Crx_C_Tree_Iterator * CRX_NOT_NULL pIterator);
CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_Tree_Iterator * crx_c_tree_iterator_copyNew(
		Crx_C_Tree_Iterator const * CRX_NOT_NULL pIterator);
CRX__LIB__PUBLIC_C_FUNCTION() Crx_C_Tree_Iterator * crx_c_tree_iterator_private_copyNewUsing(
		Crx_C_Tree_Iterator_Private_Position * pPositions,
		Crx_C_Tree_Iterator const * CRX_NOT_NULL pIterator);

CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_iterator_destruct(
		Crx_C_Tree_Iterator * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_iterator_free(Crx_C_Tree_Iterator * pThis);

CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_tree_iterator_copyAssignFrom(
		Crx_C_Tree_Iterator * pThis,
		Crx_C_Tree_Iterator const * CRX_NOT_NULL pIterator);

CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_iterator_associateWith(
		Crx_C_Tree_Iterator * pThis, Crx_C_Tree * pTree);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_iterator_constantAssociateWith(
		Crx_C_Tree_Iterator * pThis, Crx_C_Tree const * pTree);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_iterator_private_doAssociateWith(
		Crx_C_Tree_Iterator * pThis, bool pIsConstant, Crx_C_Tree const * pTree);

CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_iterator_reset(Crx_C_Tree_Iterator * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() void crx_c_tree_iterator_resetToBack(
		Crx_C_Tree_Iterator * pThis);

CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_tree_iterator_isEqualTo(
		Crx_C_Tree_Iterator * pThis, Crx_C_Tree_Iterator const * pIterator);

CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_tree_iterator_next(Crx_C_Tree_Iterator * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_tree_iterator_prev(Crx_C_Tree_Iterator * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_tree_iterator_isValid(
		Crx_C_Tree_Iterator * pThis);

CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_tree_iterator_setToPositionOf(
		Crx_C_Tree_Iterator * pThis, void const * pElement,
		Crx_C_Tree_Edge pEdge);
CRX__LIB__PRIVATE_C_FUNCTION() bool crx_c_tree_iterator_setToPositionOf__do(
		Crx_C_Tree_Iterator * pThis, void const * pIndex__guide,
		void const * pElement, Crx_C_Tree_Edge pEdge);

CRX__LIB__PUBLIC_C_FUNCTION() bool crx_c_tree_iterator_remove(Crx_C_Tree_Iterator * pThis);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_iterator_private_remove__do(
		Crx_C_Tree_Iterator * pThis, uint32_t pMode,
		Crx_C_Tree_Private_Node * pNode,
		Crx_C_Tree_Iterator_Private_Position * pPosition__current,
		size_t * pIndices, size_t pIndexInIndices,
		void * pIndex__guide, void * pElement,
		bool * CRX_NOT_NULL pIsToAdvance,
		void * pIndex__out, void * pElement__out);

CRX__LIB__PUBLIC_C_FUNCTION() unsigned char * crx_c_tree_iterator_get(
		Crx_C_Tree_Iterator const * pThis);
CRX__LIB__PUBLIC_C_FUNCTION() unsigned char const * crx_c_tree_iterator_constantGet(
		Crx_C_Tree_Iterator const * pThis);
CRX__LIB__PRIVATE_C_FUNCTION() unsigned char * crx_c_tree_iterator_private_doGet(
		Crx_C_Tree_Iterator const * pThis);

CRX__LIB__PRIVATE_C_FUNCTION() bool crx_c_tree_iterator_private_depthPush(
		Crx_C_Tree_Iterator * pThis, Crx_C_Tree_Private_Node * pNode,
		size_t pIndex);
CRX__LIB__PRIVATE_C_FUNCTION() void crx_c_tree_iterator_private_depthPop(
		Crx_C_Tree_Iterator * pThis);

CRX__LIB__PRIVATE_C_FUNCTION() bool crx_c_tree_iterator_private_isInInternalNode(
		Crx_C_Tree_Iterator * pThis);
CRX__LIB__PRIVATE_C_FUNCTION() unsigned char * crx_c_tree_iterator_private_getIndex(
		Crx_C_Tree_Iterator * pThis);
CRX__LIB__PRIVATE_C_FUNCTION() unsigned char * crx_c_tree_iterator_private_getEntry(
		Crx_C_Tree_Iterator * pThis);


typedef struct Crx_C_Tree_Iterator_Private_Position
{
	Crx_C_Tree_Private_Node * CRX_NOT_MINE gNode;
	size_t gIndex; /*THIS IS INDEX OF NEXT CHILD IF gNode IS NOT NULL.*/
} Crx_C_Tree_Iterator_Private_Position;

CRX__LIB__C_CODE_END()

#if(CRXM__IS(CRX__LIB__MODE, CRX__LIB__MODE__HEADER_ONLY))
	//INCLUDE THE CORRESPONDING .c.h FILE FROM THE CRXed CODE. DO NOT INCLUDE ANY OTHER FILE
	#include "Crx/C.H/crx/c/Tree.c.h"
#endif
#if(CRX__PREPROCESSOR__HAS_PUSH_MACRO)
	#pragma pop_macro("CRX__LIB__MODE")
#endif

#endif